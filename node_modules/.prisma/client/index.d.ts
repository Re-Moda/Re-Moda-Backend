
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Closet
 * 
 */
export type Closet = $Result.DefaultSelection<Prisma.$ClosetPayload>
/**
 * Model S3Bucket
 * 
 */
export type S3Bucket = $Result.DefaultSelection<Prisma.$S3BucketPayload>
/**
 * Model ClothingItem
 * 
 */
export type ClothingItem = $Result.DefaultSelection<Prisma.$ClothingItemPayload>
/**
 * Model Outfit
 * 
 */
export type Outfit = $Result.DefaultSelection<Prisma.$OutfitPayload>
/**
 * Model OutfitClothingItem
 * 
 */
export type OutfitClothingItem = $Result.DefaultSelection<Prisma.$OutfitClothingItemPayload>
/**
 * Model ChatSession
 * 
 */
export type ChatSession = $Result.DefaultSelection<Prisma.$ChatSessionPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model MCPSession
 * 
 */
export type MCPSession = $Result.DefaultSelection<Prisma.$MCPSessionPayload>
/**
 * Model MCPSessionOutfit
 * 
 */
export type MCPSessionOutfit = $Result.DefaultSelection<Prisma.$MCPSessionOutfitPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.closet`: Exposes CRUD operations for the **Closet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Closets
    * const closets = await prisma.closet.findMany()
    * ```
    */
  get closet(): Prisma.ClosetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s3Bucket`: Exposes CRUD operations for the **S3Bucket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S3Buckets
    * const s3Buckets = await prisma.s3Bucket.findMany()
    * ```
    */
  get s3Bucket(): Prisma.S3BucketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clothingItem`: Exposes CRUD operations for the **ClothingItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClothingItems
    * const clothingItems = await prisma.clothingItem.findMany()
    * ```
    */
  get clothingItem(): Prisma.ClothingItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outfit`: Exposes CRUD operations for the **Outfit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Outfits
    * const outfits = await prisma.outfit.findMany()
    * ```
    */
  get outfit(): Prisma.OutfitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outfitClothingItem`: Exposes CRUD operations for the **OutfitClothingItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutfitClothingItems
    * const outfitClothingItems = await prisma.outfitClothingItem.findMany()
    * ```
    */
  get outfitClothingItem(): Prisma.OutfitClothingItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatSession`: Exposes CRUD operations for the **ChatSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatSessions
    * const chatSessions = await prisma.chatSession.findMany()
    * ```
    */
  get chatSession(): Prisma.ChatSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mCPSession`: Exposes CRUD operations for the **MCPSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MCPSessions
    * const mCPSessions = await prisma.mCPSession.findMany()
    * ```
    */
  get mCPSession(): Prisma.MCPSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mCPSessionOutfit`: Exposes CRUD operations for the **MCPSessionOutfit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MCPSessionOutfits
    * const mCPSessionOutfits = await prisma.mCPSessionOutfit.findMany()
    * ```
    */
  get mCPSessionOutfit(): Prisma.MCPSessionOutfitDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Category: 'Category',
    Closet: 'Closet',
    S3Bucket: 'S3Bucket',
    ClothingItem: 'ClothingItem',
    Outfit: 'Outfit',
    OutfitClothingItem: 'OutfitClothingItem',
    ChatSession: 'ChatSession',
    ChatMessage: 'ChatMessage',
    MCPSession: 'MCPSession',
    MCPSessionOutfit: 'MCPSessionOutfit'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "category" | "closet" | "s3Bucket" | "clothingItem" | "outfit" | "outfitClothingItem" | "chatSession" | "chatMessage" | "mCPSession" | "mCPSessionOutfit"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Closet: {
        payload: Prisma.$ClosetPayload<ExtArgs>
        fields: Prisma.ClosetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClosetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClosetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload>
          }
          findFirst: {
            args: Prisma.ClosetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClosetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload>
          }
          findMany: {
            args: Prisma.ClosetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload>[]
          }
          create: {
            args: Prisma.ClosetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload>
          }
          createMany: {
            args: Prisma.ClosetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClosetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload>[]
          }
          delete: {
            args: Prisma.ClosetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload>
          }
          update: {
            args: Prisma.ClosetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload>
          }
          deleteMany: {
            args: Prisma.ClosetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClosetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClosetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload>[]
          }
          upsert: {
            args: Prisma.ClosetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClosetPayload>
          }
          aggregate: {
            args: Prisma.ClosetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCloset>
          }
          groupBy: {
            args: Prisma.ClosetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClosetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClosetCountArgs<ExtArgs>
            result: $Utils.Optional<ClosetCountAggregateOutputType> | number
          }
        }
      }
      S3Bucket: {
        payload: Prisma.$S3BucketPayload<ExtArgs>
        fields: Prisma.S3BucketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.S3BucketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.S3BucketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload>
          }
          findFirst: {
            args: Prisma.S3BucketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.S3BucketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload>
          }
          findMany: {
            args: Prisma.S3BucketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload>[]
          }
          create: {
            args: Prisma.S3BucketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload>
          }
          createMany: {
            args: Prisma.S3BucketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.S3BucketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload>[]
          }
          delete: {
            args: Prisma.S3BucketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload>
          }
          update: {
            args: Prisma.S3BucketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload>
          }
          deleteMany: {
            args: Prisma.S3BucketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.S3BucketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.S3BucketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload>[]
          }
          upsert: {
            args: Prisma.S3BucketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3BucketPayload>
          }
          aggregate: {
            args: Prisma.S3BucketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS3Bucket>
          }
          groupBy: {
            args: Prisma.S3BucketGroupByArgs<ExtArgs>
            result: $Utils.Optional<S3BucketGroupByOutputType>[]
          }
          count: {
            args: Prisma.S3BucketCountArgs<ExtArgs>
            result: $Utils.Optional<S3BucketCountAggregateOutputType> | number
          }
        }
      }
      ClothingItem: {
        payload: Prisma.$ClothingItemPayload<ExtArgs>
        fields: Prisma.ClothingItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClothingItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClothingItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload>
          }
          findFirst: {
            args: Prisma.ClothingItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClothingItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload>
          }
          findMany: {
            args: Prisma.ClothingItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload>[]
          }
          create: {
            args: Prisma.ClothingItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload>
          }
          createMany: {
            args: Prisma.ClothingItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClothingItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload>[]
          }
          delete: {
            args: Prisma.ClothingItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload>
          }
          update: {
            args: Prisma.ClothingItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload>
          }
          deleteMany: {
            args: Prisma.ClothingItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClothingItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClothingItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload>[]
          }
          upsert: {
            args: Prisma.ClothingItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClothingItemPayload>
          }
          aggregate: {
            args: Prisma.ClothingItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClothingItem>
          }
          groupBy: {
            args: Prisma.ClothingItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClothingItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClothingItemCountArgs<ExtArgs>
            result: $Utils.Optional<ClothingItemCountAggregateOutputType> | number
          }
        }
      }
      Outfit: {
        payload: Prisma.$OutfitPayload<ExtArgs>
        fields: Prisma.OutfitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutfitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutfitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          findFirst: {
            args: Prisma.OutfitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutfitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          findMany: {
            args: Prisma.OutfitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>[]
          }
          create: {
            args: Prisma.OutfitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          createMany: {
            args: Prisma.OutfitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutfitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>[]
          }
          delete: {
            args: Prisma.OutfitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          update: {
            args: Prisma.OutfitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          deleteMany: {
            args: Prisma.OutfitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutfitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutfitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>[]
          }
          upsert: {
            args: Prisma.OutfitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitPayload>
          }
          aggregate: {
            args: Prisma.OutfitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutfit>
          }
          groupBy: {
            args: Prisma.OutfitGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutfitGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutfitCountArgs<ExtArgs>
            result: $Utils.Optional<OutfitCountAggregateOutputType> | number
          }
        }
      }
      OutfitClothingItem: {
        payload: Prisma.$OutfitClothingItemPayload<ExtArgs>
        fields: Prisma.OutfitClothingItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutfitClothingItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutfitClothingItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload>
          }
          findFirst: {
            args: Prisma.OutfitClothingItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutfitClothingItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload>
          }
          findMany: {
            args: Prisma.OutfitClothingItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload>[]
          }
          create: {
            args: Prisma.OutfitClothingItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload>
          }
          createMany: {
            args: Prisma.OutfitClothingItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutfitClothingItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload>[]
          }
          delete: {
            args: Prisma.OutfitClothingItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload>
          }
          update: {
            args: Prisma.OutfitClothingItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload>
          }
          deleteMany: {
            args: Prisma.OutfitClothingItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutfitClothingItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutfitClothingItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload>[]
          }
          upsert: {
            args: Prisma.OutfitClothingItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutfitClothingItemPayload>
          }
          aggregate: {
            args: Prisma.OutfitClothingItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutfitClothingItem>
          }
          groupBy: {
            args: Prisma.OutfitClothingItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutfitClothingItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutfitClothingItemCountArgs<ExtArgs>
            result: $Utils.Optional<OutfitClothingItemCountAggregateOutputType> | number
          }
        }
      }
      ChatSession: {
        payload: Prisma.$ChatSessionPayload<ExtArgs>
        fields: Prisma.ChatSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findFirst: {
            args: Prisma.ChatSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findMany: {
            args: Prisma.ChatSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          create: {
            args: Prisma.ChatSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          createMany: {
            args: Prisma.ChatSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          delete: {
            args: Prisma.ChatSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          update: {
            args: Prisma.ChatSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          deleteMany: {
            args: Prisma.ChatSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          upsert: {
            args: Prisma.ChatSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          aggregate: {
            args: Prisma.ChatSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatSession>
          }
          groupBy: {
            args: Prisma.ChatSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      MCPSession: {
        payload: Prisma.$MCPSessionPayload<ExtArgs>
        fields: Prisma.MCPSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MCPSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MCPSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload>
          }
          findFirst: {
            args: Prisma.MCPSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MCPSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload>
          }
          findMany: {
            args: Prisma.MCPSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload>[]
          }
          create: {
            args: Prisma.MCPSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload>
          }
          createMany: {
            args: Prisma.MCPSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MCPSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload>[]
          }
          delete: {
            args: Prisma.MCPSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload>
          }
          update: {
            args: Prisma.MCPSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload>
          }
          deleteMany: {
            args: Prisma.MCPSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MCPSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MCPSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload>[]
          }
          upsert: {
            args: Prisma.MCPSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionPayload>
          }
          aggregate: {
            args: Prisma.MCPSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMCPSession>
          }
          groupBy: {
            args: Prisma.MCPSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MCPSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MCPSessionCountArgs<ExtArgs>
            result: $Utils.Optional<MCPSessionCountAggregateOutputType> | number
          }
        }
      }
      MCPSessionOutfit: {
        payload: Prisma.$MCPSessionOutfitPayload<ExtArgs>
        fields: Prisma.MCPSessionOutfitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MCPSessionOutfitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MCPSessionOutfitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload>
          }
          findFirst: {
            args: Prisma.MCPSessionOutfitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MCPSessionOutfitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload>
          }
          findMany: {
            args: Prisma.MCPSessionOutfitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload>[]
          }
          create: {
            args: Prisma.MCPSessionOutfitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload>
          }
          createMany: {
            args: Prisma.MCPSessionOutfitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MCPSessionOutfitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload>[]
          }
          delete: {
            args: Prisma.MCPSessionOutfitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload>
          }
          update: {
            args: Prisma.MCPSessionOutfitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload>
          }
          deleteMany: {
            args: Prisma.MCPSessionOutfitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MCPSessionOutfitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MCPSessionOutfitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload>[]
          }
          upsert: {
            args: Prisma.MCPSessionOutfitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPSessionOutfitPayload>
          }
          aggregate: {
            args: Prisma.MCPSessionOutfitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMCPSessionOutfit>
          }
          groupBy: {
            args: Prisma.MCPSessionOutfitGroupByArgs<ExtArgs>
            result: $Utils.Optional<MCPSessionOutfitGroupByOutputType>[]
          }
          count: {
            args: Prisma.MCPSessionOutfitCountArgs<ExtArgs>
            result: $Utils.Optional<MCPSessionOutfitCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    category?: CategoryOmit
    closet?: ClosetOmit
    s3Bucket?: S3BucketOmit
    clothingItem?: ClothingItemOmit
    outfit?: OutfitOmit
    outfitClothingItem?: OutfitClothingItemOmit
    chatSession?: ChatSessionOmit
    chatMessage?: ChatMessageOmit
    mCPSession?: MCPSessionOmit
    mCPSessionOutfit?: MCPSessionOutfitOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    closets: number
    categories: number
    outfits: number
    chatSessions: number
    mcpSessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closets?: boolean | UserCountOutputTypeCountClosetsArgs
    categories?: boolean | UserCountOutputTypeCountCategoriesArgs
    outfits?: boolean | UserCountOutputTypeCountOutfitsArgs
    chatSessions?: boolean | UserCountOutputTypeCountChatSessionsArgs
    mcpSessions?: boolean | UserCountOutputTypeCountMcpSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClosetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClosetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOutfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMcpSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCPSessionWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    clothingItems: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clothingItems?: boolean | CategoryCountOutputTypeCountClothingItemsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountClothingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClothingItemWhereInput
  }


  /**
   * Count Type ClosetCountOutputType
   */

  export type ClosetCountOutputType = {
    clothingItems: number
  }

  export type ClosetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clothingItems?: boolean | ClosetCountOutputTypeCountClothingItemsArgs
  }

  // Custom InputTypes
  /**
   * ClosetCountOutputType without action
   */
  export type ClosetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClosetCountOutputType
     */
    select?: ClosetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClosetCountOutputType without action
   */
  export type ClosetCountOutputTypeCountClothingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClothingItemWhereInput
  }


  /**
   * Count Type S3BucketCountOutputType
   */

  export type S3BucketCountOutputType = {
    clothingItems: number
    outfits: number
  }

  export type S3BucketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clothingItems?: boolean | S3BucketCountOutputTypeCountClothingItemsArgs
    outfits?: boolean | S3BucketCountOutputTypeCountOutfitsArgs
  }

  // Custom InputTypes
  /**
   * S3BucketCountOutputType without action
   */
  export type S3BucketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3BucketCountOutputType
     */
    select?: S3BucketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * S3BucketCountOutputType without action
   */
  export type S3BucketCountOutputTypeCountClothingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClothingItemWhereInput
  }

  /**
   * S3BucketCountOutputType without action
   */
  export type S3BucketCountOutputTypeCountOutfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitWhereInput
  }


  /**
   * Count Type ClothingItemCountOutputType
   */

  export type ClothingItemCountOutputType = {
    outfitClothingItems: number
  }

  export type ClothingItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outfitClothingItems?: boolean | ClothingItemCountOutputTypeCountOutfitClothingItemsArgs
  }

  // Custom InputTypes
  /**
   * ClothingItemCountOutputType without action
   */
  export type ClothingItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItemCountOutputType
     */
    select?: ClothingItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClothingItemCountOutputType without action
   */
  export type ClothingItemCountOutputTypeCountOutfitClothingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitClothingItemWhereInput
  }


  /**
   * Count Type OutfitCountOutputType
   */

  export type OutfitCountOutputType = {
    outfitClothingItems: number
    mcpSessionOutfits: number
  }

  export type OutfitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outfitClothingItems?: boolean | OutfitCountOutputTypeCountOutfitClothingItemsArgs
    mcpSessionOutfits?: boolean | OutfitCountOutputTypeCountMcpSessionOutfitsArgs
  }

  // Custom InputTypes
  /**
   * OutfitCountOutputType without action
   */
  export type OutfitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitCountOutputType
     */
    select?: OutfitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OutfitCountOutputType without action
   */
  export type OutfitCountOutputTypeCountOutfitClothingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitClothingItemWhereInput
  }

  /**
   * OutfitCountOutputType without action
   */
  export type OutfitCountOutputTypeCountMcpSessionOutfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCPSessionOutfitWhereInput
  }


  /**
   * Count Type ChatSessionCountOutputType
   */

  export type ChatSessionCountOutputType = {
    messages: number
  }

  export type ChatSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatSessionCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSessionCountOutputType
     */
    select?: ChatSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type MCPSessionCountOutputType
   */

  export type MCPSessionCountOutputType = {
    outfits: number
    mcpSessionOutfits: number
  }

  export type MCPSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outfits?: boolean | MCPSessionCountOutputTypeCountOutfitsArgs
    mcpSessionOutfits?: boolean | MCPSessionCountOutputTypeCountMcpSessionOutfitsArgs
  }

  // Custom InputTypes
  /**
   * MCPSessionCountOutputType without action
   */
  export type MCPSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionCountOutputType
     */
    select?: MCPSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MCPSessionCountOutputType without action
   */
  export type MCPSessionCountOutputTypeCountOutfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitWhereInput
  }

  /**
   * MCPSessionCountOutputType without action
   */
  export type MCPSessionCountOutputTypeCountMcpSessionOutfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCPSessionOutfitWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    coin_balance: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    coin_balance: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    username: string | null
    password_hash: string | null
    google_id: string | null
    coin_balance: number | null
    security_question: string | null
    security_answer_hash: string | null
    created_at: Date | null
    updated_at: Date | null
    role: string | null
    avatar_url: string | null
    avatar_key: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    username: string | null
    password_hash: string | null
    google_id: string | null
    coin_balance: number | null
    security_question: string | null
    security_answer_hash: string | null
    created_at: Date | null
    updated_at: Date | null
    role: string | null
    avatar_url: string | null
    avatar_key: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password_hash: number
    google_id: number
    coin_balance: number
    security_question: number
    security_answer_hash: number
    created_at: number
    updated_at: number
    role: number
    avatar_url: number
    avatar_key: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    coin_balance?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    coin_balance?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password_hash?: true
    google_id?: true
    coin_balance?: true
    security_question?: true
    security_answer_hash?: true
    created_at?: true
    updated_at?: true
    role?: true
    avatar_url?: true
    avatar_key?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password_hash?: true
    google_id?: true
    coin_balance?: true
    security_question?: true
    security_answer_hash?: true
    created_at?: true
    updated_at?: true
    role?: true
    avatar_url?: true
    avatar_key?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password_hash?: true
    google_id?: true
    coin_balance?: true
    security_question?: true
    security_answer_hash?: true
    created_at?: true
    updated_at?: true
    role?: true
    avatar_url?: true
    avatar_key?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    username: string
    password_hash: string
    google_id: string | null
    coin_balance: number
    security_question: string
    security_answer_hash: string
    created_at: Date
    updated_at: Date
    role: string
    avatar_url: string | null
    avatar_key: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password_hash?: boolean
    google_id?: boolean
    coin_balance?: boolean
    security_question?: boolean
    security_answer_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean
    avatar_url?: boolean
    avatar_key?: boolean
    closets?: boolean | User$closetsArgs<ExtArgs>
    categories?: boolean | User$categoriesArgs<ExtArgs>
    outfits?: boolean | User$outfitsArgs<ExtArgs>
    chatSessions?: boolean | User$chatSessionsArgs<ExtArgs>
    mcpSessions?: boolean | User$mcpSessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password_hash?: boolean
    google_id?: boolean
    coin_balance?: boolean
    security_question?: boolean
    security_answer_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean
    avatar_url?: boolean
    avatar_key?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password_hash?: boolean
    google_id?: boolean
    coin_balance?: boolean
    security_question?: boolean
    security_answer_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean
    avatar_url?: boolean
    avatar_key?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password_hash?: boolean
    google_id?: boolean
    coin_balance?: boolean
    security_question?: boolean
    security_answer_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean
    avatar_url?: boolean
    avatar_key?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "password_hash" | "google_id" | "coin_balance" | "security_question" | "security_answer_hash" | "created_at" | "updated_at" | "role" | "avatar_url" | "avatar_key", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closets?: boolean | User$closetsArgs<ExtArgs>
    categories?: boolean | User$categoriesArgs<ExtArgs>
    outfits?: boolean | User$outfitsArgs<ExtArgs>
    chatSessions?: boolean | User$chatSessionsArgs<ExtArgs>
    mcpSessions?: boolean | User$mcpSessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      closets: Prisma.$ClosetPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      outfits: Prisma.$OutfitPayload<ExtArgs>[]
      chatSessions: Prisma.$ChatSessionPayload<ExtArgs>[]
      mcpSessions: Prisma.$MCPSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      username: string
      password_hash: string
      google_id: string | null
      coin_balance: number
      security_question: string
      security_answer_hash: string
      created_at: Date
      updated_at: Date
      role: string
      avatar_url: string | null
      avatar_key: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    closets<T extends User$closetsArgs<ExtArgs> = {}>(args?: Subset<T, User$closetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends User$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    outfits<T extends User$outfitsArgs<ExtArgs> = {}>(args?: Subset<T, User$outfitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatSessions<T extends User$chatSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mcpSessions<T extends User$mcpSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$mcpSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly google_id: FieldRef<"User", 'String'>
    readonly coin_balance: FieldRef<"User", 'Int'>
    readonly security_question: FieldRef<"User", 'String'>
    readonly security_answer_hash: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
    readonly avatar_url: FieldRef<"User", 'String'>
    readonly avatar_key: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.closets
   */
  export type User$closetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
    where?: ClosetWhereInput
    orderBy?: ClosetOrderByWithRelationInput | ClosetOrderByWithRelationInput[]
    cursor?: ClosetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClosetScalarFieldEnum | ClosetScalarFieldEnum[]
  }

  /**
   * User.categories
   */
  export type User$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * User.outfits
   */
  export type User$outfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    where?: OutfitWhereInput
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    cursor?: OutfitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutfitScalarFieldEnum | OutfitScalarFieldEnum[]
  }

  /**
   * User.chatSessions
   */
  export type User$chatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    cursor?: ChatSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * User.mcpSessions
   */
  export type User$mcpSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    where?: MCPSessionWhereInput
    orderBy?: MCPSessionOrderByWithRelationInput | MCPSessionOrderByWithRelationInput[]
    cursor?: MCPSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MCPSessionScalarFieldEnum | MCPSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    created_at: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    created_at: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    created_at: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    created_at?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    created_at?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    created_at?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    user_id: number
    title: string
    created_at: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clothingItems?: boolean | Category$clothingItemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    created_at?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "title" | "created_at", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clothingItems?: boolean | Category$clothingItemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      clothingItems: Prisma.$ClothingItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      title: string
      created_at: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clothingItems<T extends Category$clothingItemsArgs<ExtArgs> = {}>(args?: Subset<T, Category$clothingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly user_id: FieldRef<"Category", 'Int'>
    readonly title: FieldRef<"Category", 'String'>
    readonly created_at: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.clothingItems
   */
  export type Category$clothingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    where?: ClothingItemWhereInput
    orderBy?: ClothingItemOrderByWithRelationInput | ClothingItemOrderByWithRelationInput[]
    cursor?: ClothingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClothingItemScalarFieldEnum | ClothingItemScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Closet
   */

  export type AggregateCloset = {
    _count: ClosetCountAggregateOutputType | null
    _avg: ClosetAvgAggregateOutputType | null
    _sum: ClosetSumAggregateOutputType | null
    _min: ClosetMinAggregateOutputType | null
    _max: ClosetMaxAggregateOutputType | null
  }

  export type ClosetAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ClosetSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ClosetMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClosetMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClosetCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClosetAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ClosetSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ClosetMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ClosetMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ClosetCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClosetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Closet to aggregate.
     */
    where?: ClosetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Closets to fetch.
     */
    orderBy?: ClosetOrderByWithRelationInput | ClosetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClosetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Closets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Closets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Closets
    **/
    _count?: true | ClosetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClosetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClosetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClosetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClosetMaxAggregateInputType
  }

  export type GetClosetAggregateType<T extends ClosetAggregateArgs> = {
        [P in keyof T & keyof AggregateCloset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCloset[P]>
      : GetScalarType<T[P], AggregateCloset[P]>
  }




  export type ClosetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClosetWhereInput
    orderBy?: ClosetOrderByWithAggregationInput | ClosetOrderByWithAggregationInput[]
    by: ClosetScalarFieldEnum[] | ClosetScalarFieldEnum
    having?: ClosetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClosetCountAggregateInputType | true
    _avg?: ClosetAvgAggregateInputType
    _sum?: ClosetSumAggregateInputType
    _min?: ClosetMinAggregateInputType
    _max?: ClosetMaxAggregateInputType
  }

  export type ClosetGroupByOutputType = {
    id: number
    user_id: number
    name: string
    created_at: Date
    updated_at: Date
    _count: ClosetCountAggregateOutputType | null
    _avg: ClosetAvgAggregateOutputType | null
    _sum: ClosetSumAggregateOutputType | null
    _min: ClosetMinAggregateOutputType | null
    _max: ClosetMaxAggregateOutputType | null
  }

  type GetClosetGroupByPayload<T extends ClosetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClosetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClosetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClosetGroupByOutputType[P]>
            : GetScalarType<T[P], ClosetGroupByOutputType[P]>
        }
      >
    >


  export type ClosetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clothingItems?: boolean | Closet$clothingItemsArgs<ExtArgs>
    _count?: boolean | ClosetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closet"]>

  export type ClosetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closet"]>

  export type ClosetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["closet"]>

  export type ClosetSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ClosetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "created_at" | "updated_at", ExtArgs["result"]["closet"]>
  export type ClosetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clothingItems?: boolean | Closet$clothingItemsArgs<ExtArgs>
    _count?: boolean | ClosetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClosetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClosetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClosetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Closet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      clothingItems: Prisma.$ClothingItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["closet"]>
    composites: {}
  }

  type ClosetGetPayload<S extends boolean | null | undefined | ClosetDefaultArgs> = $Result.GetResult<Prisma.$ClosetPayload, S>

  type ClosetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClosetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClosetCountAggregateInputType | true
    }

  export interface ClosetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Closet'], meta: { name: 'Closet' } }
    /**
     * Find zero or one Closet that matches the filter.
     * @param {ClosetFindUniqueArgs} args - Arguments to find a Closet
     * @example
     * // Get one Closet
     * const closet = await prisma.closet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClosetFindUniqueArgs>(args: SelectSubset<T, ClosetFindUniqueArgs<ExtArgs>>): Prisma__ClosetClient<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Closet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClosetFindUniqueOrThrowArgs} args - Arguments to find a Closet
     * @example
     * // Get one Closet
     * const closet = await prisma.closet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClosetFindUniqueOrThrowArgs>(args: SelectSubset<T, ClosetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClosetClient<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Closet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosetFindFirstArgs} args - Arguments to find a Closet
     * @example
     * // Get one Closet
     * const closet = await prisma.closet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClosetFindFirstArgs>(args?: SelectSubset<T, ClosetFindFirstArgs<ExtArgs>>): Prisma__ClosetClient<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Closet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosetFindFirstOrThrowArgs} args - Arguments to find a Closet
     * @example
     * // Get one Closet
     * const closet = await prisma.closet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClosetFindFirstOrThrowArgs>(args?: SelectSubset<T, ClosetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClosetClient<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Closets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Closets
     * const closets = await prisma.closet.findMany()
     * 
     * // Get first 10 Closets
     * const closets = await prisma.closet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const closetWithIdOnly = await prisma.closet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClosetFindManyArgs>(args?: SelectSubset<T, ClosetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Closet.
     * @param {ClosetCreateArgs} args - Arguments to create a Closet.
     * @example
     * // Create one Closet
     * const Closet = await prisma.closet.create({
     *   data: {
     *     // ... data to create a Closet
     *   }
     * })
     * 
     */
    create<T extends ClosetCreateArgs>(args: SelectSubset<T, ClosetCreateArgs<ExtArgs>>): Prisma__ClosetClient<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Closets.
     * @param {ClosetCreateManyArgs} args - Arguments to create many Closets.
     * @example
     * // Create many Closets
     * const closet = await prisma.closet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClosetCreateManyArgs>(args?: SelectSubset<T, ClosetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Closets and returns the data saved in the database.
     * @param {ClosetCreateManyAndReturnArgs} args - Arguments to create many Closets.
     * @example
     * // Create many Closets
     * const closet = await prisma.closet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Closets and only return the `id`
     * const closetWithIdOnly = await prisma.closet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClosetCreateManyAndReturnArgs>(args?: SelectSubset<T, ClosetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Closet.
     * @param {ClosetDeleteArgs} args - Arguments to delete one Closet.
     * @example
     * // Delete one Closet
     * const Closet = await prisma.closet.delete({
     *   where: {
     *     // ... filter to delete one Closet
     *   }
     * })
     * 
     */
    delete<T extends ClosetDeleteArgs>(args: SelectSubset<T, ClosetDeleteArgs<ExtArgs>>): Prisma__ClosetClient<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Closet.
     * @param {ClosetUpdateArgs} args - Arguments to update one Closet.
     * @example
     * // Update one Closet
     * const closet = await prisma.closet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClosetUpdateArgs>(args: SelectSubset<T, ClosetUpdateArgs<ExtArgs>>): Prisma__ClosetClient<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Closets.
     * @param {ClosetDeleteManyArgs} args - Arguments to filter Closets to delete.
     * @example
     * // Delete a few Closets
     * const { count } = await prisma.closet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClosetDeleteManyArgs>(args?: SelectSubset<T, ClosetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Closets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Closets
     * const closet = await prisma.closet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClosetUpdateManyArgs>(args: SelectSubset<T, ClosetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Closets and returns the data updated in the database.
     * @param {ClosetUpdateManyAndReturnArgs} args - Arguments to update many Closets.
     * @example
     * // Update many Closets
     * const closet = await prisma.closet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Closets and only return the `id`
     * const closetWithIdOnly = await prisma.closet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClosetUpdateManyAndReturnArgs>(args: SelectSubset<T, ClosetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Closet.
     * @param {ClosetUpsertArgs} args - Arguments to update or create a Closet.
     * @example
     * // Update or create a Closet
     * const closet = await prisma.closet.upsert({
     *   create: {
     *     // ... data to create a Closet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Closet we want to update
     *   }
     * })
     */
    upsert<T extends ClosetUpsertArgs>(args: SelectSubset<T, ClosetUpsertArgs<ExtArgs>>): Prisma__ClosetClient<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Closets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosetCountArgs} args - Arguments to filter Closets to count.
     * @example
     * // Count the number of Closets
     * const count = await prisma.closet.count({
     *   where: {
     *     // ... the filter for the Closets we want to count
     *   }
     * })
    **/
    count<T extends ClosetCountArgs>(
      args?: Subset<T, ClosetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClosetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Closet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClosetAggregateArgs>(args: Subset<T, ClosetAggregateArgs>): Prisma.PrismaPromise<GetClosetAggregateType<T>>

    /**
     * Group by Closet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClosetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClosetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClosetGroupByArgs['orderBy'] }
        : { orderBy?: ClosetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClosetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClosetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Closet model
   */
  readonly fields: ClosetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Closet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClosetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clothingItems<T extends Closet$clothingItemsArgs<ExtArgs> = {}>(args?: Subset<T, Closet$clothingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Closet model
   */
  interface ClosetFieldRefs {
    readonly id: FieldRef<"Closet", 'Int'>
    readonly user_id: FieldRef<"Closet", 'Int'>
    readonly name: FieldRef<"Closet", 'String'>
    readonly created_at: FieldRef<"Closet", 'DateTime'>
    readonly updated_at: FieldRef<"Closet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Closet findUnique
   */
  export type ClosetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
    /**
     * Filter, which Closet to fetch.
     */
    where: ClosetWhereUniqueInput
  }

  /**
   * Closet findUniqueOrThrow
   */
  export type ClosetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
    /**
     * Filter, which Closet to fetch.
     */
    where: ClosetWhereUniqueInput
  }

  /**
   * Closet findFirst
   */
  export type ClosetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
    /**
     * Filter, which Closet to fetch.
     */
    where?: ClosetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Closets to fetch.
     */
    orderBy?: ClosetOrderByWithRelationInput | ClosetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Closets.
     */
    cursor?: ClosetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Closets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Closets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Closets.
     */
    distinct?: ClosetScalarFieldEnum | ClosetScalarFieldEnum[]
  }

  /**
   * Closet findFirstOrThrow
   */
  export type ClosetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
    /**
     * Filter, which Closet to fetch.
     */
    where?: ClosetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Closets to fetch.
     */
    orderBy?: ClosetOrderByWithRelationInput | ClosetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Closets.
     */
    cursor?: ClosetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Closets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Closets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Closets.
     */
    distinct?: ClosetScalarFieldEnum | ClosetScalarFieldEnum[]
  }

  /**
   * Closet findMany
   */
  export type ClosetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
    /**
     * Filter, which Closets to fetch.
     */
    where?: ClosetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Closets to fetch.
     */
    orderBy?: ClosetOrderByWithRelationInput | ClosetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Closets.
     */
    cursor?: ClosetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Closets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Closets.
     */
    skip?: number
    distinct?: ClosetScalarFieldEnum | ClosetScalarFieldEnum[]
  }

  /**
   * Closet create
   */
  export type ClosetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
    /**
     * The data needed to create a Closet.
     */
    data: XOR<ClosetCreateInput, ClosetUncheckedCreateInput>
  }

  /**
   * Closet createMany
   */
  export type ClosetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Closets.
     */
    data: ClosetCreateManyInput | ClosetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Closet createManyAndReturn
   */
  export type ClosetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * The data used to create many Closets.
     */
    data: ClosetCreateManyInput | ClosetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Closet update
   */
  export type ClosetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
    /**
     * The data needed to update a Closet.
     */
    data: XOR<ClosetUpdateInput, ClosetUncheckedUpdateInput>
    /**
     * Choose, which Closet to update.
     */
    where: ClosetWhereUniqueInput
  }

  /**
   * Closet updateMany
   */
  export type ClosetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Closets.
     */
    data: XOR<ClosetUpdateManyMutationInput, ClosetUncheckedUpdateManyInput>
    /**
     * Filter which Closets to update
     */
    where?: ClosetWhereInput
    /**
     * Limit how many Closets to update.
     */
    limit?: number
  }

  /**
   * Closet updateManyAndReturn
   */
  export type ClosetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * The data used to update Closets.
     */
    data: XOR<ClosetUpdateManyMutationInput, ClosetUncheckedUpdateManyInput>
    /**
     * Filter which Closets to update
     */
    where?: ClosetWhereInput
    /**
     * Limit how many Closets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Closet upsert
   */
  export type ClosetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
    /**
     * The filter to search for the Closet to update in case it exists.
     */
    where: ClosetWhereUniqueInput
    /**
     * In case the Closet found by the `where` argument doesn't exist, create a new Closet with this data.
     */
    create: XOR<ClosetCreateInput, ClosetUncheckedCreateInput>
    /**
     * In case the Closet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClosetUpdateInput, ClosetUncheckedUpdateInput>
  }

  /**
   * Closet delete
   */
  export type ClosetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
    /**
     * Filter which Closet to delete.
     */
    where: ClosetWhereUniqueInput
  }

  /**
   * Closet deleteMany
   */
  export type ClosetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Closets to delete
     */
    where?: ClosetWhereInput
    /**
     * Limit how many Closets to delete.
     */
    limit?: number
  }

  /**
   * Closet.clothingItems
   */
  export type Closet$clothingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    where?: ClothingItemWhereInput
    orderBy?: ClothingItemOrderByWithRelationInput | ClothingItemOrderByWithRelationInput[]
    cursor?: ClothingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClothingItemScalarFieldEnum | ClothingItemScalarFieldEnum[]
  }

  /**
   * Closet without action
   */
  export type ClosetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Closet
     */
    select?: ClosetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Closet
     */
    omit?: ClosetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClosetInclude<ExtArgs> | null
  }


  /**
   * Model S3Bucket
   */

  export type AggregateS3Bucket = {
    _count: S3BucketCountAggregateOutputType | null
    _min: S3BucketMinAggregateOutputType | null
    _max: S3BucketMaxAggregateOutputType | null
  }

  export type S3BucketMinAggregateOutputType = {
    name: string | null
    region: string | null
    created_at: Date | null
  }

  export type S3BucketMaxAggregateOutputType = {
    name: string | null
    region: string | null
    created_at: Date | null
  }

  export type S3BucketCountAggregateOutputType = {
    name: number
    region: number
    created_at: number
    _all: number
  }


  export type S3BucketMinAggregateInputType = {
    name?: true
    region?: true
    created_at?: true
  }

  export type S3BucketMaxAggregateInputType = {
    name?: true
    region?: true
    created_at?: true
  }

  export type S3BucketCountAggregateInputType = {
    name?: true
    region?: true
    created_at?: true
    _all?: true
  }

  export type S3BucketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which S3Bucket to aggregate.
     */
    where?: S3BucketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of S3Buckets to fetch.
     */
    orderBy?: S3BucketOrderByWithRelationInput | S3BucketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: S3BucketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` S3Buckets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` S3Buckets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned S3Buckets
    **/
    _count?: true | S3BucketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S3BucketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S3BucketMaxAggregateInputType
  }

  export type GetS3BucketAggregateType<T extends S3BucketAggregateArgs> = {
        [P in keyof T & keyof AggregateS3Bucket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS3Bucket[P]>
      : GetScalarType<T[P], AggregateS3Bucket[P]>
  }




  export type S3BucketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: S3BucketWhereInput
    orderBy?: S3BucketOrderByWithAggregationInput | S3BucketOrderByWithAggregationInput[]
    by: S3BucketScalarFieldEnum[] | S3BucketScalarFieldEnum
    having?: S3BucketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S3BucketCountAggregateInputType | true
    _min?: S3BucketMinAggregateInputType
    _max?: S3BucketMaxAggregateInputType
  }

  export type S3BucketGroupByOutputType = {
    name: string
    region: string
    created_at: Date
    _count: S3BucketCountAggregateOutputType | null
    _min: S3BucketMinAggregateOutputType | null
    _max: S3BucketMaxAggregateOutputType | null
  }

  type GetS3BucketGroupByPayload<T extends S3BucketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S3BucketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S3BucketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S3BucketGroupByOutputType[P]>
            : GetScalarType<T[P], S3BucketGroupByOutputType[P]>
        }
      >
    >


  export type S3BucketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    region?: boolean
    created_at?: boolean
    clothingItems?: boolean | S3Bucket$clothingItemsArgs<ExtArgs>
    outfits?: boolean | S3Bucket$outfitsArgs<ExtArgs>
    _count?: boolean | S3BucketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["s3Bucket"]>

  export type S3BucketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    region?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["s3Bucket"]>

  export type S3BucketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    region?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["s3Bucket"]>

  export type S3BucketSelectScalar = {
    name?: boolean
    region?: boolean
    created_at?: boolean
  }

  export type S3BucketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "region" | "created_at", ExtArgs["result"]["s3Bucket"]>
  export type S3BucketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clothingItems?: boolean | S3Bucket$clothingItemsArgs<ExtArgs>
    outfits?: boolean | S3Bucket$outfitsArgs<ExtArgs>
    _count?: boolean | S3BucketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type S3BucketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type S3BucketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $S3BucketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "S3Bucket"
    objects: {
      clothingItems: Prisma.$ClothingItemPayload<ExtArgs>[]
      outfits: Prisma.$OutfitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      region: string
      created_at: Date
    }, ExtArgs["result"]["s3Bucket"]>
    composites: {}
  }

  type S3BucketGetPayload<S extends boolean | null | undefined | S3BucketDefaultArgs> = $Result.GetResult<Prisma.$S3BucketPayload, S>

  type S3BucketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<S3BucketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S3BucketCountAggregateInputType | true
    }

  export interface S3BucketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['S3Bucket'], meta: { name: 'S3Bucket' } }
    /**
     * Find zero or one S3Bucket that matches the filter.
     * @param {S3BucketFindUniqueArgs} args - Arguments to find a S3Bucket
     * @example
     * // Get one S3Bucket
     * const s3Bucket = await prisma.s3Bucket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends S3BucketFindUniqueArgs>(args: SelectSubset<T, S3BucketFindUniqueArgs<ExtArgs>>): Prisma__S3BucketClient<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S3Bucket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {S3BucketFindUniqueOrThrowArgs} args - Arguments to find a S3Bucket
     * @example
     * // Get one S3Bucket
     * const s3Bucket = await prisma.s3Bucket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends S3BucketFindUniqueOrThrowArgs>(args: SelectSubset<T, S3BucketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__S3BucketClient<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S3Bucket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3BucketFindFirstArgs} args - Arguments to find a S3Bucket
     * @example
     * // Get one S3Bucket
     * const s3Bucket = await prisma.s3Bucket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends S3BucketFindFirstArgs>(args?: SelectSubset<T, S3BucketFindFirstArgs<ExtArgs>>): Prisma__S3BucketClient<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S3Bucket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3BucketFindFirstOrThrowArgs} args - Arguments to find a S3Bucket
     * @example
     * // Get one S3Bucket
     * const s3Bucket = await prisma.s3Bucket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends S3BucketFindFirstOrThrowArgs>(args?: SelectSubset<T, S3BucketFindFirstOrThrowArgs<ExtArgs>>): Prisma__S3BucketClient<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S3Buckets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3BucketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S3Buckets
     * const s3Buckets = await prisma.s3Bucket.findMany()
     * 
     * // Get first 10 S3Buckets
     * const s3Buckets = await prisma.s3Bucket.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const s3BucketWithNameOnly = await prisma.s3Bucket.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends S3BucketFindManyArgs>(args?: SelectSubset<T, S3BucketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S3Bucket.
     * @param {S3BucketCreateArgs} args - Arguments to create a S3Bucket.
     * @example
     * // Create one S3Bucket
     * const S3Bucket = await prisma.s3Bucket.create({
     *   data: {
     *     // ... data to create a S3Bucket
     *   }
     * })
     * 
     */
    create<T extends S3BucketCreateArgs>(args: SelectSubset<T, S3BucketCreateArgs<ExtArgs>>): Prisma__S3BucketClient<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S3Buckets.
     * @param {S3BucketCreateManyArgs} args - Arguments to create many S3Buckets.
     * @example
     * // Create many S3Buckets
     * const s3Bucket = await prisma.s3Bucket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends S3BucketCreateManyArgs>(args?: SelectSubset<T, S3BucketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many S3Buckets and returns the data saved in the database.
     * @param {S3BucketCreateManyAndReturnArgs} args - Arguments to create many S3Buckets.
     * @example
     * // Create many S3Buckets
     * const s3Bucket = await prisma.s3Bucket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many S3Buckets and only return the `name`
     * const s3BucketWithNameOnly = await prisma.s3Bucket.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends S3BucketCreateManyAndReturnArgs>(args?: SelectSubset<T, S3BucketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a S3Bucket.
     * @param {S3BucketDeleteArgs} args - Arguments to delete one S3Bucket.
     * @example
     * // Delete one S3Bucket
     * const S3Bucket = await prisma.s3Bucket.delete({
     *   where: {
     *     // ... filter to delete one S3Bucket
     *   }
     * })
     * 
     */
    delete<T extends S3BucketDeleteArgs>(args: SelectSubset<T, S3BucketDeleteArgs<ExtArgs>>): Prisma__S3BucketClient<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S3Bucket.
     * @param {S3BucketUpdateArgs} args - Arguments to update one S3Bucket.
     * @example
     * // Update one S3Bucket
     * const s3Bucket = await prisma.s3Bucket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends S3BucketUpdateArgs>(args: SelectSubset<T, S3BucketUpdateArgs<ExtArgs>>): Prisma__S3BucketClient<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S3Buckets.
     * @param {S3BucketDeleteManyArgs} args - Arguments to filter S3Buckets to delete.
     * @example
     * // Delete a few S3Buckets
     * const { count } = await prisma.s3Bucket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends S3BucketDeleteManyArgs>(args?: SelectSubset<T, S3BucketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S3Buckets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3BucketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S3Buckets
     * const s3Bucket = await prisma.s3Bucket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends S3BucketUpdateManyArgs>(args: SelectSubset<T, S3BucketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S3Buckets and returns the data updated in the database.
     * @param {S3BucketUpdateManyAndReturnArgs} args - Arguments to update many S3Buckets.
     * @example
     * // Update many S3Buckets
     * const s3Bucket = await prisma.s3Bucket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more S3Buckets and only return the `name`
     * const s3BucketWithNameOnly = await prisma.s3Bucket.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends S3BucketUpdateManyAndReturnArgs>(args: SelectSubset<T, S3BucketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one S3Bucket.
     * @param {S3BucketUpsertArgs} args - Arguments to update or create a S3Bucket.
     * @example
     * // Update or create a S3Bucket
     * const s3Bucket = await prisma.s3Bucket.upsert({
     *   create: {
     *     // ... data to create a S3Bucket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S3Bucket we want to update
     *   }
     * })
     */
    upsert<T extends S3BucketUpsertArgs>(args: SelectSubset<T, S3BucketUpsertArgs<ExtArgs>>): Prisma__S3BucketClient<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S3Buckets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3BucketCountArgs} args - Arguments to filter S3Buckets to count.
     * @example
     * // Count the number of S3Buckets
     * const count = await prisma.s3Bucket.count({
     *   where: {
     *     // ... the filter for the S3Buckets we want to count
     *   }
     * })
    **/
    count<T extends S3BucketCountArgs>(
      args?: Subset<T, S3BucketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S3BucketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S3Bucket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3BucketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S3BucketAggregateArgs>(args: Subset<T, S3BucketAggregateArgs>): Prisma.PrismaPromise<GetS3BucketAggregateType<T>>

    /**
     * Group by S3Bucket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3BucketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends S3BucketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: S3BucketGroupByArgs['orderBy'] }
        : { orderBy?: S3BucketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, S3BucketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS3BucketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the S3Bucket model
   */
  readonly fields: S3BucketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for S3Bucket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__S3BucketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clothingItems<T extends S3Bucket$clothingItemsArgs<ExtArgs> = {}>(args?: Subset<T, S3Bucket$clothingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    outfits<T extends S3Bucket$outfitsArgs<ExtArgs> = {}>(args?: Subset<T, S3Bucket$outfitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the S3Bucket model
   */
  interface S3BucketFieldRefs {
    readonly name: FieldRef<"S3Bucket", 'String'>
    readonly region: FieldRef<"S3Bucket", 'String'>
    readonly created_at: FieldRef<"S3Bucket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * S3Bucket findUnique
   */
  export type S3BucketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
    /**
     * Filter, which S3Bucket to fetch.
     */
    where: S3BucketWhereUniqueInput
  }

  /**
   * S3Bucket findUniqueOrThrow
   */
  export type S3BucketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
    /**
     * Filter, which S3Bucket to fetch.
     */
    where: S3BucketWhereUniqueInput
  }

  /**
   * S3Bucket findFirst
   */
  export type S3BucketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
    /**
     * Filter, which S3Bucket to fetch.
     */
    where?: S3BucketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of S3Buckets to fetch.
     */
    orderBy?: S3BucketOrderByWithRelationInput | S3BucketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for S3Buckets.
     */
    cursor?: S3BucketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` S3Buckets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` S3Buckets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of S3Buckets.
     */
    distinct?: S3BucketScalarFieldEnum | S3BucketScalarFieldEnum[]
  }

  /**
   * S3Bucket findFirstOrThrow
   */
  export type S3BucketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
    /**
     * Filter, which S3Bucket to fetch.
     */
    where?: S3BucketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of S3Buckets to fetch.
     */
    orderBy?: S3BucketOrderByWithRelationInput | S3BucketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for S3Buckets.
     */
    cursor?: S3BucketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` S3Buckets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` S3Buckets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of S3Buckets.
     */
    distinct?: S3BucketScalarFieldEnum | S3BucketScalarFieldEnum[]
  }

  /**
   * S3Bucket findMany
   */
  export type S3BucketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
    /**
     * Filter, which S3Buckets to fetch.
     */
    where?: S3BucketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of S3Buckets to fetch.
     */
    orderBy?: S3BucketOrderByWithRelationInput | S3BucketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing S3Buckets.
     */
    cursor?: S3BucketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` S3Buckets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` S3Buckets.
     */
    skip?: number
    distinct?: S3BucketScalarFieldEnum | S3BucketScalarFieldEnum[]
  }

  /**
   * S3Bucket create
   */
  export type S3BucketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
    /**
     * The data needed to create a S3Bucket.
     */
    data: XOR<S3BucketCreateInput, S3BucketUncheckedCreateInput>
  }

  /**
   * S3Bucket createMany
   */
  export type S3BucketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many S3Buckets.
     */
    data: S3BucketCreateManyInput | S3BucketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * S3Bucket createManyAndReturn
   */
  export type S3BucketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * The data used to create many S3Buckets.
     */
    data: S3BucketCreateManyInput | S3BucketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * S3Bucket update
   */
  export type S3BucketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
    /**
     * The data needed to update a S3Bucket.
     */
    data: XOR<S3BucketUpdateInput, S3BucketUncheckedUpdateInput>
    /**
     * Choose, which S3Bucket to update.
     */
    where: S3BucketWhereUniqueInput
  }

  /**
   * S3Bucket updateMany
   */
  export type S3BucketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update S3Buckets.
     */
    data: XOR<S3BucketUpdateManyMutationInput, S3BucketUncheckedUpdateManyInput>
    /**
     * Filter which S3Buckets to update
     */
    where?: S3BucketWhereInput
    /**
     * Limit how many S3Buckets to update.
     */
    limit?: number
  }

  /**
   * S3Bucket updateManyAndReturn
   */
  export type S3BucketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * The data used to update S3Buckets.
     */
    data: XOR<S3BucketUpdateManyMutationInput, S3BucketUncheckedUpdateManyInput>
    /**
     * Filter which S3Buckets to update
     */
    where?: S3BucketWhereInput
    /**
     * Limit how many S3Buckets to update.
     */
    limit?: number
  }

  /**
   * S3Bucket upsert
   */
  export type S3BucketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
    /**
     * The filter to search for the S3Bucket to update in case it exists.
     */
    where: S3BucketWhereUniqueInput
    /**
     * In case the S3Bucket found by the `where` argument doesn't exist, create a new S3Bucket with this data.
     */
    create: XOR<S3BucketCreateInput, S3BucketUncheckedCreateInput>
    /**
     * In case the S3Bucket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<S3BucketUpdateInput, S3BucketUncheckedUpdateInput>
  }

  /**
   * S3Bucket delete
   */
  export type S3BucketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
    /**
     * Filter which S3Bucket to delete.
     */
    where: S3BucketWhereUniqueInput
  }

  /**
   * S3Bucket deleteMany
   */
  export type S3BucketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which S3Buckets to delete
     */
    where?: S3BucketWhereInput
    /**
     * Limit how many S3Buckets to delete.
     */
    limit?: number
  }

  /**
   * S3Bucket.clothingItems
   */
  export type S3Bucket$clothingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    where?: ClothingItemWhereInput
    orderBy?: ClothingItemOrderByWithRelationInput | ClothingItemOrderByWithRelationInput[]
    cursor?: ClothingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClothingItemScalarFieldEnum | ClothingItemScalarFieldEnum[]
  }

  /**
   * S3Bucket.outfits
   */
  export type S3Bucket$outfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    where?: OutfitWhereInput
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    cursor?: OutfitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutfitScalarFieldEnum | OutfitScalarFieldEnum[]
  }

  /**
   * S3Bucket without action
   */
  export type S3BucketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
  }


  /**
   * Model ClothingItem
   */

  export type AggregateClothingItem = {
    _count: ClothingItemCountAggregateOutputType | null
    _avg: ClothingItemAvgAggregateOutputType | null
    _sum: ClothingItemSumAggregateOutputType | null
    _min: ClothingItemMinAggregateOutputType | null
    _max: ClothingItemMaxAggregateOutputType | null
  }

  export type ClothingItemAvgAggregateOutputType = {
    id: number | null
    closet_id: number | null
    category_id: number | null
    wear_count: number | null
  }

  export type ClothingItemSumAggregateOutputType = {
    id: number | null
    closet_id: number | null
    category_id: number | null
    wear_count: number | null
  }

  export type ClothingItemMinAggregateOutputType = {
    id: number | null
    closet_id: number | null
    category_id: number | null
    bucket_name: string | null
    image_key: string | null
    label: string | null
    description: string | null
    wear_count: number | null
    last_worn_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
  }

  export type ClothingItemMaxAggregateOutputType = {
    id: number | null
    closet_id: number | null
    category_id: number | null
    bucket_name: string | null
    image_key: string | null
    label: string | null
    description: string | null
    wear_count: number | null
    last_worn_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    status: string | null
  }

  export type ClothingItemCountAggregateOutputType = {
    id: number
    closet_id: number
    category_id: number
    bucket_name: number
    image_key: number
    label: number
    description: number
    wear_count: number
    last_worn_at: number
    created_at: number
    updated_at: number
    status: number
    _all: number
  }


  export type ClothingItemAvgAggregateInputType = {
    id?: true
    closet_id?: true
    category_id?: true
    wear_count?: true
  }

  export type ClothingItemSumAggregateInputType = {
    id?: true
    closet_id?: true
    category_id?: true
    wear_count?: true
  }

  export type ClothingItemMinAggregateInputType = {
    id?: true
    closet_id?: true
    category_id?: true
    bucket_name?: true
    image_key?: true
    label?: true
    description?: true
    wear_count?: true
    last_worn_at?: true
    created_at?: true
    updated_at?: true
    status?: true
  }

  export type ClothingItemMaxAggregateInputType = {
    id?: true
    closet_id?: true
    category_id?: true
    bucket_name?: true
    image_key?: true
    label?: true
    description?: true
    wear_count?: true
    last_worn_at?: true
    created_at?: true
    updated_at?: true
    status?: true
  }

  export type ClothingItemCountAggregateInputType = {
    id?: true
    closet_id?: true
    category_id?: true
    bucket_name?: true
    image_key?: true
    label?: true
    description?: true
    wear_count?: true
    last_worn_at?: true
    created_at?: true
    updated_at?: true
    status?: true
    _all?: true
  }

  export type ClothingItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClothingItem to aggregate.
     */
    where?: ClothingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClothingItems to fetch.
     */
    orderBy?: ClothingItemOrderByWithRelationInput | ClothingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClothingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClothingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClothingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClothingItems
    **/
    _count?: true | ClothingItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClothingItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClothingItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClothingItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClothingItemMaxAggregateInputType
  }

  export type GetClothingItemAggregateType<T extends ClothingItemAggregateArgs> = {
        [P in keyof T & keyof AggregateClothingItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClothingItem[P]>
      : GetScalarType<T[P], AggregateClothingItem[P]>
  }




  export type ClothingItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClothingItemWhereInput
    orderBy?: ClothingItemOrderByWithAggregationInput | ClothingItemOrderByWithAggregationInput[]
    by: ClothingItemScalarFieldEnum[] | ClothingItemScalarFieldEnum
    having?: ClothingItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClothingItemCountAggregateInputType | true
    _avg?: ClothingItemAvgAggregateInputType
    _sum?: ClothingItemSumAggregateInputType
    _min?: ClothingItemMinAggregateInputType
    _max?: ClothingItemMaxAggregateInputType
  }

  export type ClothingItemGroupByOutputType = {
    id: number
    closet_id: number
    category_id: number
    bucket_name: string
    image_key: string
    label: string
    description: string
    wear_count: number
    last_worn_at: Date | null
    created_at: Date
    updated_at: Date
    status: string
    _count: ClothingItemCountAggregateOutputType | null
    _avg: ClothingItemAvgAggregateOutputType | null
    _sum: ClothingItemSumAggregateOutputType | null
    _min: ClothingItemMinAggregateOutputType | null
    _max: ClothingItemMaxAggregateOutputType | null
  }

  type GetClothingItemGroupByPayload<T extends ClothingItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClothingItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClothingItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClothingItemGroupByOutputType[P]>
            : GetScalarType<T[P], ClothingItemGroupByOutputType[P]>
        }
      >
    >


  export type ClothingItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    closet_id?: boolean
    category_id?: boolean
    bucket_name?: boolean
    image_key?: boolean
    label?: boolean
    description?: boolean
    wear_count?: boolean
    last_worn_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    closet?: boolean | ClosetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    bucket?: boolean | S3BucketDefaultArgs<ExtArgs>
    outfitClothingItems?: boolean | ClothingItem$outfitClothingItemsArgs<ExtArgs>
    _count?: boolean | ClothingItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clothingItem"]>

  export type ClothingItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    closet_id?: boolean
    category_id?: boolean
    bucket_name?: boolean
    image_key?: boolean
    label?: boolean
    description?: boolean
    wear_count?: boolean
    last_worn_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    closet?: boolean | ClosetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    bucket?: boolean | S3BucketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clothingItem"]>

  export type ClothingItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    closet_id?: boolean
    category_id?: boolean
    bucket_name?: boolean
    image_key?: boolean
    label?: boolean
    description?: boolean
    wear_count?: boolean
    last_worn_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    closet?: boolean | ClosetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    bucket?: boolean | S3BucketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clothingItem"]>

  export type ClothingItemSelectScalar = {
    id?: boolean
    closet_id?: boolean
    category_id?: boolean
    bucket_name?: boolean
    image_key?: boolean
    label?: boolean
    description?: boolean
    wear_count?: boolean
    last_worn_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
  }

  export type ClothingItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "closet_id" | "category_id" | "bucket_name" | "image_key" | "label" | "description" | "wear_count" | "last_worn_at" | "created_at" | "updated_at" | "status", ExtArgs["result"]["clothingItem"]>
  export type ClothingItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closet?: boolean | ClosetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    bucket?: boolean | S3BucketDefaultArgs<ExtArgs>
    outfitClothingItems?: boolean | ClothingItem$outfitClothingItemsArgs<ExtArgs>
    _count?: boolean | ClothingItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClothingItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closet?: boolean | ClosetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    bucket?: boolean | S3BucketDefaultArgs<ExtArgs>
  }
  export type ClothingItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closet?: boolean | ClosetDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    bucket?: boolean | S3BucketDefaultArgs<ExtArgs>
  }

  export type $ClothingItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClothingItem"
    objects: {
      closet: Prisma.$ClosetPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
      bucket: Prisma.$S3BucketPayload<ExtArgs>
      outfitClothingItems: Prisma.$OutfitClothingItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      closet_id: number
      category_id: number
      bucket_name: string
      image_key: string
      label: string
      description: string
      wear_count: number
      last_worn_at: Date | null
      created_at: Date
      updated_at: Date
      status: string
    }, ExtArgs["result"]["clothingItem"]>
    composites: {}
  }

  type ClothingItemGetPayload<S extends boolean | null | undefined | ClothingItemDefaultArgs> = $Result.GetResult<Prisma.$ClothingItemPayload, S>

  type ClothingItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClothingItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClothingItemCountAggregateInputType | true
    }

  export interface ClothingItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClothingItem'], meta: { name: 'ClothingItem' } }
    /**
     * Find zero or one ClothingItem that matches the filter.
     * @param {ClothingItemFindUniqueArgs} args - Arguments to find a ClothingItem
     * @example
     * // Get one ClothingItem
     * const clothingItem = await prisma.clothingItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClothingItemFindUniqueArgs>(args: SelectSubset<T, ClothingItemFindUniqueArgs<ExtArgs>>): Prisma__ClothingItemClient<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClothingItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClothingItemFindUniqueOrThrowArgs} args - Arguments to find a ClothingItem
     * @example
     * // Get one ClothingItem
     * const clothingItem = await prisma.clothingItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClothingItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ClothingItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClothingItemClient<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClothingItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClothingItemFindFirstArgs} args - Arguments to find a ClothingItem
     * @example
     * // Get one ClothingItem
     * const clothingItem = await prisma.clothingItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClothingItemFindFirstArgs>(args?: SelectSubset<T, ClothingItemFindFirstArgs<ExtArgs>>): Prisma__ClothingItemClient<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClothingItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClothingItemFindFirstOrThrowArgs} args - Arguments to find a ClothingItem
     * @example
     * // Get one ClothingItem
     * const clothingItem = await prisma.clothingItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClothingItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ClothingItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClothingItemClient<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClothingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClothingItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClothingItems
     * const clothingItems = await prisma.clothingItem.findMany()
     * 
     * // Get first 10 ClothingItems
     * const clothingItems = await prisma.clothingItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clothingItemWithIdOnly = await prisma.clothingItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClothingItemFindManyArgs>(args?: SelectSubset<T, ClothingItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClothingItem.
     * @param {ClothingItemCreateArgs} args - Arguments to create a ClothingItem.
     * @example
     * // Create one ClothingItem
     * const ClothingItem = await prisma.clothingItem.create({
     *   data: {
     *     // ... data to create a ClothingItem
     *   }
     * })
     * 
     */
    create<T extends ClothingItemCreateArgs>(args: SelectSubset<T, ClothingItemCreateArgs<ExtArgs>>): Prisma__ClothingItemClient<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClothingItems.
     * @param {ClothingItemCreateManyArgs} args - Arguments to create many ClothingItems.
     * @example
     * // Create many ClothingItems
     * const clothingItem = await prisma.clothingItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClothingItemCreateManyArgs>(args?: SelectSubset<T, ClothingItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClothingItems and returns the data saved in the database.
     * @param {ClothingItemCreateManyAndReturnArgs} args - Arguments to create many ClothingItems.
     * @example
     * // Create many ClothingItems
     * const clothingItem = await prisma.clothingItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClothingItems and only return the `id`
     * const clothingItemWithIdOnly = await prisma.clothingItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClothingItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ClothingItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClothingItem.
     * @param {ClothingItemDeleteArgs} args - Arguments to delete one ClothingItem.
     * @example
     * // Delete one ClothingItem
     * const ClothingItem = await prisma.clothingItem.delete({
     *   where: {
     *     // ... filter to delete one ClothingItem
     *   }
     * })
     * 
     */
    delete<T extends ClothingItemDeleteArgs>(args: SelectSubset<T, ClothingItemDeleteArgs<ExtArgs>>): Prisma__ClothingItemClient<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClothingItem.
     * @param {ClothingItemUpdateArgs} args - Arguments to update one ClothingItem.
     * @example
     * // Update one ClothingItem
     * const clothingItem = await prisma.clothingItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClothingItemUpdateArgs>(args: SelectSubset<T, ClothingItemUpdateArgs<ExtArgs>>): Prisma__ClothingItemClient<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClothingItems.
     * @param {ClothingItemDeleteManyArgs} args - Arguments to filter ClothingItems to delete.
     * @example
     * // Delete a few ClothingItems
     * const { count } = await prisma.clothingItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClothingItemDeleteManyArgs>(args?: SelectSubset<T, ClothingItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClothingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClothingItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClothingItems
     * const clothingItem = await prisma.clothingItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClothingItemUpdateManyArgs>(args: SelectSubset<T, ClothingItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClothingItems and returns the data updated in the database.
     * @param {ClothingItemUpdateManyAndReturnArgs} args - Arguments to update many ClothingItems.
     * @example
     * // Update many ClothingItems
     * const clothingItem = await prisma.clothingItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClothingItems and only return the `id`
     * const clothingItemWithIdOnly = await prisma.clothingItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClothingItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ClothingItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClothingItem.
     * @param {ClothingItemUpsertArgs} args - Arguments to update or create a ClothingItem.
     * @example
     * // Update or create a ClothingItem
     * const clothingItem = await prisma.clothingItem.upsert({
     *   create: {
     *     // ... data to create a ClothingItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClothingItem we want to update
     *   }
     * })
     */
    upsert<T extends ClothingItemUpsertArgs>(args: SelectSubset<T, ClothingItemUpsertArgs<ExtArgs>>): Prisma__ClothingItemClient<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClothingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClothingItemCountArgs} args - Arguments to filter ClothingItems to count.
     * @example
     * // Count the number of ClothingItems
     * const count = await prisma.clothingItem.count({
     *   where: {
     *     // ... the filter for the ClothingItems we want to count
     *   }
     * })
    **/
    count<T extends ClothingItemCountArgs>(
      args?: Subset<T, ClothingItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClothingItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClothingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClothingItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClothingItemAggregateArgs>(args: Subset<T, ClothingItemAggregateArgs>): Prisma.PrismaPromise<GetClothingItemAggregateType<T>>

    /**
     * Group by ClothingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClothingItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClothingItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClothingItemGroupByArgs['orderBy'] }
        : { orderBy?: ClothingItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClothingItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClothingItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClothingItem model
   */
  readonly fields: ClothingItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClothingItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClothingItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    closet<T extends ClosetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClosetDefaultArgs<ExtArgs>>): Prisma__ClosetClient<$Result.GetResult<Prisma.$ClosetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bucket<T extends S3BucketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, S3BucketDefaultArgs<ExtArgs>>): Prisma__S3BucketClient<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outfitClothingItems<T extends ClothingItem$outfitClothingItemsArgs<ExtArgs> = {}>(args?: Subset<T, ClothingItem$outfitClothingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClothingItem model
   */
  interface ClothingItemFieldRefs {
    readonly id: FieldRef<"ClothingItem", 'Int'>
    readonly closet_id: FieldRef<"ClothingItem", 'Int'>
    readonly category_id: FieldRef<"ClothingItem", 'Int'>
    readonly bucket_name: FieldRef<"ClothingItem", 'String'>
    readonly image_key: FieldRef<"ClothingItem", 'String'>
    readonly label: FieldRef<"ClothingItem", 'String'>
    readonly description: FieldRef<"ClothingItem", 'String'>
    readonly wear_count: FieldRef<"ClothingItem", 'Int'>
    readonly last_worn_at: FieldRef<"ClothingItem", 'DateTime'>
    readonly created_at: FieldRef<"ClothingItem", 'DateTime'>
    readonly updated_at: FieldRef<"ClothingItem", 'DateTime'>
    readonly status: FieldRef<"ClothingItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClothingItem findUnique
   */
  export type ClothingItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    /**
     * Filter, which ClothingItem to fetch.
     */
    where: ClothingItemWhereUniqueInput
  }

  /**
   * ClothingItem findUniqueOrThrow
   */
  export type ClothingItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    /**
     * Filter, which ClothingItem to fetch.
     */
    where: ClothingItemWhereUniqueInput
  }

  /**
   * ClothingItem findFirst
   */
  export type ClothingItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    /**
     * Filter, which ClothingItem to fetch.
     */
    where?: ClothingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClothingItems to fetch.
     */
    orderBy?: ClothingItemOrderByWithRelationInput | ClothingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClothingItems.
     */
    cursor?: ClothingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClothingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClothingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClothingItems.
     */
    distinct?: ClothingItemScalarFieldEnum | ClothingItemScalarFieldEnum[]
  }

  /**
   * ClothingItem findFirstOrThrow
   */
  export type ClothingItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    /**
     * Filter, which ClothingItem to fetch.
     */
    where?: ClothingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClothingItems to fetch.
     */
    orderBy?: ClothingItemOrderByWithRelationInput | ClothingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClothingItems.
     */
    cursor?: ClothingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClothingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClothingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClothingItems.
     */
    distinct?: ClothingItemScalarFieldEnum | ClothingItemScalarFieldEnum[]
  }

  /**
   * ClothingItem findMany
   */
  export type ClothingItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    /**
     * Filter, which ClothingItems to fetch.
     */
    where?: ClothingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClothingItems to fetch.
     */
    orderBy?: ClothingItemOrderByWithRelationInput | ClothingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClothingItems.
     */
    cursor?: ClothingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClothingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClothingItems.
     */
    skip?: number
    distinct?: ClothingItemScalarFieldEnum | ClothingItemScalarFieldEnum[]
  }

  /**
   * ClothingItem create
   */
  export type ClothingItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ClothingItem.
     */
    data: XOR<ClothingItemCreateInput, ClothingItemUncheckedCreateInput>
  }

  /**
   * ClothingItem createMany
   */
  export type ClothingItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClothingItems.
     */
    data: ClothingItemCreateManyInput | ClothingItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClothingItem createManyAndReturn
   */
  export type ClothingItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * The data used to create many ClothingItems.
     */
    data: ClothingItemCreateManyInput | ClothingItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClothingItem update
   */
  export type ClothingItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ClothingItem.
     */
    data: XOR<ClothingItemUpdateInput, ClothingItemUncheckedUpdateInput>
    /**
     * Choose, which ClothingItem to update.
     */
    where: ClothingItemWhereUniqueInput
  }

  /**
   * ClothingItem updateMany
   */
  export type ClothingItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClothingItems.
     */
    data: XOR<ClothingItemUpdateManyMutationInput, ClothingItemUncheckedUpdateManyInput>
    /**
     * Filter which ClothingItems to update
     */
    where?: ClothingItemWhereInput
    /**
     * Limit how many ClothingItems to update.
     */
    limit?: number
  }

  /**
   * ClothingItem updateManyAndReturn
   */
  export type ClothingItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * The data used to update ClothingItems.
     */
    data: XOR<ClothingItemUpdateManyMutationInput, ClothingItemUncheckedUpdateManyInput>
    /**
     * Filter which ClothingItems to update
     */
    where?: ClothingItemWhereInput
    /**
     * Limit how many ClothingItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClothingItem upsert
   */
  export type ClothingItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ClothingItem to update in case it exists.
     */
    where: ClothingItemWhereUniqueInput
    /**
     * In case the ClothingItem found by the `where` argument doesn't exist, create a new ClothingItem with this data.
     */
    create: XOR<ClothingItemCreateInput, ClothingItemUncheckedCreateInput>
    /**
     * In case the ClothingItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClothingItemUpdateInput, ClothingItemUncheckedUpdateInput>
  }

  /**
   * ClothingItem delete
   */
  export type ClothingItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
    /**
     * Filter which ClothingItem to delete.
     */
    where: ClothingItemWhereUniqueInput
  }

  /**
   * ClothingItem deleteMany
   */
  export type ClothingItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClothingItems to delete
     */
    where?: ClothingItemWhereInput
    /**
     * Limit how many ClothingItems to delete.
     */
    limit?: number
  }

  /**
   * ClothingItem.outfitClothingItems
   */
  export type ClothingItem$outfitClothingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    where?: OutfitClothingItemWhereInput
    orderBy?: OutfitClothingItemOrderByWithRelationInput | OutfitClothingItemOrderByWithRelationInput[]
    cursor?: OutfitClothingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutfitClothingItemScalarFieldEnum | OutfitClothingItemScalarFieldEnum[]
  }

  /**
   * ClothingItem without action
   */
  export type ClothingItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClothingItem
     */
    select?: ClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClothingItem
     */
    omit?: ClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClothingItemInclude<ExtArgs> | null
  }


  /**
   * Model Outfit
   */

  export type AggregateOutfit = {
    _count: OutfitCountAggregateOutputType | null
    _avg: OutfitAvgAggregateOutputType | null
    _sum: OutfitSumAggregateOutputType | null
    _min: OutfitMinAggregateOutputType | null
    _max: OutfitMaxAggregateOutputType | null
  }

  export type OutfitAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    wear_count: number | null
    mcp_session_id: number | null
  }

  export type OutfitSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    wear_count: number | null
    mcp_session_id: number | null
  }

  export type OutfitMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    bucket_name: string | null
    image_key: string | null
    title: string | null
    is_favorite: boolean | null
    is_recurring: boolean | null
    wear_count: number | null
    last_worn_at: Date | null
    mcp_session_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OutfitMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    bucket_name: string | null
    image_key: string | null
    title: string | null
    is_favorite: boolean | null
    is_recurring: boolean | null
    wear_count: number | null
    last_worn_at: Date | null
    mcp_session_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OutfitCountAggregateOutputType = {
    id: number
    user_id: number
    bucket_name: number
    image_key: number
    title: number
    is_favorite: number
    is_recurring: number
    wear_count: number
    last_worn_at: number
    mcp_session_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OutfitAvgAggregateInputType = {
    id?: true
    user_id?: true
    wear_count?: true
    mcp_session_id?: true
  }

  export type OutfitSumAggregateInputType = {
    id?: true
    user_id?: true
    wear_count?: true
    mcp_session_id?: true
  }

  export type OutfitMinAggregateInputType = {
    id?: true
    user_id?: true
    bucket_name?: true
    image_key?: true
    title?: true
    is_favorite?: true
    is_recurring?: true
    wear_count?: true
    last_worn_at?: true
    mcp_session_id?: true
    created_at?: true
    updated_at?: true
  }

  export type OutfitMaxAggregateInputType = {
    id?: true
    user_id?: true
    bucket_name?: true
    image_key?: true
    title?: true
    is_favorite?: true
    is_recurring?: true
    wear_count?: true
    last_worn_at?: true
    mcp_session_id?: true
    created_at?: true
    updated_at?: true
  }

  export type OutfitCountAggregateInputType = {
    id?: true
    user_id?: true
    bucket_name?: true
    image_key?: true
    title?: true
    is_favorite?: true
    is_recurring?: true
    wear_count?: true
    last_worn_at?: true
    mcp_session_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OutfitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outfit to aggregate.
     */
    where?: OutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outfits to fetch.
     */
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Outfits
    **/
    _count?: true | OutfitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutfitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutfitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutfitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutfitMaxAggregateInputType
  }

  export type GetOutfitAggregateType<T extends OutfitAggregateArgs> = {
        [P in keyof T & keyof AggregateOutfit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutfit[P]>
      : GetScalarType<T[P], AggregateOutfit[P]>
  }




  export type OutfitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitWhereInput
    orderBy?: OutfitOrderByWithAggregationInput | OutfitOrderByWithAggregationInput[]
    by: OutfitScalarFieldEnum[] | OutfitScalarFieldEnum
    having?: OutfitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutfitCountAggregateInputType | true
    _avg?: OutfitAvgAggregateInputType
    _sum?: OutfitSumAggregateInputType
    _min?: OutfitMinAggregateInputType
    _max?: OutfitMaxAggregateInputType
  }

  export type OutfitGroupByOutputType = {
    id: number
    user_id: number
    bucket_name: string | null
    image_key: string | null
    title: string
    is_favorite: boolean
    is_recurring: boolean
    wear_count: number
    last_worn_at: Date | null
    mcp_session_id: number | null
    created_at: Date
    updated_at: Date
    _count: OutfitCountAggregateOutputType | null
    _avg: OutfitAvgAggregateOutputType | null
    _sum: OutfitSumAggregateOutputType | null
    _min: OutfitMinAggregateOutputType | null
    _max: OutfitMaxAggregateOutputType | null
  }

  type GetOutfitGroupByPayload<T extends OutfitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutfitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutfitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutfitGroupByOutputType[P]>
            : GetScalarType<T[P], OutfitGroupByOutputType[P]>
        }
      >
    >


  export type OutfitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    bucket_name?: boolean
    image_key?: boolean
    title?: boolean
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: boolean
    last_worn_at?: boolean
    mcp_session_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bucket?: boolean | Outfit$bucketArgs<ExtArgs>
    mcpSession?: boolean | Outfit$mcpSessionArgs<ExtArgs>
    outfitClothingItems?: boolean | Outfit$outfitClothingItemsArgs<ExtArgs>
    mcpSessionOutfits?: boolean | Outfit$mcpSessionOutfitsArgs<ExtArgs>
    _count?: boolean | OutfitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outfit"]>

  export type OutfitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    bucket_name?: boolean
    image_key?: boolean
    title?: boolean
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: boolean
    last_worn_at?: boolean
    mcp_session_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bucket?: boolean | Outfit$bucketArgs<ExtArgs>
    mcpSession?: boolean | Outfit$mcpSessionArgs<ExtArgs>
  }, ExtArgs["result"]["outfit"]>

  export type OutfitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    bucket_name?: boolean
    image_key?: boolean
    title?: boolean
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: boolean
    last_worn_at?: boolean
    mcp_session_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bucket?: boolean | Outfit$bucketArgs<ExtArgs>
    mcpSession?: boolean | Outfit$mcpSessionArgs<ExtArgs>
  }, ExtArgs["result"]["outfit"]>

  export type OutfitSelectScalar = {
    id?: boolean
    user_id?: boolean
    bucket_name?: boolean
    image_key?: boolean
    title?: boolean
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: boolean
    last_worn_at?: boolean
    mcp_session_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type OutfitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "bucket_name" | "image_key" | "title" | "is_favorite" | "is_recurring" | "wear_count" | "last_worn_at" | "mcp_session_id" | "created_at" | "updated_at", ExtArgs["result"]["outfit"]>
  export type OutfitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bucket?: boolean | Outfit$bucketArgs<ExtArgs>
    mcpSession?: boolean | Outfit$mcpSessionArgs<ExtArgs>
    outfitClothingItems?: boolean | Outfit$outfitClothingItemsArgs<ExtArgs>
    mcpSessionOutfits?: boolean | Outfit$mcpSessionOutfitsArgs<ExtArgs>
    _count?: boolean | OutfitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OutfitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bucket?: boolean | Outfit$bucketArgs<ExtArgs>
    mcpSession?: boolean | Outfit$mcpSessionArgs<ExtArgs>
  }
  export type OutfitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bucket?: boolean | Outfit$bucketArgs<ExtArgs>
    mcpSession?: boolean | Outfit$mcpSessionArgs<ExtArgs>
  }

  export type $OutfitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Outfit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bucket: Prisma.$S3BucketPayload<ExtArgs> | null
      mcpSession: Prisma.$MCPSessionPayload<ExtArgs> | null
      outfitClothingItems: Prisma.$OutfitClothingItemPayload<ExtArgs>[]
      mcpSessionOutfits: Prisma.$MCPSessionOutfitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      bucket_name: string | null
      image_key: string | null
      title: string
      is_favorite: boolean
      is_recurring: boolean
      wear_count: number
      last_worn_at: Date | null
      mcp_session_id: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["outfit"]>
    composites: {}
  }

  type OutfitGetPayload<S extends boolean | null | undefined | OutfitDefaultArgs> = $Result.GetResult<Prisma.$OutfitPayload, S>

  type OutfitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutfitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutfitCountAggregateInputType | true
    }

  export interface OutfitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Outfit'], meta: { name: 'Outfit' } }
    /**
     * Find zero or one Outfit that matches the filter.
     * @param {OutfitFindUniqueArgs} args - Arguments to find a Outfit
     * @example
     * // Get one Outfit
     * const outfit = await prisma.outfit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutfitFindUniqueArgs>(args: SelectSubset<T, OutfitFindUniqueArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Outfit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutfitFindUniqueOrThrowArgs} args - Arguments to find a Outfit
     * @example
     * // Get one Outfit
     * const outfit = await prisma.outfit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutfitFindUniqueOrThrowArgs>(args: SelectSubset<T, OutfitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Outfit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitFindFirstArgs} args - Arguments to find a Outfit
     * @example
     * // Get one Outfit
     * const outfit = await prisma.outfit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutfitFindFirstArgs>(args?: SelectSubset<T, OutfitFindFirstArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Outfit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitFindFirstOrThrowArgs} args - Arguments to find a Outfit
     * @example
     * // Get one Outfit
     * const outfit = await prisma.outfit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutfitFindFirstOrThrowArgs>(args?: SelectSubset<T, OutfitFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Outfits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Outfits
     * const outfits = await prisma.outfit.findMany()
     * 
     * // Get first 10 Outfits
     * const outfits = await prisma.outfit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outfitWithIdOnly = await prisma.outfit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutfitFindManyArgs>(args?: SelectSubset<T, OutfitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Outfit.
     * @param {OutfitCreateArgs} args - Arguments to create a Outfit.
     * @example
     * // Create one Outfit
     * const Outfit = await prisma.outfit.create({
     *   data: {
     *     // ... data to create a Outfit
     *   }
     * })
     * 
     */
    create<T extends OutfitCreateArgs>(args: SelectSubset<T, OutfitCreateArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Outfits.
     * @param {OutfitCreateManyArgs} args - Arguments to create many Outfits.
     * @example
     * // Create many Outfits
     * const outfit = await prisma.outfit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutfitCreateManyArgs>(args?: SelectSubset<T, OutfitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Outfits and returns the data saved in the database.
     * @param {OutfitCreateManyAndReturnArgs} args - Arguments to create many Outfits.
     * @example
     * // Create many Outfits
     * const outfit = await prisma.outfit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Outfits and only return the `id`
     * const outfitWithIdOnly = await prisma.outfit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutfitCreateManyAndReturnArgs>(args?: SelectSubset<T, OutfitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Outfit.
     * @param {OutfitDeleteArgs} args - Arguments to delete one Outfit.
     * @example
     * // Delete one Outfit
     * const Outfit = await prisma.outfit.delete({
     *   where: {
     *     // ... filter to delete one Outfit
     *   }
     * })
     * 
     */
    delete<T extends OutfitDeleteArgs>(args: SelectSubset<T, OutfitDeleteArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Outfit.
     * @param {OutfitUpdateArgs} args - Arguments to update one Outfit.
     * @example
     * // Update one Outfit
     * const outfit = await prisma.outfit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutfitUpdateArgs>(args: SelectSubset<T, OutfitUpdateArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Outfits.
     * @param {OutfitDeleteManyArgs} args - Arguments to filter Outfits to delete.
     * @example
     * // Delete a few Outfits
     * const { count } = await prisma.outfit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutfitDeleteManyArgs>(args?: SelectSubset<T, OutfitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outfits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Outfits
     * const outfit = await prisma.outfit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutfitUpdateManyArgs>(args: SelectSubset<T, OutfitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outfits and returns the data updated in the database.
     * @param {OutfitUpdateManyAndReturnArgs} args - Arguments to update many Outfits.
     * @example
     * // Update many Outfits
     * const outfit = await prisma.outfit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Outfits and only return the `id`
     * const outfitWithIdOnly = await prisma.outfit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutfitUpdateManyAndReturnArgs>(args: SelectSubset<T, OutfitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Outfit.
     * @param {OutfitUpsertArgs} args - Arguments to update or create a Outfit.
     * @example
     * // Update or create a Outfit
     * const outfit = await prisma.outfit.upsert({
     *   create: {
     *     // ... data to create a Outfit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Outfit we want to update
     *   }
     * })
     */
    upsert<T extends OutfitUpsertArgs>(args: SelectSubset<T, OutfitUpsertArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Outfits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitCountArgs} args - Arguments to filter Outfits to count.
     * @example
     * // Count the number of Outfits
     * const count = await prisma.outfit.count({
     *   where: {
     *     // ... the filter for the Outfits we want to count
     *   }
     * })
    **/
    count<T extends OutfitCountArgs>(
      args?: Subset<T, OutfitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutfitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Outfit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutfitAggregateArgs>(args: Subset<T, OutfitAggregateArgs>): Prisma.PrismaPromise<GetOutfitAggregateType<T>>

    /**
     * Group by Outfit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutfitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutfitGroupByArgs['orderBy'] }
        : { orderBy?: OutfitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutfitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutfitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Outfit model
   */
  readonly fields: OutfitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Outfit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutfitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bucket<T extends Outfit$bucketArgs<ExtArgs> = {}>(args?: Subset<T, Outfit$bucketArgs<ExtArgs>>): Prisma__S3BucketClient<$Result.GetResult<Prisma.$S3BucketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mcpSession<T extends Outfit$mcpSessionArgs<ExtArgs> = {}>(args?: Subset<T, Outfit$mcpSessionArgs<ExtArgs>>): Prisma__MCPSessionClient<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    outfitClothingItems<T extends Outfit$outfitClothingItemsArgs<ExtArgs> = {}>(args?: Subset<T, Outfit$outfitClothingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mcpSessionOutfits<T extends Outfit$mcpSessionOutfitsArgs<ExtArgs> = {}>(args?: Subset<T, Outfit$mcpSessionOutfitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Outfit model
   */
  interface OutfitFieldRefs {
    readonly id: FieldRef<"Outfit", 'Int'>
    readonly user_id: FieldRef<"Outfit", 'Int'>
    readonly bucket_name: FieldRef<"Outfit", 'String'>
    readonly image_key: FieldRef<"Outfit", 'String'>
    readonly title: FieldRef<"Outfit", 'String'>
    readonly is_favorite: FieldRef<"Outfit", 'Boolean'>
    readonly is_recurring: FieldRef<"Outfit", 'Boolean'>
    readonly wear_count: FieldRef<"Outfit", 'Int'>
    readonly last_worn_at: FieldRef<"Outfit", 'DateTime'>
    readonly mcp_session_id: FieldRef<"Outfit", 'Int'>
    readonly created_at: FieldRef<"Outfit", 'DateTime'>
    readonly updated_at: FieldRef<"Outfit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Outfit findUnique
   */
  export type OutfitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter, which Outfit to fetch.
     */
    where: OutfitWhereUniqueInput
  }

  /**
   * Outfit findUniqueOrThrow
   */
  export type OutfitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter, which Outfit to fetch.
     */
    where: OutfitWhereUniqueInput
  }

  /**
   * Outfit findFirst
   */
  export type OutfitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter, which Outfit to fetch.
     */
    where?: OutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outfits to fetch.
     */
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outfits.
     */
    cursor?: OutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outfits.
     */
    distinct?: OutfitScalarFieldEnum | OutfitScalarFieldEnum[]
  }

  /**
   * Outfit findFirstOrThrow
   */
  export type OutfitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter, which Outfit to fetch.
     */
    where?: OutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outfits to fetch.
     */
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outfits.
     */
    cursor?: OutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outfits.
     */
    distinct?: OutfitScalarFieldEnum | OutfitScalarFieldEnum[]
  }

  /**
   * Outfit findMany
   */
  export type OutfitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter, which Outfits to fetch.
     */
    where?: OutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outfits to fetch.
     */
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Outfits.
     */
    cursor?: OutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outfits.
     */
    skip?: number
    distinct?: OutfitScalarFieldEnum | OutfitScalarFieldEnum[]
  }

  /**
   * Outfit create
   */
  export type OutfitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * The data needed to create a Outfit.
     */
    data: XOR<OutfitCreateInput, OutfitUncheckedCreateInput>
  }

  /**
   * Outfit createMany
   */
  export type OutfitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Outfits.
     */
    data: OutfitCreateManyInput | OutfitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Outfit createManyAndReturn
   */
  export type OutfitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * The data used to create many Outfits.
     */
    data: OutfitCreateManyInput | OutfitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Outfit update
   */
  export type OutfitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * The data needed to update a Outfit.
     */
    data: XOR<OutfitUpdateInput, OutfitUncheckedUpdateInput>
    /**
     * Choose, which Outfit to update.
     */
    where: OutfitWhereUniqueInput
  }

  /**
   * Outfit updateMany
   */
  export type OutfitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Outfits.
     */
    data: XOR<OutfitUpdateManyMutationInput, OutfitUncheckedUpdateManyInput>
    /**
     * Filter which Outfits to update
     */
    where?: OutfitWhereInput
    /**
     * Limit how many Outfits to update.
     */
    limit?: number
  }

  /**
   * Outfit updateManyAndReturn
   */
  export type OutfitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * The data used to update Outfits.
     */
    data: XOR<OutfitUpdateManyMutationInput, OutfitUncheckedUpdateManyInput>
    /**
     * Filter which Outfits to update
     */
    where?: OutfitWhereInput
    /**
     * Limit how many Outfits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Outfit upsert
   */
  export type OutfitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * The filter to search for the Outfit to update in case it exists.
     */
    where: OutfitWhereUniqueInput
    /**
     * In case the Outfit found by the `where` argument doesn't exist, create a new Outfit with this data.
     */
    create: XOR<OutfitCreateInput, OutfitUncheckedCreateInput>
    /**
     * In case the Outfit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutfitUpdateInput, OutfitUncheckedUpdateInput>
  }

  /**
   * Outfit delete
   */
  export type OutfitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    /**
     * Filter which Outfit to delete.
     */
    where: OutfitWhereUniqueInput
  }

  /**
   * Outfit deleteMany
   */
  export type OutfitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outfits to delete
     */
    where?: OutfitWhereInput
    /**
     * Limit how many Outfits to delete.
     */
    limit?: number
  }

  /**
   * Outfit.bucket
   */
  export type Outfit$bucketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3Bucket
     */
    select?: S3BucketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3Bucket
     */
    omit?: S3BucketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3BucketInclude<ExtArgs> | null
    where?: S3BucketWhereInput
  }

  /**
   * Outfit.mcpSession
   */
  export type Outfit$mcpSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    where?: MCPSessionWhereInput
  }

  /**
   * Outfit.outfitClothingItems
   */
  export type Outfit$outfitClothingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    where?: OutfitClothingItemWhereInput
    orderBy?: OutfitClothingItemOrderByWithRelationInput | OutfitClothingItemOrderByWithRelationInput[]
    cursor?: OutfitClothingItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutfitClothingItemScalarFieldEnum | OutfitClothingItemScalarFieldEnum[]
  }

  /**
   * Outfit.mcpSessionOutfits
   */
  export type Outfit$mcpSessionOutfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    where?: MCPSessionOutfitWhereInput
    orderBy?: MCPSessionOutfitOrderByWithRelationInput | MCPSessionOutfitOrderByWithRelationInput[]
    cursor?: MCPSessionOutfitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MCPSessionOutfitScalarFieldEnum | MCPSessionOutfitScalarFieldEnum[]
  }

  /**
   * Outfit without action
   */
  export type OutfitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
  }


  /**
   * Model OutfitClothingItem
   */

  export type AggregateOutfitClothingItem = {
    _count: OutfitClothingItemCountAggregateOutputType | null
    _avg: OutfitClothingItemAvgAggregateOutputType | null
    _sum: OutfitClothingItemSumAggregateOutputType | null
    _min: OutfitClothingItemMinAggregateOutputType | null
    _max: OutfitClothingItemMaxAggregateOutputType | null
  }

  export type OutfitClothingItemAvgAggregateOutputType = {
    outfit_id: number | null
    clothing_item_id: number | null
  }

  export type OutfitClothingItemSumAggregateOutputType = {
    outfit_id: number | null
    clothing_item_id: number | null
  }

  export type OutfitClothingItemMinAggregateOutputType = {
    outfit_id: number | null
    clothing_item_id: number | null
    added_at: Date | null
  }

  export type OutfitClothingItemMaxAggregateOutputType = {
    outfit_id: number | null
    clothing_item_id: number | null
    added_at: Date | null
  }

  export type OutfitClothingItemCountAggregateOutputType = {
    outfit_id: number
    clothing_item_id: number
    added_at: number
    _all: number
  }


  export type OutfitClothingItemAvgAggregateInputType = {
    outfit_id?: true
    clothing_item_id?: true
  }

  export type OutfitClothingItemSumAggregateInputType = {
    outfit_id?: true
    clothing_item_id?: true
  }

  export type OutfitClothingItemMinAggregateInputType = {
    outfit_id?: true
    clothing_item_id?: true
    added_at?: true
  }

  export type OutfitClothingItemMaxAggregateInputType = {
    outfit_id?: true
    clothing_item_id?: true
    added_at?: true
  }

  export type OutfitClothingItemCountAggregateInputType = {
    outfit_id?: true
    clothing_item_id?: true
    added_at?: true
    _all?: true
  }

  export type OutfitClothingItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutfitClothingItem to aggregate.
     */
    where?: OutfitClothingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutfitClothingItems to fetch.
     */
    orderBy?: OutfitClothingItemOrderByWithRelationInput | OutfitClothingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutfitClothingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutfitClothingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutfitClothingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutfitClothingItems
    **/
    _count?: true | OutfitClothingItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutfitClothingItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutfitClothingItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutfitClothingItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutfitClothingItemMaxAggregateInputType
  }

  export type GetOutfitClothingItemAggregateType<T extends OutfitClothingItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOutfitClothingItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutfitClothingItem[P]>
      : GetScalarType<T[P], AggregateOutfitClothingItem[P]>
  }




  export type OutfitClothingItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutfitClothingItemWhereInput
    orderBy?: OutfitClothingItemOrderByWithAggregationInput | OutfitClothingItemOrderByWithAggregationInput[]
    by: OutfitClothingItemScalarFieldEnum[] | OutfitClothingItemScalarFieldEnum
    having?: OutfitClothingItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutfitClothingItemCountAggregateInputType | true
    _avg?: OutfitClothingItemAvgAggregateInputType
    _sum?: OutfitClothingItemSumAggregateInputType
    _min?: OutfitClothingItemMinAggregateInputType
    _max?: OutfitClothingItemMaxAggregateInputType
  }

  export type OutfitClothingItemGroupByOutputType = {
    outfit_id: number
    clothing_item_id: number
    added_at: Date
    _count: OutfitClothingItemCountAggregateOutputType | null
    _avg: OutfitClothingItemAvgAggregateOutputType | null
    _sum: OutfitClothingItemSumAggregateOutputType | null
    _min: OutfitClothingItemMinAggregateOutputType | null
    _max: OutfitClothingItemMaxAggregateOutputType | null
  }

  type GetOutfitClothingItemGroupByPayload<T extends OutfitClothingItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutfitClothingItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutfitClothingItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutfitClothingItemGroupByOutputType[P]>
            : GetScalarType<T[P], OutfitClothingItemGroupByOutputType[P]>
        }
      >
    >


  export type OutfitClothingItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    outfit_id?: boolean
    clothing_item_id?: boolean
    added_at?: boolean
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
    clothingItem?: boolean | ClothingItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outfitClothingItem"]>

  export type OutfitClothingItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    outfit_id?: boolean
    clothing_item_id?: boolean
    added_at?: boolean
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
    clothingItem?: boolean | ClothingItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outfitClothingItem"]>

  export type OutfitClothingItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    outfit_id?: boolean
    clothing_item_id?: boolean
    added_at?: boolean
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
    clothingItem?: boolean | ClothingItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outfitClothingItem"]>

  export type OutfitClothingItemSelectScalar = {
    outfit_id?: boolean
    clothing_item_id?: boolean
    added_at?: boolean
  }

  export type OutfitClothingItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"outfit_id" | "clothing_item_id" | "added_at", ExtArgs["result"]["outfitClothingItem"]>
  export type OutfitClothingItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
    clothingItem?: boolean | ClothingItemDefaultArgs<ExtArgs>
  }
  export type OutfitClothingItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
    clothingItem?: boolean | ClothingItemDefaultArgs<ExtArgs>
  }
  export type OutfitClothingItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
    clothingItem?: boolean | ClothingItemDefaultArgs<ExtArgs>
  }

  export type $OutfitClothingItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutfitClothingItem"
    objects: {
      outfit: Prisma.$OutfitPayload<ExtArgs>
      clothingItem: Prisma.$ClothingItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      outfit_id: number
      clothing_item_id: number
      added_at: Date
    }, ExtArgs["result"]["outfitClothingItem"]>
    composites: {}
  }

  type OutfitClothingItemGetPayload<S extends boolean | null | undefined | OutfitClothingItemDefaultArgs> = $Result.GetResult<Prisma.$OutfitClothingItemPayload, S>

  type OutfitClothingItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutfitClothingItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutfitClothingItemCountAggregateInputType | true
    }

  export interface OutfitClothingItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutfitClothingItem'], meta: { name: 'OutfitClothingItem' } }
    /**
     * Find zero or one OutfitClothingItem that matches the filter.
     * @param {OutfitClothingItemFindUniqueArgs} args - Arguments to find a OutfitClothingItem
     * @example
     * // Get one OutfitClothingItem
     * const outfitClothingItem = await prisma.outfitClothingItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutfitClothingItemFindUniqueArgs>(args: SelectSubset<T, OutfitClothingItemFindUniqueArgs<ExtArgs>>): Prisma__OutfitClothingItemClient<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OutfitClothingItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutfitClothingItemFindUniqueOrThrowArgs} args - Arguments to find a OutfitClothingItem
     * @example
     * // Get one OutfitClothingItem
     * const outfitClothingItem = await prisma.outfitClothingItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutfitClothingItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OutfitClothingItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutfitClothingItemClient<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutfitClothingItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitClothingItemFindFirstArgs} args - Arguments to find a OutfitClothingItem
     * @example
     * // Get one OutfitClothingItem
     * const outfitClothingItem = await prisma.outfitClothingItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutfitClothingItemFindFirstArgs>(args?: SelectSubset<T, OutfitClothingItemFindFirstArgs<ExtArgs>>): Prisma__OutfitClothingItemClient<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutfitClothingItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitClothingItemFindFirstOrThrowArgs} args - Arguments to find a OutfitClothingItem
     * @example
     * // Get one OutfitClothingItem
     * const outfitClothingItem = await prisma.outfitClothingItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutfitClothingItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OutfitClothingItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutfitClothingItemClient<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OutfitClothingItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitClothingItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutfitClothingItems
     * const outfitClothingItems = await prisma.outfitClothingItem.findMany()
     * 
     * // Get first 10 OutfitClothingItems
     * const outfitClothingItems = await prisma.outfitClothingItem.findMany({ take: 10 })
     * 
     * // Only select the `outfit_id`
     * const outfitClothingItemWithOutfit_idOnly = await prisma.outfitClothingItem.findMany({ select: { outfit_id: true } })
     * 
     */
    findMany<T extends OutfitClothingItemFindManyArgs>(args?: SelectSubset<T, OutfitClothingItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OutfitClothingItem.
     * @param {OutfitClothingItemCreateArgs} args - Arguments to create a OutfitClothingItem.
     * @example
     * // Create one OutfitClothingItem
     * const OutfitClothingItem = await prisma.outfitClothingItem.create({
     *   data: {
     *     // ... data to create a OutfitClothingItem
     *   }
     * })
     * 
     */
    create<T extends OutfitClothingItemCreateArgs>(args: SelectSubset<T, OutfitClothingItemCreateArgs<ExtArgs>>): Prisma__OutfitClothingItemClient<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OutfitClothingItems.
     * @param {OutfitClothingItemCreateManyArgs} args - Arguments to create many OutfitClothingItems.
     * @example
     * // Create many OutfitClothingItems
     * const outfitClothingItem = await prisma.outfitClothingItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutfitClothingItemCreateManyArgs>(args?: SelectSubset<T, OutfitClothingItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutfitClothingItems and returns the data saved in the database.
     * @param {OutfitClothingItemCreateManyAndReturnArgs} args - Arguments to create many OutfitClothingItems.
     * @example
     * // Create many OutfitClothingItems
     * const outfitClothingItem = await prisma.outfitClothingItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutfitClothingItems and only return the `outfit_id`
     * const outfitClothingItemWithOutfit_idOnly = await prisma.outfitClothingItem.createManyAndReturn({
     *   select: { outfit_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutfitClothingItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OutfitClothingItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OutfitClothingItem.
     * @param {OutfitClothingItemDeleteArgs} args - Arguments to delete one OutfitClothingItem.
     * @example
     * // Delete one OutfitClothingItem
     * const OutfitClothingItem = await prisma.outfitClothingItem.delete({
     *   where: {
     *     // ... filter to delete one OutfitClothingItem
     *   }
     * })
     * 
     */
    delete<T extends OutfitClothingItemDeleteArgs>(args: SelectSubset<T, OutfitClothingItemDeleteArgs<ExtArgs>>): Prisma__OutfitClothingItemClient<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OutfitClothingItem.
     * @param {OutfitClothingItemUpdateArgs} args - Arguments to update one OutfitClothingItem.
     * @example
     * // Update one OutfitClothingItem
     * const outfitClothingItem = await prisma.outfitClothingItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutfitClothingItemUpdateArgs>(args: SelectSubset<T, OutfitClothingItemUpdateArgs<ExtArgs>>): Prisma__OutfitClothingItemClient<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OutfitClothingItems.
     * @param {OutfitClothingItemDeleteManyArgs} args - Arguments to filter OutfitClothingItems to delete.
     * @example
     * // Delete a few OutfitClothingItems
     * const { count } = await prisma.outfitClothingItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutfitClothingItemDeleteManyArgs>(args?: SelectSubset<T, OutfitClothingItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutfitClothingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitClothingItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutfitClothingItems
     * const outfitClothingItem = await prisma.outfitClothingItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutfitClothingItemUpdateManyArgs>(args: SelectSubset<T, OutfitClothingItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutfitClothingItems and returns the data updated in the database.
     * @param {OutfitClothingItemUpdateManyAndReturnArgs} args - Arguments to update many OutfitClothingItems.
     * @example
     * // Update many OutfitClothingItems
     * const outfitClothingItem = await prisma.outfitClothingItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OutfitClothingItems and only return the `outfit_id`
     * const outfitClothingItemWithOutfit_idOnly = await prisma.outfitClothingItem.updateManyAndReturn({
     *   select: { outfit_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutfitClothingItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OutfitClothingItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OutfitClothingItem.
     * @param {OutfitClothingItemUpsertArgs} args - Arguments to update or create a OutfitClothingItem.
     * @example
     * // Update or create a OutfitClothingItem
     * const outfitClothingItem = await prisma.outfitClothingItem.upsert({
     *   create: {
     *     // ... data to create a OutfitClothingItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutfitClothingItem we want to update
     *   }
     * })
     */
    upsert<T extends OutfitClothingItemUpsertArgs>(args: SelectSubset<T, OutfitClothingItemUpsertArgs<ExtArgs>>): Prisma__OutfitClothingItemClient<$Result.GetResult<Prisma.$OutfitClothingItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OutfitClothingItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitClothingItemCountArgs} args - Arguments to filter OutfitClothingItems to count.
     * @example
     * // Count the number of OutfitClothingItems
     * const count = await prisma.outfitClothingItem.count({
     *   where: {
     *     // ... the filter for the OutfitClothingItems we want to count
     *   }
     * })
    **/
    count<T extends OutfitClothingItemCountArgs>(
      args?: Subset<T, OutfitClothingItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutfitClothingItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutfitClothingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitClothingItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutfitClothingItemAggregateArgs>(args: Subset<T, OutfitClothingItemAggregateArgs>): Prisma.PrismaPromise<GetOutfitClothingItemAggregateType<T>>

    /**
     * Group by OutfitClothingItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutfitClothingItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutfitClothingItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutfitClothingItemGroupByArgs['orderBy'] }
        : { orderBy?: OutfitClothingItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutfitClothingItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutfitClothingItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutfitClothingItem model
   */
  readonly fields: OutfitClothingItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutfitClothingItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutfitClothingItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    outfit<T extends OutfitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutfitDefaultArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clothingItem<T extends ClothingItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClothingItemDefaultArgs<ExtArgs>>): Prisma__ClothingItemClient<$Result.GetResult<Prisma.$ClothingItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutfitClothingItem model
   */
  interface OutfitClothingItemFieldRefs {
    readonly outfit_id: FieldRef<"OutfitClothingItem", 'Int'>
    readonly clothing_item_id: FieldRef<"OutfitClothingItem", 'Int'>
    readonly added_at: FieldRef<"OutfitClothingItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutfitClothingItem findUnique
   */
  export type OutfitClothingItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    /**
     * Filter, which OutfitClothingItem to fetch.
     */
    where: OutfitClothingItemWhereUniqueInput
  }

  /**
   * OutfitClothingItem findUniqueOrThrow
   */
  export type OutfitClothingItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    /**
     * Filter, which OutfitClothingItem to fetch.
     */
    where: OutfitClothingItemWhereUniqueInput
  }

  /**
   * OutfitClothingItem findFirst
   */
  export type OutfitClothingItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    /**
     * Filter, which OutfitClothingItem to fetch.
     */
    where?: OutfitClothingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutfitClothingItems to fetch.
     */
    orderBy?: OutfitClothingItemOrderByWithRelationInput | OutfitClothingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutfitClothingItems.
     */
    cursor?: OutfitClothingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutfitClothingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutfitClothingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutfitClothingItems.
     */
    distinct?: OutfitClothingItemScalarFieldEnum | OutfitClothingItemScalarFieldEnum[]
  }

  /**
   * OutfitClothingItem findFirstOrThrow
   */
  export type OutfitClothingItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    /**
     * Filter, which OutfitClothingItem to fetch.
     */
    where?: OutfitClothingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutfitClothingItems to fetch.
     */
    orderBy?: OutfitClothingItemOrderByWithRelationInput | OutfitClothingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutfitClothingItems.
     */
    cursor?: OutfitClothingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutfitClothingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutfitClothingItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutfitClothingItems.
     */
    distinct?: OutfitClothingItemScalarFieldEnum | OutfitClothingItemScalarFieldEnum[]
  }

  /**
   * OutfitClothingItem findMany
   */
  export type OutfitClothingItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    /**
     * Filter, which OutfitClothingItems to fetch.
     */
    where?: OutfitClothingItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutfitClothingItems to fetch.
     */
    orderBy?: OutfitClothingItemOrderByWithRelationInput | OutfitClothingItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutfitClothingItems.
     */
    cursor?: OutfitClothingItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutfitClothingItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutfitClothingItems.
     */
    skip?: number
    distinct?: OutfitClothingItemScalarFieldEnum | OutfitClothingItemScalarFieldEnum[]
  }

  /**
   * OutfitClothingItem create
   */
  export type OutfitClothingItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OutfitClothingItem.
     */
    data: XOR<OutfitClothingItemCreateInput, OutfitClothingItemUncheckedCreateInput>
  }

  /**
   * OutfitClothingItem createMany
   */
  export type OutfitClothingItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutfitClothingItems.
     */
    data: OutfitClothingItemCreateManyInput | OutfitClothingItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutfitClothingItem createManyAndReturn
   */
  export type OutfitClothingItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * The data used to create many OutfitClothingItems.
     */
    data: OutfitClothingItemCreateManyInput | OutfitClothingItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutfitClothingItem update
   */
  export type OutfitClothingItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OutfitClothingItem.
     */
    data: XOR<OutfitClothingItemUpdateInput, OutfitClothingItemUncheckedUpdateInput>
    /**
     * Choose, which OutfitClothingItem to update.
     */
    where: OutfitClothingItemWhereUniqueInput
  }

  /**
   * OutfitClothingItem updateMany
   */
  export type OutfitClothingItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutfitClothingItems.
     */
    data: XOR<OutfitClothingItemUpdateManyMutationInput, OutfitClothingItemUncheckedUpdateManyInput>
    /**
     * Filter which OutfitClothingItems to update
     */
    where?: OutfitClothingItemWhereInput
    /**
     * Limit how many OutfitClothingItems to update.
     */
    limit?: number
  }

  /**
   * OutfitClothingItem updateManyAndReturn
   */
  export type OutfitClothingItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * The data used to update OutfitClothingItems.
     */
    data: XOR<OutfitClothingItemUpdateManyMutationInput, OutfitClothingItemUncheckedUpdateManyInput>
    /**
     * Filter which OutfitClothingItems to update
     */
    where?: OutfitClothingItemWhereInput
    /**
     * Limit how many OutfitClothingItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutfitClothingItem upsert
   */
  export type OutfitClothingItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OutfitClothingItem to update in case it exists.
     */
    where: OutfitClothingItemWhereUniqueInput
    /**
     * In case the OutfitClothingItem found by the `where` argument doesn't exist, create a new OutfitClothingItem with this data.
     */
    create: XOR<OutfitClothingItemCreateInput, OutfitClothingItemUncheckedCreateInput>
    /**
     * In case the OutfitClothingItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutfitClothingItemUpdateInput, OutfitClothingItemUncheckedUpdateInput>
  }

  /**
   * OutfitClothingItem delete
   */
  export type OutfitClothingItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
    /**
     * Filter which OutfitClothingItem to delete.
     */
    where: OutfitClothingItemWhereUniqueInput
  }

  /**
   * OutfitClothingItem deleteMany
   */
  export type OutfitClothingItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutfitClothingItems to delete
     */
    where?: OutfitClothingItemWhereInput
    /**
     * Limit how many OutfitClothingItems to delete.
     */
    limit?: number
  }

  /**
   * OutfitClothingItem without action
   */
  export type OutfitClothingItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutfitClothingItem
     */
    select?: OutfitClothingItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutfitClothingItem
     */
    omit?: OutfitClothingItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitClothingItemInclude<ExtArgs> | null
  }


  /**
   * Model ChatSession
   */

  export type AggregateChatSession = {
    _count: ChatSessionCountAggregateOutputType | null
    _avg: ChatSessionAvgAggregateOutputType | null
    _sum: ChatSessionSumAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  export type ChatSessionAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ChatSessionSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ChatSessionMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    started_at: Date | null
  }

  export type ChatSessionMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    started_at: Date | null
  }

  export type ChatSessionCountAggregateOutputType = {
    id: number
    user_id: number
    started_at: number
    _all: number
  }


  export type ChatSessionAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ChatSessionSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ChatSessionMinAggregateInputType = {
    id?: true
    user_id?: true
    started_at?: true
  }

  export type ChatSessionMaxAggregateInputType = {
    id?: true
    user_id?: true
    started_at?: true
  }

  export type ChatSessionCountAggregateInputType = {
    id?: true
    user_id?: true
    started_at?: true
    _all?: true
  }

  export type ChatSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSession to aggregate.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatSessions
    **/
    _count?: true | ChatSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatSessionMaxAggregateInputType
  }

  export type GetChatSessionAggregateType<T extends ChatSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateChatSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatSession[P]>
      : GetScalarType<T[P], AggregateChatSession[P]>
  }




  export type ChatSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithAggregationInput | ChatSessionOrderByWithAggregationInput[]
    by: ChatSessionScalarFieldEnum[] | ChatSessionScalarFieldEnum
    having?: ChatSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatSessionCountAggregateInputType | true
    _avg?: ChatSessionAvgAggregateInputType
    _sum?: ChatSessionSumAggregateInputType
    _min?: ChatSessionMinAggregateInputType
    _max?: ChatSessionMaxAggregateInputType
  }

  export type ChatSessionGroupByOutputType = {
    id: number
    user_id: number
    started_at: Date
    _count: ChatSessionCountAggregateOutputType | null
    _avg: ChatSessionAvgAggregateOutputType | null
    _sum: ChatSessionSumAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  type GetChatSessionGroupByPayload<T extends ChatSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
        }
      >
    >


  export type ChatSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    started_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | ChatSession$messagesArgs<ExtArgs>
    _count?: boolean | ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    started_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    started_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectScalar = {
    id?: boolean
    user_id?: boolean
    started_at?: boolean
  }

  export type ChatSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "started_at", ExtArgs["result"]["chatSession"]>
  export type ChatSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | ChatSession$messagesArgs<ExtArgs>
    _count?: boolean | ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      started_at: Date
    }, ExtArgs["result"]["chatSession"]>
    composites: {}
  }

  type ChatSessionGetPayload<S extends boolean | null | undefined | ChatSessionDefaultArgs> = $Result.GetResult<Prisma.$ChatSessionPayload, S>

  type ChatSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatSessionCountAggregateInputType | true
    }

  export interface ChatSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatSession'], meta: { name: 'ChatSession' } }
    /**
     * Find zero or one ChatSession that matches the filter.
     * @param {ChatSessionFindUniqueArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatSessionFindUniqueArgs>(args: SelectSubset<T, ChatSessionFindUniqueArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatSessionFindUniqueOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatSessionFindFirstArgs>(args?: SelectSubset<T, ChatSessionFindFirstArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatSessions
     * const chatSessions = await prisma.chatSession.findMany()
     * 
     * // Get first 10 ChatSessions
     * const chatSessions = await prisma.chatSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatSessionFindManyArgs>(args?: SelectSubset<T, ChatSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatSession.
     * @param {ChatSessionCreateArgs} args - Arguments to create a ChatSession.
     * @example
     * // Create one ChatSession
     * const ChatSession = await prisma.chatSession.create({
     *   data: {
     *     // ... data to create a ChatSession
     *   }
     * })
     * 
     */
    create<T extends ChatSessionCreateArgs>(args: SelectSubset<T, ChatSessionCreateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatSessions.
     * @param {ChatSessionCreateManyArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatSessionCreateManyArgs>(args?: SelectSubset<T, ChatSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatSessions and returns the data saved in the database.
     * @param {ChatSessionCreateManyAndReturnArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatSessions and only return the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatSession.
     * @param {ChatSessionDeleteArgs} args - Arguments to delete one ChatSession.
     * @example
     * // Delete one ChatSession
     * const ChatSession = await prisma.chatSession.delete({
     *   where: {
     *     // ... filter to delete one ChatSession
     *   }
     * })
     * 
     */
    delete<T extends ChatSessionDeleteArgs>(args: SelectSubset<T, ChatSessionDeleteArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatSession.
     * @param {ChatSessionUpdateArgs} args - Arguments to update one ChatSession.
     * @example
     * // Update one ChatSession
     * const chatSession = await prisma.chatSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatSessionUpdateArgs>(args: SelectSubset<T, ChatSessionUpdateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatSessions.
     * @param {ChatSessionDeleteManyArgs} args - Arguments to filter ChatSessions to delete.
     * @example
     * // Delete a few ChatSessions
     * const { count } = await prisma.chatSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatSessionDeleteManyArgs>(args?: SelectSubset<T, ChatSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatSessionUpdateManyArgs>(args: SelectSubset<T, ChatSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions and returns the data updated in the database.
     * @param {ChatSessionUpdateManyAndReturnArgs} args - Arguments to update many ChatSessions.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatSessions and only return the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatSession.
     * @param {ChatSessionUpsertArgs} args - Arguments to update or create a ChatSession.
     * @example
     * // Update or create a ChatSession
     * const chatSession = await prisma.chatSession.upsert({
     *   create: {
     *     // ... data to create a ChatSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatSession we want to update
     *   }
     * })
     */
    upsert<T extends ChatSessionUpsertArgs>(args: SelectSubset<T, ChatSessionUpsertArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionCountArgs} args - Arguments to filter ChatSessions to count.
     * @example
     * // Count the number of ChatSessions
     * const count = await prisma.chatSession.count({
     *   where: {
     *     // ... the filter for the ChatSessions we want to count
     *   }
     * })
    **/
    count<T extends ChatSessionCountArgs>(
      args?: Subset<T, ChatSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatSessionAggregateArgs>(args: Subset<T, ChatSessionAggregateArgs>): Prisma.PrismaPromise<GetChatSessionAggregateType<T>>

    /**
     * Group by ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatSessionGroupByArgs['orderBy'] }
        : { orderBy?: ChatSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatSession model
   */
  readonly fields: ChatSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends ChatSession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatSession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatSession model
   */
  interface ChatSessionFieldRefs {
    readonly id: FieldRef<"ChatSession", 'Int'>
    readonly user_id: FieldRef<"ChatSession", 'Int'>
    readonly started_at: FieldRef<"ChatSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatSession findUnique
   */
  export type ChatSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findUniqueOrThrow
   */
  export type ChatSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findFirst
   */
  export type ChatSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findFirstOrThrow
   */
  export type ChatSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findMany
   */
  export type ChatSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSessions to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession create
   */
  export type ChatSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatSession.
     */
    data: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
  }

  /**
   * ChatSession createMany
   */
  export type ChatSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatSession createManyAndReturn
   */
  export type ChatSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatSession update
   */
  export type ChatSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatSession.
     */
    data: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
    /**
     * Choose, which ChatSession to update.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession updateMany
   */
  export type ChatSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to update.
     */
    limit?: number
  }

  /**
   * ChatSession updateManyAndReturn
   */
  export type ChatSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatSession upsert
   */
  export type ChatSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatSession to update in case it exists.
     */
    where: ChatSessionWhereUniqueInput
    /**
     * In case the ChatSession found by the `where` argument doesn't exist, create a new ChatSession with this data.
     */
    create: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
    /**
     * In case the ChatSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
  }

  /**
   * ChatSession delete
   */
  export type ChatSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter which ChatSession to delete.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession deleteMany
   */
  export type ChatSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSessions to delete
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to delete.
     */
    limit?: number
  }

  /**
   * ChatSession.messages
   */
  export type ChatSession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatSession without action
   */
  export type ChatSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageAvgAggregateOutputType = {
    id: number | null
    session_id: number | null
  }

  export type ChatMessageSumAggregateOutputType = {
    id: number | null
    session_id: number | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: number | null
    session_id: number | null
    role: string | null
    content: string | null
    sent_at: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: number | null
    session_id: number | null
    role: string | null
    content: string | null
    sent_at: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    session_id: number
    role: number
    content: number
    sent_at: number
    _all: number
  }


  export type ChatMessageAvgAggregateInputType = {
    id?: true
    session_id?: true
  }

  export type ChatMessageSumAggregateInputType = {
    id?: true
    session_id?: true
  }

  export type ChatMessageMinAggregateInputType = {
    id?: true
    session_id?: true
    role?: true
    content?: true
    sent_at?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    session_id?: true
    role?: true
    content?: true
    sent_at?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    session_id?: true
    role?: true
    content?: true
    sent_at?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _avg?: ChatMessageAvgAggregateInputType
    _sum?: ChatMessageSumAggregateInputType
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: number
    session_id: number
    role: string
    content: string
    sent_at: Date
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    role?: boolean
    content?: boolean
    sent_at?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    role?: boolean
    content?: boolean
    sent_at?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    role?: boolean
    content?: boolean
    sent_at?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    session_id?: boolean
    role?: boolean
    content?: boolean
    sent_at?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "session_id" | "role" | "content" | "sent_at", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      session: Prisma.$ChatSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      session_id: number
      role: string
      content: string
      sent_at: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends ChatSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatSessionDefaultArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'Int'>
    readonly session_id: FieldRef<"ChatMessage", 'Int'>
    readonly role: FieldRef<"ChatMessage", 'String'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly sent_at: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model MCPSession
   */

  export type AggregateMCPSession = {
    _count: MCPSessionCountAggregateOutputType | null
    _avg: MCPSessionAvgAggregateOutputType | null
    _sum: MCPSessionSumAggregateOutputType | null
    _min: MCPSessionMinAggregateOutputType | null
    _max: MCPSessionMaxAggregateOutputType | null
  }

  export type MCPSessionAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type MCPSessionSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type MCPSessionMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    status: string | null
    created_at: Date | null
    completed_at: Date | null
  }

  export type MCPSessionMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    status: string | null
    created_at: Date | null
    completed_at: Date | null
  }

  export type MCPSessionCountAggregateOutputType = {
    id: number
    user_id: number
    prompt_payload: number
    status: number
    created_at: number
    completed_at: number
    _all: number
  }


  export type MCPSessionAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type MCPSessionSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type MCPSessionMinAggregateInputType = {
    id?: true
    user_id?: true
    status?: true
    created_at?: true
    completed_at?: true
  }

  export type MCPSessionMaxAggregateInputType = {
    id?: true
    user_id?: true
    status?: true
    created_at?: true
    completed_at?: true
  }

  export type MCPSessionCountAggregateInputType = {
    id?: true
    user_id?: true
    prompt_payload?: true
    status?: true
    created_at?: true
    completed_at?: true
    _all?: true
  }

  export type MCPSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCPSession to aggregate.
     */
    where?: MCPSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPSessions to fetch.
     */
    orderBy?: MCPSessionOrderByWithRelationInput | MCPSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MCPSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MCPSessions
    **/
    _count?: true | MCPSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MCPSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MCPSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MCPSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MCPSessionMaxAggregateInputType
  }

  export type GetMCPSessionAggregateType<T extends MCPSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateMCPSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMCPSession[P]>
      : GetScalarType<T[P], AggregateMCPSession[P]>
  }




  export type MCPSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCPSessionWhereInput
    orderBy?: MCPSessionOrderByWithAggregationInput | MCPSessionOrderByWithAggregationInput[]
    by: MCPSessionScalarFieldEnum[] | MCPSessionScalarFieldEnum
    having?: MCPSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MCPSessionCountAggregateInputType | true
    _avg?: MCPSessionAvgAggregateInputType
    _sum?: MCPSessionSumAggregateInputType
    _min?: MCPSessionMinAggregateInputType
    _max?: MCPSessionMaxAggregateInputType
  }

  export type MCPSessionGroupByOutputType = {
    id: number
    user_id: number
    prompt_payload: JsonValue
    status: string
    created_at: Date
    completed_at: Date | null
    _count: MCPSessionCountAggregateOutputType | null
    _avg: MCPSessionAvgAggregateOutputType | null
    _sum: MCPSessionSumAggregateOutputType | null
    _min: MCPSessionMinAggregateOutputType | null
    _max: MCPSessionMaxAggregateOutputType | null
  }

  type GetMCPSessionGroupByPayload<T extends MCPSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MCPSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MCPSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MCPSessionGroupByOutputType[P]>
            : GetScalarType<T[P], MCPSessionGroupByOutputType[P]>
        }
      >
    >


  export type MCPSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    prompt_payload?: boolean
    status?: boolean
    created_at?: boolean
    completed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    outfits?: boolean | MCPSession$outfitsArgs<ExtArgs>
    mcpSessionOutfits?: boolean | MCPSession$mcpSessionOutfitsArgs<ExtArgs>
    _count?: boolean | MCPSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mCPSession"]>

  export type MCPSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    prompt_payload?: boolean
    status?: boolean
    created_at?: boolean
    completed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mCPSession"]>

  export type MCPSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    prompt_payload?: boolean
    status?: boolean
    created_at?: boolean
    completed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mCPSession"]>

  export type MCPSessionSelectScalar = {
    id?: boolean
    user_id?: boolean
    prompt_payload?: boolean
    status?: boolean
    created_at?: boolean
    completed_at?: boolean
  }

  export type MCPSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "prompt_payload" | "status" | "created_at" | "completed_at", ExtArgs["result"]["mCPSession"]>
  export type MCPSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    outfits?: boolean | MCPSession$outfitsArgs<ExtArgs>
    mcpSessionOutfits?: boolean | MCPSession$mcpSessionOutfitsArgs<ExtArgs>
    _count?: boolean | MCPSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MCPSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MCPSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MCPSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MCPSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      outfits: Prisma.$OutfitPayload<ExtArgs>[]
      mcpSessionOutfits: Prisma.$MCPSessionOutfitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      prompt_payload: Prisma.JsonValue
      status: string
      created_at: Date
      completed_at: Date | null
    }, ExtArgs["result"]["mCPSession"]>
    composites: {}
  }

  type MCPSessionGetPayload<S extends boolean | null | undefined | MCPSessionDefaultArgs> = $Result.GetResult<Prisma.$MCPSessionPayload, S>

  type MCPSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MCPSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MCPSessionCountAggregateInputType | true
    }

  export interface MCPSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MCPSession'], meta: { name: 'MCPSession' } }
    /**
     * Find zero or one MCPSession that matches the filter.
     * @param {MCPSessionFindUniqueArgs} args - Arguments to find a MCPSession
     * @example
     * // Get one MCPSession
     * const mCPSession = await prisma.mCPSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MCPSessionFindUniqueArgs>(args: SelectSubset<T, MCPSessionFindUniqueArgs<ExtArgs>>): Prisma__MCPSessionClient<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MCPSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MCPSessionFindUniqueOrThrowArgs} args - Arguments to find a MCPSession
     * @example
     * // Get one MCPSession
     * const mCPSession = await prisma.mCPSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MCPSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, MCPSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MCPSessionClient<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MCPSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionFindFirstArgs} args - Arguments to find a MCPSession
     * @example
     * // Get one MCPSession
     * const mCPSession = await prisma.mCPSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MCPSessionFindFirstArgs>(args?: SelectSubset<T, MCPSessionFindFirstArgs<ExtArgs>>): Prisma__MCPSessionClient<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MCPSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionFindFirstOrThrowArgs} args - Arguments to find a MCPSession
     * @example
     * // Get one MCPSession
     * const mCPSession = await prisma.mCPSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MCPSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, MCPSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MCPSessionClient<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MCPSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MCPSessions
     * const mCPSessions = await prisma.mCPSession.findMany()
     * 
     * // Get first 10 MCPSessions
     * const mCPSessions = await prisma.mCPSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mCPSessionWithIdOnly = await prisma.mCPSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MCPSessionFindManyArgs>(args?: SelectSubset<T, MCPSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MCPSession.
     * @param {MCPSessionCreateArgs} args - Arguments to create a MCPSession.
     * @example
     * // Create one MCPSession
     * const MCPSession = await prisma.mCPSession.create({
     *   data: {
     *     // ... data to create a MCPSession
     *   }
     * })
     * 
     */
    create<T extends MCPSessionCreateArgs>(args: SelectSubset<T, MCPSessionCreateArgs<ExtArgs>>): Prisma__MCPSessionClient<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MCPSessions.
     * @param {MCPSessionCreateManyArgs} args - Arguments to create many MCPSessions.
     * @example
     * // Create many MCPSessions
     * const mCPSession = await prisma.mCPSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MCPSessionCreateManyArgs>(args?: SelectSubset<T, MCPSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MCPSessions and returns the data saved in the database.
     * @param {MCPSessionCreateManyAndReturnArgs} args - Arguments to create many MCPSessions.
     * @example
     * // Create many MCPSessions
     * const mCPSession = await prisma.mCPSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MCPSessions and only return the `id`
     * const mCPSessionWithIdOnly = await prisma.mCPSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MCPSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, MCPSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MCPSession.
     * @param {MCPSessionDeleteArgs} args - Arguments to delete one MCPSession.
     * @example
     * // Delete one MCPSession
     * const MCPSession = await prisma.mCPSession.delete({
     *   where: {
     *     // ... filter to delete one MCPSession
     *   }
     * })
     * 
     */
    delete<T extends MCPSessionDeleteArgs>(args: SelectSubset<T, MCPSessionDeleteArgs<ExtArgs>>): Prisma__MCPSessionClient<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MCPSession.
     * @param {MCPSessionUpdateArgs} args - Arguments to update one MCPSession.
     * @example
     * // Update one MCPSession
     * const mCPSession = await prisma.mCPSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MCPSessionUpdateArgs>(args: SelectSubset<T, MCPSessionUpdateArgs<ExtArgs>>): Prisma__MCPSessionClient<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MCPSessions.
     * @param {MCPSessionDeleteManyArgs} args - Arguments to filter MCPSessions to delete.
     * @example
     * // Delete a few MCPSessions
     * const { count } = await prisma.mCPSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MCPSessionDeleteManyArgs>(args?: SelectSubset<T, MCPSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCPSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MCPSessions
     * const mCPSession = await prisma.mCPSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MCPSessionUpdateManyArgs>(args: SelectSubset<T, MCPSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCPSessions and returns the data updated in the database.
     * @param {MCPSessionUpdateManyAndReturnArgs} args - Arguments to update many MCPSessions.
     * @example
     * // Update many MCPSessions
     * const mCPSession = await prisma.mCPSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MCPSessions and only return the `id`
     * const mCPSessionWithIdOnly = await prisma.mCPSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MCPSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, MCPSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MCPSession.
     * @param {MCPSessionUpsertArgs} args - Arguments to update or create a MCPSession.
     * @example
     * // Update or create a MCPSession
     * const mCPSession = await prisma.mCPSession.upsert({
     *   create: {
     *     // ... data to create a MCPSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MCPSession we want to update
     *   }
     * })
     */
    upsert<T extends MCPSessionUpsertArgs>(args: SelectSubset<T, MCPSessionUpsertArgs<ExtArgs>>): Prisma__MCPSessionClient<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MCPSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionCountArgs} args - Arguments to filter MCPSessions to count.
     * @example
     * // Count the number of MCPSessions
     * const count = await prisma.mCPSession.count({
     *   where: {
     *     // ... the filter for the MCPSessions we want to count
     *   }
     * })
    **/
    count<T extends MCPSessionCountArgs>(
      args?: Subset<T, MCPSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MCPSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MCPSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MCPSessionAggregateArgs>(args: Subset<T, MCPSessionAggregateArgs>): Prisma.PrismaPromise<GetMCPSessionAggregateType<T>>

    /**
     * Group by MCPSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MCPSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MCPSessionGroupByArgs['orderBy'] }
        : { orderBy?: MCPSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MCPSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMCPSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MCPSession model
   */
  readonly fields: MCPSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MCPSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MCPSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outfits<T extends MCPSession$outfitsArgs<ExtArgs> = {}>(args?: Subset<T, MCPSession$outfitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mcpSessionOutfits<T extends MCPSession$mcpSessionOutfitsArgs<ExtArgs> = {}>(args?: Subset<T, MCPSession$mcpSessionOutfitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MCPSession model
   */
  interface MCPSessionFieldRefs {
    readonly id: FieldRef<"MCPSession", 'Int'>
    readonly user_id: FieldRef<"MCPSession", 'Int'>
    readonly prompt_payload: FieldRef<"MCPSession", 'Json'>
    readonly status: FieldRef<"MCPSession", 'String'>
    readonly created_at: FieldRef<"MCPSession", 'DateTime'>
    readonly completed_at: FieldRef<"MCPSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MCPSession findUnique
   */
  export type MCPSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    /**
     * Filter, which MCPSession to fetch.
     */
    where: MCPSessionWhereUniqueInput
  }

  /**
   * MCPSession findUniqueOrThrow
   */
  export type MCPSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    /**
     * Filter, which MCPSession to fetch.
     */
    where: MCPSessionWhereUniqueInput
  }

  /**
   * MCPSession findFirst
   */
  export type MCPSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    /**
     * Filter, which MCPSession to fetch.
     */
    where?: MCPSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPSessions to fetch.
     */
    orderBy?: MCPSessionOrderByWithRelationInput | MCPSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCPSessions.
     */
    cursor?: MCPSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCPSessions.
     */
    distinct?: MCPSessionScalarFieldEnum | MCPSessionScalarFieldEnum[]
  }

  /**
   * MCPSession findFirstOrThrow
   */
  export type MCPSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    /**
     * Filter, which MCPSession to fetch.
     */
    where?: MCPSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPSessions to fetch.
     */
    orderBy?: MCPSessionOrderByWithRelationInput | MCPSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCPSessions.
     */
    cursor?: MCPSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCPSessions.
     */
    distinct?: MCPSessionScalarFieldEnum | MCPSessionScalarFieldEnum[]
  }

  /**
   * MCPSession findMany
   */
  export type MCPSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    /**
     * Filter, which MCPSessions to fetch.
     */
    where?: MCPSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPSessions to fetch.
     */
    orderBy?: MCPSessionOrderByWithRelationInput | MCPSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MCPSessions.
     */
    cursor?: MCPSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPSessions.
     */
    skip?: number
    distinct?: MCPSessionScalarFieldEnum | MCPSessionScalarFieldEnum[]
  }

  /**
   * MCPSession create
   */
  export type MCPSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a MCPSession.
     */
    data: XOR<MCPSessionCreateInput, MCPSessionUncheckedCreateInput>
  }

  /**
   * MCPSession createMany
   */
  export type MCPSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MCPSessions.
     */
    data: MCPSessionCreateManyInput | MCPSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MCPSession createManyAndReturn
   */
  export type MCPSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * The data used to create many MCPSessions.
     */
    data: MCPSessionCreateManyInput | MCPSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MCPSession update
   */
  export type MCPSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a MCPSession.
     */
    data: XOR<MCPSessionUpdateInput, MCPSessionUncheckedUpdateInput>
    /**
     * Choose, which MCPSession to update.
     */
    where: MCPSessionWhereUniqueInput
  }

  /**
   * MCPSession updateMany
   */
  export type MCPSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MCPSessions.
     */
    data: XOR<MCPSessionUpdateManyMutationInput, MCPSessionUncheckedUpdateManyInput>
    /**
     * Filter which MCPSessions to update
     */
    where?: MCPSessionWhereInput
    /**
     * Limit how many MCPSessions to update.
     */
    limit?: number
  }

  /**
   * MCPSession updateManyAndReturn
   */
  export type MCPSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * The data used to update MCPSessions.
     */
    data: XOR<MCPSessionUpdateManyMutationInput, MCPSessionUncheckedUpdateManyInput>
    /**
     * Filter which MCPSessions to update
     */
    where?: MCPSessionWhereInput
    /**
     * Limit how many MCPSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MCPSession upsert
   */
  export type MCPSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the MCPSession to update in case it exists.
     */
    where: MCPSessionWhereUniqueInput
    /**
     * In case the MCPSession found by the `where` argument doesn't exist, create a new MCPSession with this data.
     */
    create: XOR<MCPSessionCreateInput, MCPSessionUncheckedCreateInput>
    /**
     * In case the MCPSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MCPSessionUpdateInput, MCPSessionUncheckedUpdateInput>
  }

  /**
   * MCPSession delete
   */
  export type MCPSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
    /**
     * Filter which MCPSession to delete.
     */
    where: MCPSessionWhereUniqueInput
  }

  /**
   * MCPSession deleteMany
   */
  export type MCPSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCPSessions to delete
     */
    where?: MCPSessionWhereInput
    /**
     * Limit how many MCPSessions to delete.
     */
    limit?: number
  }

  /**
   * MCPSession.outfits
   */
  export type MCPSession$outfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outfit
     */
    select?: OutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outfit
     */
    omit?: OutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutfitInclude<ExtArgs> | null
    where?: OutfitWhereInput
    orderBy?: OutfitOrderByWithRelationInput | OutfitOrderByWithRelationInput[]
    cursor?: OutfitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutfitScalarFieldEnum | OutfitScalarFieldEnum[]
  }

  /**
   * MCPSession.mcpSessionOutfits
   */
  export type MCPSession$mcpSessionOutfitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    where?: MCPSessionOutfitWhereInput
    orderBy?: MCPSessionOutfitOrderByWithRelationInput | MCPSessionOutfitOrderByWithRelationInput[]
    cursor?: MCPSessionOutfitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MCPSessionOutfitScalarFieldEnum | MCPSessionOutfitScalarFieldEnum[]
  }

  /**
   * MCPSession without action
   */
  export type MCPSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSession
     */
    select?: MCPSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSession
     */
    omit?: MCPSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionInclude<ExtArgs> | null
  }


  /**
   * Model MCPSessionOutfit
   */

  export type AggregateMCPSessionOutfit = {
    _count: MCPSessionOutfitCountAggregateOutputType | null
    _avg: MCPSessionOutfitAvgAggregateOutputType | null
    _sum: MCPSessionOutfitSumAggregateOutputType | null
    _min: MCPSessionOutfitMinAggregateOutputType | null
    _max: MCPSessionOutfitMaxAggregateOutputType | null
  }

  export type MCPSessionOutfitAvgAggregateOutputType = {
    mcp_session_id: number | null
    outfit_id: number | null
  }

  export type MCPSessionOutfitSumAggregateOutputType = {
    mcp_session_id: number | null
    outfit_id: number | null
  }

  export type MCPSessionOutfitMinAggregateOutputType = {
    mcp_session_id: number | null
    outfit_id: number | null
    added_at: Date | null
  }

  export type MCPSessionOutfitMaxAggregateOutputType = {
    mcp_session_id: number | null
    outfit_id: number | null
    added_at: Date | null
  }

  export type MCPSessionOutfitCountAggregateOutputType = {
    mcp_session_id: number
    outfit_id: number
    added_at: number
    _all: number
  }


  export type MCPSessionOutfitAvgAggregateInputType = {
    mcp_session_id?: true
    outfit_id?: true
  }

  export type MCPSessionOutfitSumAggregateInputType = {
    mcp_session_id?: true
    outfit_id?: true
  }

  export type MCPSessionOutfitMinAggregateInputType = {
    mcp_session_id?: true
    outfit_id?: true
    added_at?: true
  }

  export type MCPSessionOutfitMaxAggregateInputType = {
    mcp_session_id?: true
    outfit_id?: true
    added_at?: true
  }

  export type MCPSessionOutfitCountAggregateInputType = {
    mcp_session_id?: true
    outfit_id?: true
    added_at?: true
    _all?: true
  }

  export type MCPSessionOutfitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCPSessionOutfit to aggregate.
     */
    where?: MCPSessionOutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPSessionOutfits to fetch.
     */
    orderBy?: MCPSessionOutfitOrderByWithRelationInput | MCPSessionOutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MCPSessionOutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPSessionOutfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPSessionOutfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MCPSessionOutfits
    **/
    _count?: true | MCPSessionOutfitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MCPSessionOutfitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MCPSessionOutfitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MCPSessionOutfitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MCPSessionOutfitMaxAggregateInputType
  }

  export type GetMCPSessionOutfitAggregateType<T extends MCPSessionOutfitAggregateArgs> = {
        [P in keyof T & keyof AggregateMCPSessionOutfit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMCPSessionOutfit[P]>
      : GetScalarType<T[P], AggregateMCPSessionOutfit[P]>
  }




  export type MCPSessionOutfitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCPSessionOutfitWhereInput
    orderBy?: MCPSessionOutfitOrderByWithAggregationInput | MCPSessionOutfitOrderByWithAggregationInput[]
    by: MCPSessionOutfitScalarFieldEnum[] | MCPSessionOutfitScalarFieldEnum
    having?: MCPSessionOutfitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MCPSessionOutfitCountAggregateInputType | true
    _avg?: MCPSessionOutfitAvgAggregateInputType
    _sum?: MCPSessionOutfitSumAggregateInputType
    _min?: MCPSessionOutfitMinAggregateInputType
    _max?: MCPSessionOutfitMaxAggregateInputType
  }

  export type MCPSessionOutfitGroupByOutputType = {
    mcp_session_id: number
    outfit_id: number
    added_at: Date
    _count: MCPSessionOutfitCountAggregateOutputType | null
    _avg: MCPSessionOutfitAvgAggregateOutputType | null
    _sum: MCPSessionOutfitSumAggregateOutputType | null
    _min: MCPSessionOutfitMinAggregateOutputType | null
    _max: MCPSessionOutfitMaxAggregateOutputType | null
  }

  type GetMCPSessionOutfitGroupByPayload<T extends MCPSessionOutfitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MCPSessionOutfitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MCPSessionOutfitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MCPSessionOutfitGroupByOutputType[P]>
            : GetScalarType<T[P], MCPSessionOutfitGroupByOutputType[P]>
        }
      >
    >


  export type MCPSessionOutfitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mcp_session_id?: boolean
    outfit_id?: boolean
    added_at?: boolean
    mcpSession?: boolean | MCPSessionDefaultArgs<ExtArgs>
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mCPSessionOutfit"]>

  export type MCPSessionOutfitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mcp_session_id?: boolean
    outfit_id?: boolean
    added_at?: boolean
    mcpSession?: boolean | MCPSessionDefaultArgs<ExtArgs>
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mCPSessionOutfit"]>

  export type MCPSessionOutfitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mcp_session_id?: boolean
    outfit_id?: boolean
    added_at?: boolean
    mcpSession?: boolean | MCPSessionDefaultArgs<ExtArgs>
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mCPSessionOutfit"]>

  export type MCPSessionOutfitSelectScalar = {
    mcp_session_id?: boolean
    outfit_id?: boolean
    added_at?: boolean
  }

  export type MCPSessionOutfitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"mcp_session_id" | "outfit_id" | "added_at", ExtArgs["result"]["mCPSessionOutfit"]>
  export type MCPSessionOutfitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mcpSession?: boolean | MCPSessionDefaultArgs<ExtArgs>
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
  }
  export type MCPSessionOutfitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mcpSession?: boolean | MCPSessionDefaultArgs<ExtArgs>
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
  }
  export type MCPSessionOutfitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mcpSession?: boolean | MCPSessionDefaultArgs<ExtArgs>
    outfit?: boolean | OutfitDefaultArgs<ExtArgs>
  }

  export type $MCPSessionOutfitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MCPSessionOutfit"
    objects: {
      mcpSession: Prisma.$MCPSessionPayload<ExtArgs>
      outfit: Prisma.$OutfitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      mcp_session_id: number
      outfit_id: number
      added_at: Date
    }, ExtArgs["result"]["mCPSessionOutfit"]>
    composites: {}
  }

  type MCPSessionOutfitGetPayload<S extends boolean | null | undefined | MCPSessionOutfitDefaultArgs> = $Result.GetResult<Prisma.$MCPSessionOutfitPayload, S>

  type MCPSessionOutfitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MCPSessionOutfitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MCPSessionOutfitCountAggregateInputType | true
    }

  export interface MCPSessionOutfitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MCPSessionOutfit'], meta: { name: 'MCPSessionOutfit' } }
    /**
     * Find zero or one MCPSessionOutfit that matches the filter.
     * @param {MCPSessionOutfitFindUniqueArgs} args - Arguments to find a MCPSessionOutfit
     * @example
     * // Get one MCPSessionOutfit
     * const mCPSessionOutfit = await prisma.mCPSessionOutfit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MCPSessionOutfitFindUniqueArgs>(args: SelectSubset<T, MCPSessionOutfitFindUniqueArgs<ExtArgs>>): Prisma__MCPSessionOutfitClient<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MCPSessionOutfit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MCPSessionOutfitFindUniqueOrThrowArgs} args - Arguments to find a MCPSessionOutfit
     * @example
     * // Get one MCPSessionOutfit
     * const mCPSessionOutfit = await prisma.mCPSessionOutfit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MCPSessionOutfitFindUniqueOrThrowArgs>(args: SelectSubset<T, MCPSessionOutfitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MCPSessionOutfitClient<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MCPSessionOutfit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionOutfitFindFirstArgs} args - Arguments to find a MCPSessionOutfit
     * @example
     * // Get one MCPSessionOutfit
     * const mCPSessionOutfit = await prisma.mCPSessionOutfit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MCPSessionOutfitFindFirstArgs>(args?: SelectSubset<T, MCPSessionOutfitFindFirstArgs<ExtArgs>>): Prisma__MCPSessionOutfitClient<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MCPSessionOutfit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionOutfitFindFirstOrThrowArgs} args - Arguments to find a MCPSessionOutfit
     * @example
     * // Get one MCPSessionOutfit
     * const mCPSessionOutfit = await prisma.mCPSessionOutfit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MCPSessionOutfitFindFirstOrThrowArgs>(args?: SelectSubset<T, MCPSessionOutfitFindFirstOrThrowArgs<ExtArgs>>): Prisma__MCPSessionOutfitClient<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MCPSessionOutfits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionOutfitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MCPSessionOutfits
     * const mCPSessionOutfits = await prisma.mCPSessionOutfit.findMany()
     * 
     * // Get first 10 MCPSessionOutfits
     * const mCPSessionOutfits = await prisma.mCPSessionOutfit.findMany({ take: 10 })
     * 
     * // Only select the `mcp_session_id`
     * const mCPSessionOutfitWithMcp_session_idOnly = await prisma.mCPSessionOutfit.findMany({ select: { mcp_session_id: true } })
     * 
     */
    findMany<T extends MCPSessionOutfitFindManyArgs>(args?: SelectSubset<T, MCPSessionOutfitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MCPSessionOutfit.
     * @param {MCPSessionOutfitCreateArgs} args - Arguments to create a MCPSessionOutfit.
     * @example
     * // Create one MCPSessionOutfit
     * const MCPSessionOutfit = await prisma.mCPSessionOutfit.create({
     *   data: {
     *     // ... data to create a MCPSessionOutfit
     *   }
     * })
     * 
     */
    create<T extends MCPSessionOutfitCreateArgs>(args: SelectSubset<T, MCPSessionOutfitCreateArgs<ExtArgs>>): Prisma__MCPSessionOutfitClient<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MCPSessionOutfits.
     * @param {MCPSessionOutfitCreateManyArgs} args - Arguments to create many MCPSessionOutfits.
     * @example
     * // Create many MCPSessionOutfits
     * const mCPSessionOutfit = await prisma.mCPSessionOutfit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MCPSessionOutfitCreateManyArgs>(args?: SelectSubset<T, MCPSessionOutfitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MCPSessionOutfits and returns the data saved in the database.
     * @param {MCPSessionOutfitCreateManyAndReturnArgs} args - Arguments to create many MCPSessionOutfits.
     * @example
     * // Create many MCPSessionOutfits
     * const mCPSessionOutfit = await prisma.mCPSessionOutfit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MCPSessionOutfits and only return the `mcp_session_id`
     * const mCPSessionOutfitWithMcp_session_idOnly = await prisma.mCPSessionOutfit.createManyAndReturn({
     *   select: { mcp_session_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MCPSessionOutfitCreateManyAndReturnArgs>(args?: SelectSubset<T, MCPSessionOutfitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MCPSessionOutfit.
     * @param {MCPSessionOutfitDeleteArgs} args - Arguments to delete one MCPSessionOutfit.
     * @example
     * // Delete one MCPSessionOutfit
     * const MCPSessionOutfit = await prisma.mCPSessionOutfit.delete({
     *   where: {
     *     // ... filter to delete one MCPSessionOutfit
     *   }
     * })
     * 
     */
    delete<T extends MCPSessionOutfitDeleteArgs>(args: SelectSubset<T, MCPSessionOutfitDeleteArgs<ExtArgs>>): Prisma__MCPSessionOutfitClient<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MCPSessionOutfit.
     * @param {MCPSessionOutfitUpdateArgs} args - Arguments to update one MCPSessionOutfit.
     * @example
     * // Update one MCPSessionOutfit
     * const mCPSessionOutfit = await prisma.mCPSessionOutfit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MCPSessionOutfitUpdateArgs>(args: SelectSubset<T, MCPSessionOutfitUpdateArgs<ExtArgs>>): Prisma__MCPSessionOutfitClient<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MCPSessionOutfits.
     * @param {MCPSessionOutfitDeleteManyArgs} args - Arguments to filter MCPSessionOutfits to delete.
     * @example
     * // Delete a few MCPSessionOutfits
     * const { count } = await prisma.mCPSessionOutfit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MCPSessionOutfitDeleteManyArgs>(args?: SelectSubset<T, MCPSessionOutfitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCPSessionOutfits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionOutfitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MCPSessionOutfits
     * const mCPSessionOutfit = await prisma.mCPSessionOutfit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MCPSessionOutfitUpdateManyArgs>(args: SelectSubset<T, MCPSessionOutfitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCPSessionOutfits and returns the data updated in the database.
     * @param {MCPSessionOutfitUpdateManyAndReturnArgs} args - Arguments to update many MCPSessionOutfits.
     * @example
     * // Update many MCPSessionOutfits
     * const mCPSessionOutfit = await prisma.mCPSessionOutfit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MCPSessionOutfits and only return the `mcp_session_id`
     * const mCPSessionOutfitWithMcp_session_idOnly = await prisma.mCPSessionOutfit.updateManyAndReturn({
     *   select: { mcp_session_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MCPSessionOutfitUpdateManyAndReturnArgs>(args: SelectSubset<T, MCPSessionOutfitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MCPSessionOutfit.
     * @param {MCPSessionOutfitUpsertArgs} args - Arguments to update or create a MCPSessionOutfit.
     * @example
     * // Update or create a MCPSessionOutfit
     * const mCPSessionOutfit = await prisma.mCPSessionOutfit.upsert({
     *   create: {
     *     // ... data to create a MCPSessionOutfit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MCPSessionOutfit we want to update
     *   }
     * })
     */
    upsert<T extends MCPSessionOutfitUpsertArgs>(args: SelectSubset<T, MCPSessionOutfitUpsertArgs<ExtArgs>>): Prisma__MCPSessionOutfitClient<$Result.GetResult<Prisma.$MCPSessionOutfitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MCPSessionOutfits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionOutfitCountArgs} args - Arguments to filter MCPSessionOutfits to count.
     * @example
     * // Count the number of MCPSessionOutfits
     * const count = await prisma.mCPSessionOutfit.count({
     *   where: {
     *     // ... the filter for the MCPSessionOutfits we want to count
     *   }
     * })
    **/
    count<T extends MCPSessionOutfitCountArgs>(
      args?: Subset<T, MCPSessionOutfitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MCPSessionOutfitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MCPSessionOutfit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionOutfitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MCPSessionOutfitAggregateArgs>(args: Subset<T, MCPSessionOutfitAggregateArgs>): Prisma.PrismaPromise<GetMCPSessionOutfitAggregateType<T>>

    /**
     * Group by MCPSessionOutfit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPSessionOutfitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MCPSessionOutfitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MCPSessionOutfitGroupByArgs['orderBy'] }
        : { orderBy?: MCPSessionOutfitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MCPSessionOutfitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMCPSessionOutfitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MCPSessionOutfit model
   */
  readonly fields: MCPSessionOutfitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MCPSessionOutfit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MCPSessionOutfitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mcpSession<T extends MCPSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MCPSessionDefaultArgs<ExtArgs>>): Prisma__MCPSessionClient<$Result.GetResult<Prisma.$MCPSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outfit<T extends OutfitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutfitDefaultArgs<ExtArgs>>): Prisma__OutfitClient<$Result.GetResult<Prisma.$OutfitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MCPSessionOutfit model
   */
  interface MCPSessionOutfitFieldRefs {
    readonly mcp_session_id: FieldRef<"MCPSessionOutfit", 'Int'>
    readonly outfit_id: FieldRef<"MCPSessionOutfit", 'Int'>
    readonly added_at: FieldRef<"MCPSessionOutfit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MCPSessionOutfit findUnique
   */
  export type MCPSessionOutfitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    /**
     * Filter, which MCPSessionOutfit to fetch.
     */
    where: MCPSessionOutfitWhereUniqueInput
  }

  /**
   * MCPSessionOutfit findUniqueOrThrow
   */
  export type MCPSessionOutfitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    /**
     * Filter, which MCPSessionOutfit to fetch.
     */
    where: MCPSessionOutfitWhereUniqueInput
  }

  /**
   * MCPSessionOutfit findFirst
   */
  export type MCPSessionOutfitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    /**
     * Filter, which MCPSessionOutfit to fetch.
     */
    where?: MCPSessionOutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPSessionOutfits to fetch.
     */
    orderBy?: MCPSessionOutfitOrderByWithRelationInput | MCPSessionOutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCPSessionOutfits.
     */
    cursor?: MCPSessionOutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPSessionOutfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPSessionOutfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCPSessionOutfits.
     */
    distinct?: MCPSessionOutfitScalarFieldEnum | MCPSessionOutfitScalarFieldEnum[]
  }

  /**
   * MCPSessionOutfit findFirstOrThrow
   */
  export type MCPSessionOutfitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    /**
     * Filter, which MCPSessionOutfit to fetch.
     */
    where?: MCPSessionOutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPSessionOutfits to fetch.
     */
    orderBy?: MCPSessionOutfitOrderByWithRelationInput | MCPSessionOutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCPSessionOutfits.
     */
    cursor?: MCPSessionOutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPSessionOutfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPSessionOutfits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCPSessionOutfits.
     */
    distinct?: MCPSessionOutfitScalarFieldEnum | MCPSessionOutfitScalarFieldEnum[]
  }

  /**
   * MCPSessionOutfit findMany
   */
  export type MCPSessionOutfitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    /**
     * Filter, which MCPSessionOutfits to fetch.
     */
    where?: MCPSessionOutfitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPSessionOutfits to fetch.
     */
    orderBy?: MCPSessionOutfitOrderByWithRelationInput | MCPSessionOutfitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MCPSessionOutfits.
     */
    cursor?: MCPSessionOutfitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPSessionOutfits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPSessionOutfits.
     */
    skip?: number
    distinct?: MCPSessionOutfitScalarFieldEnum | MCPSessionOutfitScalarFieldEnum[]
  }

  /**
   * MCPSessionOutfit create
   */
  export type MCPSessionOutfitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    /**
     * The data needed to create a MCPSessionOutfit.
     */
    data: XOR<MCPSessionOutfitCreateInput, MCPSessionOutfitUncheckedCreateInput>
  }

  /**
   * MCPSessionOutfit createMany
   */
  export type MCPSessionOutfitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MCPSessionOutfits.
     */
    data: MCPSessionOutfitCreateManyInput | MCPSessionOutfitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MCPSessionOutfit createManyAndReturn
   */
  export type MCPSessionOutfitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * The data used to create many MCPSessionOutfits.
     */
    data: MCPSessionOutfitCreateManyInput | MCPSessionOutfitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MCPSessionOutfit update
   */
  export type MCPSessionOutfitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    /**
     * The data needed to update a MCPSessionOutfit.
     */
    data: XOR<MCPSessionOutfitUpdateInput, MCPSessionOutfitUncheckedUpdateInput>
    /**
     * Choose, which MCPSessionOutfit to update.
     */
    where: MCPSessionOutfitWhereUniqueInput
  }

  /**
   * MCPSessionOutfit updateMany
   */
  export type MCPSessionOutfitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MCPSessionOutfits.
     */
    data: XOR<MCPSessionOutfitUpdateManyMutationInput, MCPSessionOutfitUncheckedUpdateManyInput>
    /**
     * Filter which MCPSessionOutfits to update
     */
    where?: MCPSessionOutfitWhereInput
    /**
     * Limit how many MCPSessionOutfits to update.
     */
    limit?: number
  }

  /**
   * MCPSessionOutfit updateManyAndReturn
   */
  export type MCPSessionOutfitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * The data used to update MCPSessionOutfits.
     */
    data: XOR<MCPSessionOutfitUpdateManyMutationInput, MCPSessionOutfitUncheckedUpdateManyInput>
    /**
     * Filter which MCPSessionOutfits to update
     */
    where?: MCPSessionOutfitWhereInput
    /**
     * Limit how many MCPSessionOutfits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MCPSessionOutfit upsert
   */
  export type MCPSessionOutfitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    /**
     * The filter to search for the MCPSessionOutfit to update in case it exists.
     */
    where: MCPSessionOutfitWhereUniqueInput
    /**
     * In case the MCPSessionOutfit found by the `where` argument doesn't exist, create a new MCPSessionOutfit with this data.
     */
    create: XOR<MCPSessionOutfitCreateInput, MCPSessionOutfitUncheckedCreateInput>
    /**
     * In case the MCPSessionOutfit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MCPSessionOutfitUpdateInput, MCPSessionOutfitUncheckedUpdateInput>
  }

  /**
   * MCPSessionOutfit delete
   */
  export type MCPSessionOutfitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
    /**
     * Filter which MCPSessionOutfit to delete.
     */
    where: MCPSessionOutfitWhereUniqueInput
  }

  /**
   * MCPSessionOutfit deleteMany
   */
  export type MCPSessionOutfitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCPSessionOutfits to delete
     */
    where?: MCPSessionOutfitWhereInput
    /**
     * Limit how many MCPSessionOutfits to delete.
     */
    limit?: number
  }

  /**
   * MCPSessionOutfit without action
   */
  export type MCPSessionOutfitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPSessionOutfit
     */
    select?: MCPSessionOutfitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPSessionOutfit
     */
    omit?: MCPSessionOutfitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MCPSessionOutfitInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password_hash: 'password_hash',
    google_id: 'google_id',
    coin_balance: 'coin_balance',
    security_question: 'security_question',
    security_answer_hash: 'security_answer_hash',
    created_at: 'created_at',
    updated_at: 'updated_at',
    role: 'role',
    avatar_url: 'avatar_url',
    avatar_key: 'avatar_key'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    created_at: 'created_at'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ClosetScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClosetScalarFieldEnum = (typeof ClosetScalarFieldEnum)[keyof typeof ClosetScalarFieldEnum]


  export const S3BucketScalarFieldEnum: {
    name: 'name',
    region: 'region',
    created_at: 'created_at'
  };

  export type S3BucketScalarFieldEnum = (typeof S3BucketScalarFieldEnum)[keyof typeof S3BucketScalarFieldEnum]


  export const ClothingItemScalarFieldEnum: {
    id: 'id',
    closet_id: 'closet_id',
    category_id: 'category_id',
    bucket_name: 'bucket_name',
    image_key: 'image_key',
    label: 'label',
    description: 'description',
    wear_count: 'wear_count',
    last_worn_at: 'last_worn_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    status: 'status'
  };

  export type ClothingItemScalarFieldEnum = (typeof ClothingItemScalarFieldEnum)[keyof typeof ClothingItemScalarFieldEnum]


  export const OutfitScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    bucket_name: 'bucket_name',
    image_key: 'image_key',
    title: 'title',
    is_favorite: 'is_favorite',
    is_recurring: 'is_recurring',
    wear_count: 'wear_count',
    last_worn_at: 'last_worn_at',
    mcp_session_id: 'mcp_session_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OutfitScalarFieldEnum = (typeof OutfitScalarFieldEnum)[keyof typeof OutfitScalarFieldEnum]


  export const OutfitClothingItemScalarFieldEnum: {
    outfit_id: 'outfit_id',
    clothing_item_id: 'clothing_item_id',
    added_at: 'added_at'
  };

  export type OutfitClothingItemScalarFieldEnum = (typeof OutfitClothingItemScalarFieldEnum)[keyof typeof OutfitClothingItemScalarFieldEnum]


  export const ChatSessionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    started_at: 'started_at'
  };

  export type ChatSessionScalarFieldEnum = (typeof ChatSessionScalarFieldEnum)[keyof typeof ChatSessionScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    session_id: 'session_id',
    role: 'role',
    content: 'content',
    sent_at: 'sent_at'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const MCPSessionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    prompt_payload: 'prompt_payload',
    status: 'status',
    created_at: 'created_at',
    completed_at: 'completed_at'
  };

  export type MCPSessionScalarFieldEnum = (typeof MCPSessionScalarFieldEnum)[keyof typeof MCPSessionScalarFieldEnum]


  export const MCPSessionOutfitScalarFieldEnum: {
    mcp_session_id: 'mcp_session_id',
    outfit_id: 'outfit_id',
    added_at: 'added_at'
  };

  export type MCPSessionOutfitScalarFieldEnum = (typeof MCPSessionOutfitScalarFieldEnum)[keyof typeof MCPSessionOutfitScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    google_id?: StringNullableFilter<"User"> | string | null
    coin_balance?: IntFilter<"User"> | number
    security_question?: StringFilter<"User"> | string
    security_answer_hash?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    avatar_url?: StringNullableFilter<"User"> | string | null
    avatar_key?: StringNullableFilter<"User"> | string | null
    closets?: ClosetListRelationFilter
    categories?: CategoryListRelationFilter
    outfits?: OutfitListRelationFilter
    chatSessions?: ChatSessionListRelationFilter
    mcpSessions?: MCPSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    google_id?: SortOrderInput | SortOrder
    coin_balance?: SortOrder
    security_question?: SortOrder
    security_answer_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    avatar_key?: SortOrderInput | SortOrder
    closets?: ClosetOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    outfits?: OutfitOrderByRelationAggregateInput
    chatSessions?: ChatSessionOrderByRelationAggregateInput
    mcpSessions?: MCPSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    google_id?: StringNullableFilter<"User"> | string | null
    coin_balance?: IntFilter<"User"> | number
    security_question?: StringFilter<"User"> | string
    security_answer_hash?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    avatar_url?: StringNullableFilter<"User"> | string | null
    avatar_key?: StringNullableFilter<"User"> | string | null
    closets?: ClosetListRelationFilter
    categories?: CategoryListRelationFilter
    outfits?: OutfitListRelationFilter
    chatSessions?: ChatSessionListRelationFilter
    mcpSessions?: MCPSessionListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    google_id?: SortOrderInput | SortOrder
    coin_balance?: SortOrder
    security_question?: SortOrder
    security_answer_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    avatar_key?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    google_id?: StringNullableWithAggregatesFilter<"User"> | string | null
    coin_balance?: IntWithAggregatesFilter<"User"> | number
    security_question?: StringWithAggregatesFilter<"User"> | string
    security_answer_hash?: StringWithAggregatesFilter<"User"> | string
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: StringWithAggregatesFilter<"User"> | string
    avatar_url?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar_key?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    user_id?: IntFilter<"Category"> | number
    title?: StringFilter<"Category"> | string
    created_at?: DateTimeFilter<"Category"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    clothingItems?: ClothingItemListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    clothingItems?: ClothingItemOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_title?: CategoryUser_idTitleCompoundUniqueInput
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    user_id?: IntFilter<"Category"> | number
    title?: StringFilter<"Category"> | string
    created_at?: DateTimeFilter<"Category"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    clothingItems?: ClothingItemListRelationFilter
  }, "id" | "user_id_title">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    user_id?: IntWithAggregatesFilter<"Category"> | number
    title?: StringWithAggregatesFilter<"Category"> | string
    created_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type ClosetWhereInput = {
    AND?: ClosetWhereInput | ClosetWhereInput[]
    OR?: ClosetWhereInput[]
    NOT?: ClosetWhereInput | ClosetWhereInput[]
    id?: IntFilter<"Closet"> | number
    user_id?: IntFilter<"Closet"> | number
    name?: StringFilter<"Closet"> | string
    created_at?: DateTimeFilter<"Closet"> | Date | string
    updated_at?: DateTimeFilter<"Closet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    clothingItems?: ClothingItemListRelationFilter
  }

  export type ClosetOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    clothingItems?: ClothingItemOrderByRelationAggregateInput
  }

  export type ClosetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClosetWhereInput | ClosetWhereInput[]
    OR?: ClosetWhereInput[]
    NOT?: ClosetWhereInput | ClosetWhereInput[]
    user_id?: IntFilter<"Closet"> | number
    name?: StringFilter<"Closet"> | string
    created_at?: DateTimeFilter<"Closet"> | Date | string
    updated_at?: DateTimeFilter<"Closet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    clothingItems?: ClothingItemListRelationFilter
  }, "id">

  export type ClosetOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ClosetCountOrderByAggregateInput
    _avg?: ClosetAvgOrderByAggregateInput
    _max?: ClosetMaxOrderByAggregateInput
    _min?: ClosetMinOrderByAggregateInput
    _sum?: ClosetSumOrderByAggregateInput
  }

  export type ClosetScalarWhereWithAggregatesInput = {
    AND?: ClosetScalarWhereWithAggregatesInput | ClosetScalarWhereWithAggregatesInput[]
    OR?: ClosetScalarWhereWithAggregatesInput[]
    NOT?: ClosetScalarWhereWithAggregatesInput | ClosetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Closet"> | number
    user_id?: IntWithAggregatesFilter<"Closet"> | number
    name?: StringWithAggregatesFilter<"Closet"> | string
    created_at?: DateTimeWithAggregatesFilter<"Closet"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Closet"> | Date | string
  }

  export type S3BucketWhereInput = {
    AND?: S3BucketWhereInput | S3BucketWhereInput[]
    OR?: S3BucketWhereInput[]
    NOT?: S3BucketWhereInput | S3BucketWhereInput[]
    name?: StringFilter<"S3Bucket"> | string
    region?: StringFilter<"S3Bucket"> | string
    created_at?: DateTimeFilter<"S3Bucket"> | Date | string
    clothingItems?: ClothingItemListRelationFilter
    outfits?: OutfitListRelationFilter
  }

  export type S3BucketOrderByWithRelationInput = {
    name?: SortOrder
    region?: SortOrder
    created_at?: SortOrder
    clothingItems?: ClothingItemOrderByRelationAggregateInput
    outfits?: OutfitOrderByRelationAggregateInput
  }

  export type S3BucketWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: S3BucketWhereInput | S3BucketWhereInput[]
    OR?: S3BucketWhereInput[]
    NOT?: S3BucketWhereInput | S3BucketWhereInput[]
    region?: StringFilter<"S3Bucket"> | string
    created_at?: DateTimeFilter<"S3Bucket"> | Date | string
    clothingItems?: ClothingItemListRelationFilter
    outfits?: OutfitListRelationFilter
  }, "name">

  export type S3BucketOrderByWithAggregationInput = {
    name?: SortOrder
    region?: SortOrder
    created_at?: SortOrder
    _count?: S3BucketCountOrderByAggregateInput
    _max?: S3BucketMaxOrderByAggregateInput
    _min?: S3BucketMinOrderByAggregateInput
  }

  export type S3BucketScalarWhereWithAggregatesInput = {
    AND?: S3BucketScalarWhereWithAggregatesInput | S3BucketScalarWhereWithAggregatesInput[]
    OR?: S3BucketScalarWhereWithAggregatesInput[]
    NOT?: S3BucketScalarWhereWithAggregatesInput | S3BucketScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"S3Bucket"> | string
    region?: StringWithAggregatesFilter<"S3Bucket"> | string
    created_at?: DateTimeWithAggregatesFilter<"S3Bucket"> | Date | string
  }

  export type ClothingItemWhereInput = {
    AND?: ClothingItemWhereInput | ClothingItemWhereInput[]
    OR?: ClothingItemWhereInput[]
    NOT?: ClothingItemWhereInput | ClothingItemWhereInput[]
    id?: IntFilter<"ClothingItem"> | number
    closet_id?: IntFilter<"ClothingItem"> | number
    category_id?: IntFilter<"ClothingItem"> | number
    bucket_name?: StringFilter<"ClothingItem"> | string
    image_key?: StringFilter<"ClothingItem"> | string
    label?: StringFilter<"ClothingItem"> | string
    description?: StringFilter<"ClothingItem"> | string
    wear_count?: IntFilter<"ClothingItem"> | number
    last_worn_at?: DateTimeNullableFilter<"ClothingItem"> | Date | string | null
    created_at?: DateTimeFilter<"ClothingItem"> | Date | string
    updated_at?: DateTimeFilter<"ClothingItem"> | Date | string
    status?: StringFilter<"ClothingItem"> | string
    closet?: XOR<ClosetScalarRelationFilter, ClosetWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    bucket?: XOR<S3BucketScalarRelationFilter, S3BucketWhereInput>
    outfitClothingItems?: OutfitClothingItemListRelationFilter
  }

  export type ClothingItemOrderByWithRelationInput = {
    id?: SortOrder
    closet_id?: SortOrder
    category_id?: SortOrder
    bucket_name?: SortOrder
    image_key?: SortOrder
    label?: SortOrder
    description?: SortOrder
    wear_count?: SortOrder
    last_worn_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    closet?: ClosetOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    bucket?: S3BucketOrderByWithRelationInput
    outfitClothingItems?: OutfitClothingItemOrderByRelationAggregateInput
  }

  export type ClothingItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClothingItemWhereInput | ClothingItemWhereInput[]
    OR?: ClothingItemWhereInput[]
    NOT?: ClothingItemWhereInput | ClothingItemWhereInput[]
    closet_id?: IntFilter<"ClothingItem"> | number
    category_id?: IntFilter<"ClothingItem"> | number
    bucket_name?: StringFilter<"ClothingItem"> | string
    image_key?: StringFilter<"ClothingItem"> | string
    label?: StringFilter<"ClothingItem"> | string
    description?: StringFilter<"ClothingItem"> | string
    wear_count?: IntFilter<"ClothingItem"> | number
    last_worn_at?: DateTimeNullableFilter<"ClothingItem"> | Date | string | null
    created_at?: DateTimeFilter<"ClothingItem"> | Date | string
    updated_at?: DateTimeFilter<"ClothingItem"> | Date | string
    status?: StringFilter<"ClothingItem"> | string
    closet?: XOR<ClosetScalarRelationFilter, ClosetWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    bucket?: XOR<S3BucketScalarRelationFilter, S3BucketWhereInput>
    outfitClothingItems?: OutfitClothingItemListRelationFilter
  }, "id">

  export type ClothingItemOrderByWithAggregationInput = {
    id?: SortOrder
    closet_id?: SortOrder
    category_id?: SortOrder
    bucket_name?: SortOrder
    image_key?: SortOrder
    label?: SortOrder
    description?: SortOrder
    wear_count?: SortOrder
    last_worn_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    _count?: ClothingItemCountOrderByAggregateInput
    _avg?: ClothingItemAvgOrderByAggregateInput
    _max?: ClothingItemMaxOrderByAggregateInput
    _min?: ClothingItemMinOrderByAggregateInput
    _sum?: ClothingItemSumOrderByAggregateInput
  }

  export type ClothingItemScalarWhereWithAggregatesInput = {
    AND?: ClothingItemScalarWhereWithAggregatesInput | ClothingItemScalarWhereWithAggregatesInput[]
    OR?: ClothingItemScalarWhereWithAggregatesInput[]
    NOT?: ClothingItemScalarWhereWithAggregatesInput | ClothingItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClothingItem"> | number
    closet_id?: IntWithAggregatesFilter<"ClothingItem"> | number
    category_id?: IntWithAggregatesFilter<"ClothingItem"> | number
    bucket_name?: StringWithAggregatesFilter<"ClothingItem"> | string
    image_key?: StringWithAggregatesFilter<"ClothingItem"> | string
    label?: StringWithAggregatesFilter<"ClothingItem"> | string
    description?: StringWithAggregatesFilter<"ClothingItem"> | string
    wear_count?: IntWithAggregatesFilter<"ClothingItem"> | number
    last_worn_at?: DateTimeNullableWithAggregatesFilter<"ClothingItem"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"ClothingItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ClothingItem"> | Date | string
    status?: StringWithAggregatesFilter<"ClothingItem"> | string
  }

  export type OutfitWhereInput = {
    AND?: OutfitWhereInput | OutfitWhereInput[]
    OR?: OutfitWhereInput[]
    NOT?: OutfitWhereInput | OutfitWhereInput[]
    id?: IntFilter<"Outfit"> | number
    user_id?: IntFilter<"Outfit"> | number
    bucket_name?: StringNullableFilter<"Outfit"> | string | null
    image_key?: StringNullableFilter<"Outfit"> | string | null
    title?: StringFilter<"Outfit"> | string
    is_favorite?: BoolFilter<"Outfit"> | boolean
    is_recurring?: BoolFilter<"Outfit"> | boolean
    wear_count?: IntFilter<"Outfit"> | number
    last_worn_at?: DateTimeNullableFilter<"Outfit"> | Date | string | null
    mcp_session_id?: IntNullableFilter<"Outfit"> | number | null
    created_at?: DateTimeFilter<"Outfit"> | Date | string
    updated_at?: DateTimeFilter<"Outfit"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bucket?: XOR<S3BucketNullableScalarRelationFilter, S3BucketWhereInput> | null
    mcpSession?: XOR<MCPSessionNullableScalarRelationFilter, MCPSessionWhereInput> | null
    outfitClothingItems?: OutfitClothingItemListRelationFilter
    mcpSessionOutfits?: MCPSessionOutfitListRelationFilter
  }

  export type OutfitOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    bucket_name?: SortOrderInput | SortOrder
    image_key?: SortOrderInput | SortOrder
    title?: SortOrder
    is_favorite?: SortOrder
    is_recurring?: SortOrder
    wear_count?: SortOrder
    last_worn_at?: SortOrderInput | SortOrder
    mcp_session_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    bucket?: S3BucketOrderByWithRelationInput
    mcpSession?: MCPSessionOrderByWithRelationInput
    outfitClothingItems?: OutfitClothingItemOrderByRelationAggregateInput
    mcpSessionOutfits?: MCPSessionOutfitOrderByRelationAggregateInput
  }

  export type OutfitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OutfitWhereInput | OutfitWhereInput[]
    OR?: OutfitWhereInput[]
    NOT?: OutfitWhereInput | OutfitWhereInput[]
    user_id?: IntFilter<"Outfit"> | number
    bucket_name?: StringNullableFilter<"Outfit"> | string | null
    image_key?: StringNullableFilter<"Outfit"> | string | null
    title?: StringFilter<"Outfit"> | string
    is_favorite?: BoolFilter<"Outfit"> | boolean
    is_recurring?: BoolFilter<"Outfit"> | boolean
    wear_count?: IntFilter<"Outfit"> | number
    last_worn_at?: DateTimeNullableFilter<"Outfit"> | Date | string | null
    mcp_session_id?: IntNullableFilter<"Outfit"> | number | null
    created_at?: DateTimeFilter<"Outfit"> | Date | string
    updated_at?: DateTimeFilter<"Outfit"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bucket?: XOR<S3BucketNullableScalarRelationFilter, S3BucketWhereInput> | null
    mcpSession?: XOR<MCPSessionNullableScalarRelationFilter, MCPSessionWhereInput> | null
    outfitClothingItems?: OutfitClothingItemListRelationFilter
    mcpSessionOutfits?: MCPSessionOutfitListRelationFilter
  }, "id">

  export type OutfitOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    bucket_name?: SortOrderInput | SortOrder
    image_key?: SortOrderInput | SortOrder
    title?: SortOrder
    is_favorite?: SortOrder
    is_recurring?: SortOrder
    wear_count?: SortOrder
    last_worn_at?: SortOrderInput | SortOrder
    mcp_session_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: OutfitCountOrderByAggregateInput
    _avg?: OutfitAvgOrderByAggregateInput
    _max?: OutfitMaxOrderByAggregateInput
    _min?: OutfitMinOrderByAggregateInput
    _sum?: OutfitSumOrderByAggregateInput
  }

  export type OutfitScalarWhereWithAggregatesInput = {
    AND?: OutfitScalarWhereWithAggregatesInput | OutfitScalarWhereWithAggregatesInput[]
    OR?: OutfitScalarWhereWithAggregatesInput[]
    NOT?: OutfitScalarWhereWithAggregatesInput | OutfitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Outfit"> | number
    user_id?: IntWithAggregatesFilter<"Outfit"> | number
    bucket_name?: StringNullableWithAggregatesFilter<"Outfit"> | string | null
    image_key?: StringNullableWithAggregatesFilter<"Outfit"> | string | null
    title?: StringWithAggregatesFilter<"Outfit"> | string
    is_favorite?: BoolWithAggregatesFilter<"Outfit"> | boolean
    is_recurring?: BoolWithAggregatesFilter<"Outfit"> | boolean
    wear_count?: IntWithAggregatesFilter<"Outfit"> | number
    last_worn_at?: DateTimeNullableWithAggregatesFilter<"Outfit"> | Date | string | null
    mcp_session_id?: IntNullableWithAggregatesFilter<"Outfit"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Outfit"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Outfit"> | Date | string
  }

  export type OutfitClothingItemWhereInput = {
    AND?: OutfitClothingItemWhereInput | OutfitClothingItemWhereInput[]
    OR?: OutfitClothingItemWhereInput[]
    NOT?: OutfitClothingItemWhereInput | OutfitClothingItemWhereInput[]
    outfit_id?: IntFilter<"OutfitClothingItem"> | number
    clothing_item_id?: IntFilter<"OutfitClothingItem"> | number
    added_at?: DateTimeFilter<"OutfitClothingItem"> | Date | string
    outfit?: XOR<OutfitScalarRelationFilter, OutfitWhereInput>
    clothingItem?: XOR<ClothingItemScalarRelationFilter, ClothingItemWhereInput>
  }

  export type OutfitClothingItemOrderByWithRelationInput = {
    outfit_id?: SortOrder
    clothing_item_id?: SortOrder
    added_at?: SortOrder
    outfit?: OutfitOrderByWithRelationInput
    clothingItem?: ClothingItemOrderByWithRelationInput
  }

  export type OutfitClothingItemWhereUniqueInput = Prisma.AtLeast<{
    outfit_id_clothing_item_id?: OutfitClothingItemOutfit_idClothing_item_idCompoundUniqueInput
    AND?: OutfitClothingItemWhereInput | OutfitClothingItemWhereInput[]
    OR?: OutfitClothingItemWhereInput[]
    NOT?: OutfitClothingItemWhereInput | OutfitClothingItemWhereInput[]
    outfit_id?: IntFilter<"OutfitClothingItem"> | number
    clothing_item_id?: IntFilter<"OutfitClothingItem"> | number
    added_at?: DateTimeFilter<"OutfitClothingItem"> | Date | string
    outfit?: XOR<OutfitScalarRelationFilter, OutfitWhereInput>
    clothingItem?: XOR<ClothingItemScalarRelationFilter, ClothingItemWhereInput>
  }, "outfit_id_clothing_item_id">

  export type OutfitClothingItemOrderByWithAggregationInput = {
    outfit_id?: SortOrder
    clothing_item_id?: SortOrder
    added_at?: SortOrder
    _count?: OutfitClothingItemCountOrderByAggregateInput
    _avg?: OutfitClothingItemAvgOrderByAggregateInput
    _max?: OutfitClothingItemMaxOrderByAggregateInput
    _min?: OutfitClothingItemMinOrderByAggregateInput
    _sum?: OutfitClothingItemSumOrderByAggregateInput
  }

  export type OutfitClothingItemScalarWhereWithAggregatesInput = {
    AND?: OutfitClothingItemScalarWhereWithAggregatesInput | OutfitClothingItemScalarWhereWithAggregatesInput[]
    OR?: OutfitClothingItemScalarWhereWithAggregatesInput[]
    NOT?: OutfitClothingItemScalarWhereWithAggregatesInput | OutfitClothingItemScalarWhereWithAggregatesInput[]
    outfit_id?: IntWithAggregatesFilter<"OutfitClothingItem"> | number
    clothing_item_id?: IntWithAggregatesFilter<"OutfitClothingItem"> | number
    added_at?: DateTimeWithAggregatesFilter<"OutfitClothingItem"> | Date | string
  }

  export type ChatSessionWhereInput = {
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    id?: IntFilter<"ChatSession"> | number
    user_id?: IntFilter<"ChatSession"> | number
    started_at?: DateTimeFilter<"ChatSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: ChatMessageListRelationFilter
  }

  export type ChatSessionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    started_at?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type ChatSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    user_id?: IntFilter<"ChatSession"> | number
    started_at?: DateTimeFilter<"ChatSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type ChatSessionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    started_at?: SortOrder
    _count?: ChatSessionCountOrderByAggregateInput
    _avg?: ChatSessionAvgOrderByAggregateInput
    _max?: ChatSessionMaxOrderByAggregateInput
    _min?: ChatSessionMinOrderByAggregateInput
    _sum?: ChatSessionSumOrderByAggregateInput
  }

  export type ChatSessionScalarWhereWithAggregatesInput = {
    AND?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    OR?: ChatSessionScalarWhereWithAggregatesInput[]
    NOT?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatSession"> | number
    user_id?: IntWithAggregatesFilter<"ChatSession"> | number
    started_at?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    session_id?: IntFilter<"ChatMessage"> | number
    role?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    sent_at?: DateTimeFilter<"ChatMessage"> | Date | string
    session?: XOR<ChatSessionScalarRelationFilter, ChatSessionWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    session_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    sent_at?: SortOrder
    session?: ChatSessionOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    session_id?: IntFilter<"ChatMessage"> | number
    role?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    sent_at?: DateTimeFilter<"ChatMessage"> | Date | string
    session?: XOR<ChatSessionScalarRelationFilter, ChatSessionWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    session_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    sent_at?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _avg?: ChatMessageAvgOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
    _sum?: ChatMessageSumOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatMessage"> | number
    session_id?: IntWithAggregatesFilter<"ChatMessage"> | number
    role?: StringWithAggregatesFilter<"ChatMessage"> | string
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    sent_at?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type MCPSessionWhereInput = {
    AND?: MCPSessionWhereInput | MCPSessionWhereInput[]
    OR?: MCPSessionWhereInput[]
    NOT?: MCPSessionWhereInput | MCPSessionWhereInput[]
    id?: IntFilter<"MCPSession"> | number
    user_id?: IntFilter<"MCPSession"> | number
    prompt_payload?: JsonFilter<"MCPSession">
    status?: StringFilter<"MCPSession"> | string
    created_at?: DateTimeFilter<"MCPSession"> | Date | string
    completed_at?: DateTimeNullableFilter<"MCPSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    outfits?: OutfitListRelationFilter
    mcpSessionOutfits?: MCPSessionOutfitListRelationFilter
  }

  export type MCPSessionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    prompt_payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    outfits?: OutfitOrderByRelationAggregateInput
    mcpSessionOutfits?: MCPSessionOutfitOrderByRelationAggregateInput
  }

  export type MCPSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MCPSessionWhereInput | MCPSessionWhereInput[]
    OR?: MCPSessionWhereInput[]
    NOT?: MCPSessionWhereInput | MCPSessionWhereInput[]
    user_id?: IntFilter<"MCPSession"> | number
    prompt_payload?: JsonFilter<"MCPSession">
    status?: StringFilter<"MCPSession"> | string
    created_at?: DateTimeFilter<"MCPSession"> | Date | string
    completed_at?: DateTimeNullableFilter<"MCPSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    outfits?: OutfitListRelationFilter
    mcpSessionOutfits?: MCPSessionOutfitListRelationFilter
  }, "id">

  export type MCPSessionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    prompt_payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    _count?: MCPSessionCountOrderByAggregateInput
    _avg?: MCPSessionAvgOrderByAggregateInput
    _max?: MCPSessionMaxOrderByAggregateInput
    _min?: MCPSessionMinOrderByAggregateInput
    _sum?: MCPSessionSumOrderByAggregateInput
  }

  export type MCPSessionScalarWhereWithAggregatesInput = {
    AND?: MCPSessionScalarWhereWithAggregatesInput | MCPSessionScalarWhereWithAggregatesInput[]
    OR?: MCPSessionScalarWhereWithAggregatesInput[]
    NOT?: MCPSessionScalarWhereWithAggregatesInput | MCPSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MCPSession"> | number
    user_id?: IntWithAggregatesFilter<"MCPSession"> | number
    prompt_payload?: JsonWithAggregatesFilter<"MCPSession">
    status?: StringWithAggregatesFilter<"MCPSession"> | string
    created_at?: DateTimeWithAggregatesFilter<"MCPSession"> | Date | string
    completed_at?: DateTimeNullableWithAggregatesFilter<"MCPSession"> | Date | string | null
  }

  export type MCPSessionOutfitWhereInput = {
    AND?: MCPSessionOutfitWhereInput | MCPSessionOutfitWhereInput[]
    OR?: MCPSessionOutfitWhereInput[]
    NOT?: MCPSessionOutfitWhereInput | MCPSessionOutfitWhereInput[]
    mcp_session_id?: IntFilter<"MCPSessionOutfit"> | number
    outfit_id?: IntFilter<"MCPSessionOutfit"> | number
    added_at?: DateTimeFilter<"MCPSessionOutfit"> | Date | string
    mcpSession?: XOR<MCPSessionScalarRelationFilter, MCPSessionWhereInput>
    outfit?: XOR<OutfitScalarRelationFilter, OutfitWhereInput>
  }

  export type MCPSessionOutfitOrderByWithRelationInput = {
    mcp_session_id?: SortOrder
    outfit_id?: SortOrder
    added_at?: SortOrder
    mcpSession?: MCPSessionOrderByWithRelationInput
    outfit?: OutfitOrderByWithRelationInput
  }

  export type MCPSessionOutfitWhereUniqueInput = Prisma.AtLeast<{
    mcp_session_id_outfit_id?: MCPSessionOutfitMcp_session_idOutfit_idCompoundUniqueInput
    AND?: MCPSessionOutfitWhereInput | MCPSessionOutfitWhereInput[]
    OR?: MCPSessionOutfitWhereInput[]
    NOT?: MCPSessionOutfitWhereInput | MCPSessionOutfitWhereInput[]
    mcp_session_id?: IntFilter<"MCPSessionOutfit"> | number
    outfit_id?: IntFilter<"MCPSessionOutfit"> | number
    added_at?: DateTimeFilter<"MCPSessionOutfit"> | Date | string
    mcpSession?: XOR<MCPSessionScalarRelationFilter, MCPSessionWhereInput>
    outfit?: XOR<OutfitScalarRelationFilter, OutfitWhereInput>
  }, "mcp_session_id_outfit_id">

  export type MCPSessionOutfitOrderByWithAggregationInput = {
    mcp_session_id?: SortOrder
    outfit_id?: SortOrder
    added_at?: SortOrder
    _count?: MCPSessionOutfitCountOrderByAggregateInput
    _avg?: MCPSessionOutfitAvgOrderByAggregateInput
    _max?: MCPSessionOutfitMaxOrderByAggregateInput
    _min?: MCPSessionOutfitMinOrderByAggregateInput
    _sum?: MCPSessionOutfitSumOrderByAggregateInput
  }

  export type MCPSessionOutfitScalarWhereWithAggregatesInput = {
    AND?: MCPSessionOutfitScalarWhereWithAggregatesInput | MCPSessionOutfitScalarWhereWithAggregatesInput[]
    OR?: MCPSessionOutfitScalarWhereWithAggregatesInput[]
    NOT?: MCPSessionOutfitScalarWhereWithAggregatesInput | MCPSessionOutfitScalarWhereWithAggregatesInput[]
    mcp_session_id?: IntWithAggregatesFilter<"MCPSessionOutfit"> | number
    outfit_id?: IntWithAggregatesFilter<"MCPSessionOutfit"> | number
    added_at?: DateTimeWithAggregatesFilter<"MCPSessionOutfit"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    closets?: ClosetCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    mcpSessions?: MCPSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    closets?: ClosetUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    mcpSessions?: MCPSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    closets?: ClosetUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    mcpSessions?: MCPSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    closets?: ClosetUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    mcpSessions?: MCPSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateInput = {
    title: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutCategoriesInput
    clothingItems?: ClothingItemCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    user_id: number
    title: string
    created_at?: Date | string
    clothingItems?: ClothingItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCategoriesNestedInput
    clothingItems?: ClothingItemUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItems?: ClothingItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    user_id: number
    title: string
    created_at?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClosetCreateInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutClosetsInput
    clothingItems?: ClothingItemCreateNestedManyWithoutClosetInput
  }

  export type ClosetUncheckedCreateInput = {
    id?: number
    user_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    clothingItems?: ClothingItemUncheckedCreateNestedManyWithoutClosetInput
  }

  export type ClosetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClosetsNestedInput
    clothingItems?: ClothingItemUpdateManyWithoutClosetNestedInput
  }

  export type ClosetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItems?: ClothingItemUncheckedUpdateManyWithoutClosetNestedInput
  }

  export type ClosetCreateManyInput = {
    id?: number
    user_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClosetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClosetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type S3BucketCreateInput = {
    name: string
    region: string
    created_at?: Date | string
    clothingItems?: ClothingItemCreateNestedManyWithoutBucketInput
    outfits?: OutfitCreateNestedManyWithoutBucketInput
  }

  export type S3BucketUncheckedCreateInput = {
    name: string
    region: string
    created_at?: Date | string
    clothingItems?: ClothingItemUncheckedCreateNestedManyWithoutBucketInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutBucketInput
  }

  export type S3BucketUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItems?: ClothingItemUpdateManyWithoutBucketNestedInput
    outfits?: OutfitUpdateManyWithoutBucketNestedInput
  }

  export type S3BucketUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItems?: ClothingItemUncheckedUpdateManyWithoutBucketNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutBucketNestedInput
  }

  export type S3BucketCreateManyInput = {
    name: string
    region: string
    created_at?: Date | string
  }

  export type S3BucketUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type S3BucketUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClothingItemCreateInput = {
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    closet: ClosetCreateNestedOneWithoutClothingItemsInput
    category: CategoryCreateNestedOneWithoutClothingItemsInput
    bucket: S3BucketCreateNestedOneWithoutClothingItemsInput
    outfitClothingItems?: OutfitClothingItemCreateNestedManyWithoutClothingItemInput
  }

  export type ClothingItemUncheckedCreateInput = {
    id?: number
    closet_id: number
    category_id: number
    bucket_name: string
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    outfitClothingItems?: OutfitClothingItemUncheckedCreateNestedManyWithoutClothingItemInput
  }

  export type ClothingItemUpdateInput = {
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    closet?: ClosetUpdateOneRequiredWithoutClothingItemsNestedInput
    category?: CategoryUpdateOneRequiredWithoutClothingItemsNestedInput
    bucket?: S3BucketUpdateOneRequiredWithoutClothingItemsNestedInput
    outfitClothingItems?: OutfitClothingItemUpdateManyWithoutClothingItemNestedInput
  }

  export type ClothingItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    closet_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: StringFieldUpdateOperationsInput | string
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    outfitClothingItems?: OutfitClothingItemUncheckedUpdateManyWithoutClothingItemNestedInput
  }

  export type ClothingItemCreateManyInput = {
    id?: number
    closet_id: number
    category_id: number
    bucket_name: string
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
  }

  export type ClothingItemUpdateManyMutationInput = {
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClothingItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    closet_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: StringFieldUpdateOperationsInput | string
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type OutfitCreateInput = {
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutOutfitsInput
    bucket?: S3BucketCreateNestedOneWithoutOutfitsInput
    mcpSession?: MCPSessionCreateNestedOneWithoutOutfitsInput
    outfitClothingItems?: OutfitClothingItemCreateNestedManyWithoutOutfitInput
    mcpSessionOutfits?: MCPSessionOutfitCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUncheckedCreateInput = {
    id?: number
    user_id: number
    bucket_name?: string | null
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    mcp_session_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    outfitClothingItems?: OutfitClothingItemUncheckedCreateNestedManyWithoutOutfitInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUpdateInput = {
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOutfitsNestedInput
    bucket?: S3BucketUpdateOneWithoutOutfitsNestedInput
    mcpSession?: MCPSessionUpdateOneWithoutOutfitsNestedInput
    outfitClothingItems?: OutfitClothingItemUpdateManyWithoutOutfitNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcp_session_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitClothingItems?: OutfitClothingItemUncheckedUpdateManyWithoutOutfitNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitCreateManyInput = {
    id?: number
    user_id: number
    bucket_name?: string | null
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    mcp_session_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OutfitUpdateManyMutationInput = {
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcp_session_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitClothingItemCreateInput = {
    added_at?: Date | string
    outfit: OutfitCreateNestedOneWithoutOutfitClothingItemsInput
    clothingItem: ClothingItemCreateNestedOneWithoutOutfitClothingItemsInput
  }

  export type OutfitClothingItemUncheckedCreateInput = {
    outfit_id: number
    clothing_item_id: number
    added_at?: Date | string
  }

  export type OutfitClothingItemUpdateInput = {
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    outfit?: OutfitUpdateOneRequiredWithoutOutfitClothingItemsNestedInput
    clothingItem?: ClothingItemUpdateOneRequiredWithoutOutfitClothingItemsNestedInput
  }

  export type OutfitClothingItemUncheckedUpdateInput = {
    outfit_id?: IntFieldUpdateOperationsInput | number
    clothing_item_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitClothingItemCreateManyInput = {
    outfit_id: number
    clothing_item_id: number
    added_at?: Date | string
  }

  export type OutfitClothingItemUpdateManyMutationInput = {
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitClothingItemUncheckedUpdateManyInput = {
    outfit_id?: IntFieldUpdateOperationsInput | number
    clothing_item_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionCreateInput = {
    started_at?: Date | string
    user: UserCreateNestedOneWithoutChatSessionsInput
    messages?: ChatMessageCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUncheckedCreateInput = {
    id?: number
    user_id: number
    started_at?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUpdateInput = {
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatSessionsNestedInput
    messages?: ChatMessageUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionCreateManyInput = {
    id?: number
    user_id: number
    started_at?: Date | string
  }

  export type ChatSessionUpdateManyMutationInput = {
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    role: string
    content: string
    sent_at?: Date | string
    session: ChatSessionCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: number
    session_id: number
    role: string
    content: string
    sent_at?: Date | string
  }

  export type ChatMessageUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: ChatSessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: number
    session_id: number
    role: string
    content: string
    sent_at?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPSessionCreateInput = {
    prompt_payload: JsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    completed_at?: Date | string | null
    user: UserCreateNestedOneWithoutMcpSessionsInput
    outfits?: OutfitCreateNestedManyWithoutMcpSessionInput
    mcpSessionOutfits?: MCPSessionOutfitCreateNestedManyWithoutMcpSessionInput
  }

  export type MCPSessionUncheckedCreateInput = {
    id?: number
    user_id: number
    prompt_payload: JsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    completed_at?: Date | string | null
    outfits?: OutfitUncheckedCreateNestedManyWithoutMcpSessionInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedCreateNestedManyWithoutMcpSessionInput
  }

  export type MCPSessionUpdateInput = {
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMcpSessionsNestedInput
    outfits?: OutfitUpdateManyWithoutMcpSessionNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUpdateManyWithoutMcpSessionNestedInput
  }

  export type MCPSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outfits?: OutfitUncheckedUpdateManyWithoutMcpSessionNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedUpdateManyWithoutMcpSessionNestedInput
  }

  export type MCPSessionCreateManyInput = {
    id?: number
    user_id: number
    prompt_payload: JsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    completed_at?: Date | string | null
  }

  export type MCPSessionUpdateManyMutationInput = {
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MCPSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MCPSessionOutfitCreateInput = {
    added_at?: Date | string
    mcpSession: MCPSessionCreateNestedOneWithoutMcpSessionOutfitsInput
    outfit: OutfitCreateNestedOneWithoutMcpSessionOutfitsInput
  }

  export type MCPSessionOutfitUncheckedCreateInput = {
    mcp_session_id: number
    outfit_id: number
    added_at?: Date | string
  }

  export type MCPSessionOutfitUpdateInput = {
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mcpSession?: MCPSessionUpdateOneRequiredWithoutMcpSessionOutfitsNestedInput
    outfit?: OutfitUpdateOneRequiredWithoutMcpSessionOutfitsNestedInput
  }

  export type MCPSessionOutfitUncheckedUpdateInput = {
    mcp_session_id?: IntFieldUpdateOperationsInput | number
    outfit_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPSessionOutfitCreateManyInput = {
    mcp_session_id: number
    outfit_id: number
    added_at?: Date | string
  }

  export type MCPSessionOutfitUpdateManyMutationInput = {
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPSessionOutfitUncheckedUpdateManyInput = {
    mcp_session_id?: IntFieldUpdateOperationsInput | number
    outfit_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClosetListRelationFilter = {
    every?: ClosetWhereInput
    some?: ClosetWhereInput
    none?: ClosetWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type OutfitListRelationFilter = {
    every?: OutfitWhereInput
    some?: OutfitWhereInput
    none?: OutfitWhereInput
  }

  export type ChatSessionListRelationFilter = {
    every?: ChatSessionWhereInput
    some?: ChatSessionWhereInput
    none?: ChatSessionWhereInput
  }

  export type MCPSessionListRelationFilter = {
    every?: MCPSessionWhereInput
    some?: MCPSessionWhereInput
    none?: MCPSessionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClosetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutfitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MCPSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    google_id?: SortOrder
    coin_balance?: SortOrder
    security_question?: SortOrder
    security_answer_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    avatar_url?: SortOrder
    avatar_key?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    coin_balance?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    google_id?: SortOrder
    coin_balance?: SortOrder
    security_question?: SortOrder
    security_answer_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    avatar_url?: SortOrder
    avatar_key?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    google_id?: SortOrder
    coin_balance?: SortOrder
    security_question?: SortOrder
    security_answer_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    avatar_url?: SortOrder
    avatar_key?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    coin_balance?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ClothingItemListRelationFilter = {
    every?: ClothingItemWhereInput
    some?: ClothingItemWhereInput
    none?: ClothingItemWhereInput
  }

  export type ClothingItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryUser_idTitleCompoundUniqueInput = {
    user_id: number
    title: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ClosetCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClosetAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ClosetMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClosetMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClosetSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type S3BucketCountOrderByAggregateInput = {
    name?: SortOrder
    region?: SortOrder
    created_at?: SortOrder
  }

  export type S3BucketMaxOrderByAggregateInput = {
    name?: SortOrder
    region?: SortOrder
    created_at?: SortOrder
  }

  export type S3BucketMinOrderByAggregateInput = {
    name?: SortOrder
    region?: SortOrder
    created_at?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClosetScalarRelationFilter = {
    is?: ClosetWhereInput
    isNot?: ClosetWhereInput
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type S3BucketScalarRelationFilter = {
    is?: S3BucketWhereInput
    isNot?: S3BucketWhereInput
  }

  export type OutfitClothingItemListRelationFilter = {
    every?: OutfitClothingItemWhereInput
    some?: OutfitClothingItemWhereInput
    none?: OutfitClothingItemWhereInput
  }

  export type OutfitClothingItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClothingItemCountOrderByAggregateInput = {
    id?: SortOrder
    closet_id?: SortOrder
    category_id?: SortOrder
    bucket_name?: SortOrder
    image_key?: SortOrder
    label?: SortOrder
    description?: SortOrder
    wear_count?: SortOrder
    last_worn_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
  }

  export type ClothingItemAvgOrderByAggregateInput = {
    id?: SortOrder
    closet_id?: SortOrder
    category_id?: SortOrder
    wear_count?: SortOrder
  }

  export type ClothingItemMaxOrderByAggregateInput = {
    id?: SortOrder
    closet_id?: SortOrder
    category_id?: SortOrder
    bucket_name?: SortOrder
    image_key?: SortOrder
    label?: SortOrder
    description?: SortOrder
    wear_count?: SortOrder
    last_worn_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
  }

  export type ClothingItemMinOrderByAggregateInput = {
    id?: SortOrder
    closet_id?: SortOrder
    category_id?: SortOrder
    bucket_name?: SortOrder
    image_key?: SortOrder
    label?: SortOrder
    description?: SortOrder
    wear_count?: SortOrder
    last_worn_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
  }

  export type ClothingItemSumOrderByAggregateInput = {
    id?: SortOrder
    closet_id?: SortOrder
    category_id?: SortOrder
    wear_count?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type S3BucketNullableScalarRelationFilter = {
    is?: S3BucketWhereInput | null
    isNot?: S3BucketWhereInput | null
  }

  export type MCPSessionNullableScalarRelationFilter = {
    is?: MCPSessionWhereInput | null
    isNot?: MCPSessionWhereInput | null
  }

  export type MCPSessionOutfitListRelationFilter = {
    every?: MCPSessionOutfitWhereInput
    some?: MCPSessionOutfitWhereInput
    none?: MCPSessionOutfitWhereInput
  }

  export type MCPSessionOutfitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutfitCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    bucket_name?: SortOrder
    image_key?: SortOrder
    title?: SortOrder
    is_favorite?: SortOrder
    is_recurring?: SortOrder
    wear_count?: SortOrder
    last_worn_at?: SortOrder
    mcp_session_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OutfitAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wear_count?: SortOrder
    mcp_session_id?: SortOrder
  }

  export type OutfitMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    bucket_name?: SortOrder
    image_key?: SortOrder
    title?: SortOrder
    is_favorite?: SortOrder
    is_recurring?: SortOrder
    wear_count?: SortOrder
    last_worn_at?: SortOrder
    mcp_session_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OutfitMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    bucket_name?: SortOrder
    image_key?: SortOrder
    title?: SortOrder
    is_favorite?: SortOrder
    is_recurring?: SortOrder
    wear_count?: SortOrder
    last_worn_at?: SortOrder
    mcp_session_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OutfitSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wear_count?: SortOrder
    mcp_session_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OutfitScalarRelationFilter = {
    is?: OutfitWhereInput
    isNot?: OutfitWhereInput
  }

  export type ClothingItemScalarRelationFilter = {
    is?: ClothingItemWhereInput
    isNot?: ClothingItemWhereInput
  }

  export type OutfitClothingItemOutfit_idClothing_item_idCompoundUniqueInput = {
    outfit_id: number
    clothing_item_id: number
  }

  export type OutfitClothingItemCountOrderByAggregateInput = {
    outfit_id?: SortOrder
    clothing_item_id?: SortOrder
    added_at?: SortOrder
  }

  export type OutfitClothingItemAvgOrderByAggregateInput = {
    outfit_id?: SortOrder
    clothing_item_id?: SortOrder
  }

  export type OutfitClothingItemMaxOrderByAggregateInput = {
    outfit_id?: SortOrder
    clothing_item_id?: SortOrder
    added_at?: SortOrder
  }

  export type OutfitClothingItemMinOrderByAggregateInput = {
    outfit_id?: SortOrder
    clothing_item_id?: SortOrder
    added_at?: SortOrder
  }

  export type OutfitClothingItemSumOrderByAggregateInput = {
    outfit_id?: SortOrder
    clothing_item_id?: SortOrder
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatSessionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    started_at?: SortOrder
  }

  export type ChatSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ChatSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    started_at?: SortOrder
  }

  export type ChatSessionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    started_at?: SortOrder
  }

  export type ChatSessionSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ChatSessionScalarRelationFilter = {
    is?: ChatSessionWhereInput
    isNot?: ChatSessionWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    sent_at?: SortOrder
  }

  export type ChatMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    sent_at?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    role?: SortOrder
    content?: SortOrder
    sent_at?: SortOrder
  }

  export type ChatMessageSumOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MCPSessionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    prompt_payload?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    completed_at?: SortOrder
  }

  export type MCPSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type MCPSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    completed_at?: SortOrder
  }

  export type MCPSessionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    completed_at?: SortOrder
  }

  export type MCPSessionSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type MCPSessionScalarRelationFilter = {
    is?: MCPSessionWhereInput
    isNot?: MCPSessionWhereInput
  }

  export type MCPSessionOutfitMcp_session_idOutfit_idCompoundUniqueInput = {
    mcp_session_id: number
    outfit_id: number
  }

  export type MCPSessionOutfitCountOrderByAggregateInput = {
    mcp_session_id?: SortOrder
    outfit_id?: SortOrder
    added_at?: SortOrder
  }

  export type MCPSessionOutfitAvgOrderByAggregateInput = {
    mcp_session_id?: SortOrder
    outfit_id?: SortOrder
  }

  export type MCPSessionOutfitMaxOrderByAggregateInput = {
    mcp_session_id?: SortOrder
    outfit_id?: SortOrder
    added_at?: SortOrder
  }

  export type MCPSessionOutfitMinOrderByAggregateInput = {
    mcp_session_id?: SortOrder
    outfit_id?: SortOrder
    added_at?: SortOrder
  }

  export type MCPSessionOutfitSumOrderByAggregateInput = {
    mcp_session_id?: SortOrder
    outfit_id?: SortOrder
  }

  export type ClosetCreateNestedManyWithoutUserInput = {
    create?: XOR<ClosetCreateWithoutUserInput, ClosetUncheckedCreateWithoutUserInput> | ClosetCreateWithoutUserInput[] | ClosetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClosetCreateOrConnectWithoutUserInput | ClosetCreateOrConnectWithoutUserInput[]
    createMany?: ClosetCreateManyUserInputEnvelope
    connect?: ClosetWhereUniqueInput | ClosetWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutUserInput = {
    create?: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput> | CategoryCreateWithoutUserInput[] | CategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutUserInput | CategoryCreateOrConnectWithoutUserInput[]
    createMany?: CategoryCreateManyUserInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type OutfitCreateNestedManyWithoutUserInput = {
    create?: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput> | OutfitCreateWithoutUserInput[] | OutfitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutUserInput | OutfitCreateOrConnectWithoutUserInput[]
    createMany?: OutfitCreateManyUserInputEnvelope
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
  }

  export type ChatSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type MCPSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<MCPSessionCreateWithoutUserInput, MCPSessionUncheckedCreateWithoutUserInput> | MCPSessionCreateWithoutUserInput[] | MCPSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MCPSessionCreateOrConnectWithoutUserInput | MCPSessionCreateOrConnectWithoutUserInput[]
    createMany?: MCPSessionCreateManyUserInputEnvelope
    connect?: MCPSessionWhereUniqueInput | MCPSessionWhereUniqueInput[]
  }

  export type ClosetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClosetCreateWithoutUserInput, ClosetUncheckedCreateWithoutUserInput> | ClosetCreateWithoutUserInput[] | ClosetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClosetCreateOrConnectWithoutUserInput | ClosetCreateOrConnectWithoutUserInput[]
    createMany?: ClosetCreateManyUserInputEnvelope
    connect?: ClosetWhereUniqueInput | ClosetWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput> | CategoryCreateWithoutUserInput[] | CategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutUserInput | CategoryCreateOrConnectWithoutUserInput[]
    createMany?: CategoryCreateManyUserInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type OutfitUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput> | OutfitCreateWithoutUserInput[] | OutfitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutUserInput | OutfitCreateOrConnectWithoutUserInput[]
    createMany?: OutfitCreateManyUserInputEnvelope
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
  }

  export type ChatSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type MCPSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MCPSessionCreateWithoutUserInput, MCPSessionUncheckedCreateWithoutUserInput> | MCPSessionCreateWithoutUserInput[] | MCPSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MCPSessionCreateOrConnectWithoutUserInput | MCPSessionCreateOrConnectWithoutUserInput[]
    createMany?: MCPSessionCreateManyUserInputEnvelope
    connect?: MCPSessionWhereUniqueInput | MCPSessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClosetUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClosetCreateWithoutUserInput, ClosetUncheckedCreateWithoutUserInput> | ClosetCreateWithoutUserInput[] | ClosetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClosetCreateOrConnectWithoutUserInput | ClosetCreateOrConnectWithoutUserInput[]
    upsert?: ClosetUpsertWithWhereUniqueWithoutUserInput | ClosetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClosetCreateManyUserInputEnvelope
    set?: ClosetWhereUniqueInput | ClosetWhereUniqueInput[]
    disconnect?: ClosetWhereUniqueInput | ClosetWhereUniqueInput[]
    delete?: ClosetWhereUniqueInput | ClosetWhereUniqueInput[]
    connect?: ClosetWhereUniqueInput | ClosetWhereUniqueInput[]
    update?: ClosetUpdateWithWhereUniqueWithoutUserInput | ClosetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClosetUpdateManyWithWhereWithoutUserInput | ClosetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClosetScalarWhereInput | ClosetScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput> | CategoryCreateWithoutUserInput[] | CategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutUserInput | CategoryCreateOrConnectWithoutUserInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutUserInput | CategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CategoryCreateManyUserInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutUserInput | CategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutUserInput | CategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type OutfitUpdateManyWithoutUserNestedInput = {
    create?: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput> | OutfitCreateWithoutUserInput[] | OutfitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutUserInput | OutfitCreateOrConnectWithoutUserInput[]
    upsert?: OutfitUpsertWithWhereUniqueWithoutUserInput | OutfitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OutfitCreateManyUserInputEnvelope
    set?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    disconnect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    delete?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    update?: OutfitUpdateWithWhereUniqueWithoutUserInput | OutfitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OutfitUpdateManyWithWhereWithoutUserInput | OutfitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
  }

  export type ChatSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutUserInput | ChatSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutUserInput | ChatSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutUserInput | ChatSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type MCPSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<MCPSessionCreateWithoutUserInput, MCPSessionUncheckedCreateWithoutUserInput> | MCPSessionCreateWithoutUserInput[] | MCPSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MCPSessionCreateOrConnectWithoutUserInput | MCPSessionCreateOrConnectWithoutUserInput[]
    upsert?: MCPSessionUpsertWithWhereUniqueWithoutUserInput | MCPSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MCPSessionCreateManyUserInputEnvelope
    set?: MCPSessionWhereUniqueInput | MCPSessionWhereUniqueInput[]
    disconnect?: MCPSessionWhereUniqueInput | MCPSessionWhereUniqueInput[]
    delete?: MCPSessionWhereUniqueInput | MCPSessionWhereUniqueInput[]
    connect?: MCPSessionWhereUniqueInput | MCPSessionWhereUniqueInput[]
    update?: MCPSessionUpdateWithWhereUniqueWithoutUserInput | MCPSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MCPSessionUpdateManyWithWhereWithoutUserInput | MCPSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MCPSessionScalarWhereInput | MCPSessionScalarWhereInput[]
  }

  export type ClosetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClosetCreateWithoutUserInput, ClosetUncheckedCreateWithoutUserInput> | ClosetCreateWithoutUserInput[] | ClosetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClosetCreateOrConnectWithoutUserInput | ClosetCreateOrConnectWithoutUserInput[]
    upsert?: ClosetUpsertWithWhereUniqueWithoutUserInput | ClosetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClosetCreateManyUserInputEnvelope
    set?: ClosetWhereUniqueInput | ClosetWhereUniqueInput[]
    disconnect?: ClosetWhereUniqueInput | ClosetWhereUniqueInput[]
    delete?: ClosetWhereUniqueInput | ClosetWhereUniqueInput[]
    connect?: ClosetWhereUniqueInput | ClosetWhereUniqueInput[]
    update?: ClosetUpdateWithWhereUniqueWithoutUserInput | ClosetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClosetUpdateManyWithWhereWithoutUserInput | ClosetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClosetScalarWhereInput | ClosetScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput> | CategoryCreateWithoutUserInput[] | CategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutUserInput | CategoryCreateOrConnectWithoutUserInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutUserInput | CategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CategoryCreateManyUserInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutUserInput | CategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutUserInput | CategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type OutfitUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput> | OutfitCreateWithoutUserInput[] | OutfitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutUserInput | OutfitCreateOrConnectWithoutUserInput[]
    upsert?: OutfitUpsertWithWhereUniqueWithoutUserInput | OutfitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OutfitCreateManyUserInputEnvelope
    set?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    disconnect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    delete?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    update?: OutfitUpdateWithWhereUniqueWithoutUserInput | OutfitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OutfitUpdateManyWithWhereWithoutUserInput | OutfitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
  }

  export type ChatSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutUserInput | ChatSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutUserInput | ChatSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutUserInput | ChatSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type MCPSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MCPSessionCreateWithoutUserInput, MCPSessionUncheckedCreateWithoutUserInput> | MCPSessionCreateWithoutUserInput[] | MCPSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MCPSessionCreateOrConnectWithoutUserInput | MCPSessionCreateOrConnectWithoutUserInput[]
    upsert?: MCPSessionUpsertWithWhereUniqueWithoutUserInput | MCPSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MCPSessionCreateManyUserInputEnvelope
    set?: MCPSessionWhereUniqueInput | MCPSessionWhereUniqueInput[]
    disconnect?: MCPSessionWhereUniqueInput | MCPSessionWhereUniqueInput[]
    delete?: MCPSessionWhereUniqueInput | MCPSessionWhereUniqueInput[]
    connect?: MCPSessionWhereUniqueInput | MCPSessionWhereUniqueInput[]
    update?: MCPSessionUpdateWithWhereUniqueWithoutUserInput | MCPSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MCPSessionUpdateManyWithWhereWithoutUserInput | MCPSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MCPSessionScalarWhereInput | MCPSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type ClothingItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ClothingItemCreateWithoutCategoryInput, ClothingItemUncheckedCreateWithoutCategoryInput> | ClothingItemCreateWithoutCategoryInput[] | ClothingItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutCategoryInput | ClothingItemCreateOrConnectWithoutCategoryInput[]
    createMany?: ClothingItemCreateManyCategoryInputEnvelope
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
  }

  export type ClothingItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ClothingItemCreateWithoutCategoryInput, ClothingItemUncheckedCreateWithoutCategoryInput> | ClothingItemCreateWithoutCategoryInput[] | ClothingItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutCategoryInput | ClothingItemCreateOrConnectWithoutCategoryInput[]
    createMany?: ClothingItemCreateManyCategoryInputEnvelope
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCategoriesInput
    upsert?: UserUpsertWithoutCategoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCategoriesInput, UserUpdateWithoutCategoriesInput>, UserUncheckedUpdateWithoutCategoriesInput>
  }

  export type ClothingItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ClothingItemCreateWithoutCategoryInput, ClothingItemUncheckedCreateWithoutCategoryInput> | ClothingItemCreateWithoutCategoryInput[] | ClothingItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutCategoryInput | ClothingItemCreateOrConnectWithoutCategoryInput[]
    upsert?: ClothingItemUpsertWithWhereUniqueWithoutCategoryInput | ClothingItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ClothingItemCreateManyCategoryInputEnvelope
    set?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    disconnect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    delete?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    update?: ClothingItemUpdateWithWhereUniqueWithoutCategoryInput | ClothingItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ClothingItemUpdateManyWithWhereWithoutCategoryInput | ClothingItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ClothingItemScalarWhereInput | ClothingItemScalarWhereInput[]
  }

  export type ClothingItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ClothingItemCreateWithoutCategoryInput, ClothingItemUncheckedCreateWithoutCategoryInput> | ClothingItemCreateWithoutCategoryInput[] | ClothingItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutCategoryInput | ClothingItemCreateOrConnectWithoutCategoryInput[]
    upsert?: ClothingItemUpsertWithWhereUniqueWithoutCategoryInput | ClothingItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ClothingItemCreateManyCategoryInputEnvelope
    set?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    disconnect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    delete?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    update?: ClothingItemUpdateWithWhereUniqueWithoutCategoryInput | ClothingItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ClothingItemUpdateManyWithWhereWithoutCategoryInput | ClothingItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ClothingItemScalarWhereInput | ClothingItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClosetsInput = {
    create?: XOR<UserCreateWithoutClosetsInput, UserUncheckedCreateWithoutClosetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClosetsInput
    connect?: UserWhereUniqueInput
  }

  export type ClothingItemCreateNestedManyWithoutClosetInput = {
    create?: XOR<ClothingItemCreateWithoutClosetInput, ClothingItemUncheckedCreateWithoutClosetInput> | ClothingItemCreateWithoutClosetInput[] | ClothingItemUncheckedCreateWithoutClosetInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutClosetInput | ClothingItemCreateOrConnectWithoutClosetInput[]
    createMany?: ClothingItemCreateManyClosetInputEnvelope
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
  }

  export type ClothingItemUncheckedCreateNestedManyWithoutClosetInput = {
    create?: XOR<ClothingItemCreateWithoutClosetInput, ClothingItemUncheckedCreateWithoutClosetInput> | ClothingItemCreateWithoutClosetInput[] | ClothingItemUncheckedCreateWithoutClosetInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutClosetInput | ClothingItemCreateOrConnectWithoutClosetInput[]
    createMany?: ClothingItemCreateManyClosetInputEnvelope
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutClosetsNestedInput = {
    create?: XOR<UserCreateWithoutClosetsInput, UserUncheckedCreateWithoutClosetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClosetsInput
    upsert?: UserUpsertWithoutClosetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClosetsInput, UserUpdateWithoutClosetsInput>, UserUncheckedUpdateWithoutClosetsInput>
  }

  export type ClothingItemUpdateManyWithoutClosetNestedInput = {
    create?: XOR<ClothingItemCreateWithoutClosetInput, ClothingItemUncheckedCreateWithoutClosetInput> | ClothingItemCreateWithoutClosetInput[] | ClothingItemUncheckedCreateWithoutClosetInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutClosetInput | ClothingItemCreateOrConnectWithoutClosetInput[]
    upsert?: ClothingItemUpsertWithWhereUniqueWithoutClosetInput | ClothingItemUpsertWithWhereUniqueWithoutClosetInput[]
    createMany?: ClothingItemCreateManyClosetInputEnvelope
    set?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    disconnect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    delete?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    update?: ClothingItemUpdateWithWhereUniqueWithoutClosetInput | ClothingItemUpdateWithWhereUniqueWithoutClosetInput[]
    updateMany?: ClothingItemUpdateManyWithWhereWithoutClosetInput | ClothingItemUpdateManyWithWhereWithoutClosetInput[]
    deleteMany?: ClothingItemScalarWhereInput | ClothingItemScalarWhereInput[]
  }

  export type ClothingItemUncheckedUpdateManyWithoutClosetNestedInput = {
    create?: XOR<ClothingItemCreateWithoutClosetInput, ClothingItemUncheckedCreateWithoutClosetInput> | ClothingItemCreateWithoutClosetInput[] | ClothingItemUncheckedCreateWithoutClosetInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutClosetInput | ClothingItemCreateOrConnectWithoutClosetInput[]
    upsert?: ClothingItemUpsertWithWhereUniqueWithoutClosetInput | ClothingItemUpsertWithWhereUniqueWithoutClosetInput[]
    createMany?: ClothingItemCreateManyClosetInputEnvelope
    set?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    disconnect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    delete?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    update?: ClothingItemUpdateWithWhereUniqueWithoutClosetInput | ClothingItemUpdateWithWhereUniqueWithoutClosetInput[]
    updateMany?: ClothingItemUpdateManyWithWhereWithoutClosetInput | ClothingItemUpdateManyWithWhereWithoutClosetInput[]
    deleteMany?: ClothingItemScalarWhereInput | ClothingItemScalarWhereInput[]
  }

  export type ClothingItemCreateNestedManyWithoutBucketInput = {
    create?: XOR<ClothingItemCreateWithoutBucketInput, ClothingItemUncheckedCreateWithoutBucketInput> | ClothingItemCreateWithoutBucketInput[] | ClothingItemUncheckedCreateWithoutBucketInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutBucketInput | ClothingItemCreateOrConnectWithoutBucketInput[]
    createMany?: ClothingItemCreateManyBucketInputEnvelope
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
  }

  export type OutfitCreateNestedManyWithoutBucketInput = {
    create?: XOR<OutfitCreateWithoutBucketInput, OutfitUncheckedCreateWithoutBucketInput> | OutfitCreateWithoutBucketInput[] | OutfitUncheckedCreateWithoutBucketInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutBucketInput | OutfitCreateOrConnectWithoutBucketInput[]
    createMany?: OutfitCreateManyBucketInputEnvelope
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
  }

  export type ClothingItemUncheckedCreateNestedManyWithoutBucketInput = {
    create?: XOR<ClothingItemCreateWithoutBucketInput, ClothingItemUncheckedCreateWithoutBucketInput> | ClothingItemCreateWithoutBucketInput[] | ClothingItemUncheckedCreateWithoutBucketInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutBucketInput | ClothingItemCreateOrConnectWithoutBucketInput[]
    createMany?: ClothingItemCreateManyBucketInputEnvelope
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
  }

  export type OutfitUncheckedCreateNestedManyWithoutBucketInput = {
    create?: XOR<OutfitCreateWithoutBucketInput, OutfitUncheckedCreateWithoutBucketInput> | OutfitCreateWithoutBucketInput[] | OutfitUncheckedCreateWithoutBucketInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutBucketInput | OutfitCreateOrConnectWithoutBucketInput[]
    createMany?: OutfitCreateManyBucketInputEnvelope
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
  }

  export type ClothingItemUpdateManyWithoutBucketNestedInput = {
    create?: XOR<ClothingItemCreateWithoutBucketInput, ClothingItemUncheckedCreateWithoutBucketInput> | ClothingItemCreateWithoutBucketInput[] | ClothingItemUncheckedCreateWithoutBucketInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutBucketInput | ClothingItemCreateOrConnectWithoutBucketInput[]
    upsert?: ClothingItemUpsertWithWhereUniqueWithoutBucketInput | ClothingItemUpsertWithWhereUniqueWithoutBucketInput[]
    createMany?: ClothingItemCreateManyBucketInputEnvelope
    set?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    disconnect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    delete?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    update?: ClothingItemUpdateWithWhereUniqueWithoutBucketInput | ClothingItemUpdateWithWhereUniqueWithoutBucketInput[]
    updateMany?: ClothingItemUpdateManyWithWhereWithoutBucketInput | ClothingItemUpdateManyWithWhereWithoutBucketInput[]
    deleteMany?: ClothingItemScalarWhereInput | ClothingItemScalarWhereInput[]
  }

  export type OutfitUpdateManyWithoutBucketNestedInput = {
    create?: XOR<OutfitCreateWithoutBucketInput, OutfitUncheckedCreateWithoutBucketInput> | OutfitCreateWithoutBucketInput[] | OutfitUncheckedCreateWithoutBucketInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutBucketInput | OutfitCreateOrConnectWithoutBucketInput[]
    upsert?: OutfitUpsertWithWhereUniqueWithoutBucketInput | OutfitUpsertWithWhereUniqueWithoutBucketInput[]
    createMany?: OutfitCreateManyBucketInputEnvelope
    set?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    disconnect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    delete?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    update?: OutfitUpdateWithWhereUniqueWithoutBucketInput | OutfitUpdateWithWhereUniqueWithoutBucketInput[]
    updateMany?: OutfitUpdateManyWithWhereWithoutBucketInput | OutfitUpdateManyWithWhereWithoutBucketInput[]
    deleteMany?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
  }

  export type ClothingItemUncheckedUpdateManyWithoutBucketNestedInput = {
    create?: XOR<ClothingItemCreateWithoutBucketInput, ClothingItemUncheckedCreateWithoutBucketInput> | ClothingItemCreateWithoutBucketInput[] | ClothingItemUncheckedCreateWithoutBucketInput[]
    connectOrCreate?: ClothingItemCreateOrConnectWithoutBucketInput | ClothingItemCreateOrConnectWithoutBucketInput[]
    upsert?: ClothingItemUpsertWithWhereUniqueWithoutBucketInput | ClothingItemUpsertWithWhereUniqueWithoutBucketInput[]
    createMany?: ClothingItemCreateManyBucketInputEnvelope
    set?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    disconnect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    delete?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    connect?: ClothingItemWhereUniqueInput | ClothingItemWhereUniqueInput[]
    update?: ClothingItemUpdateWithWhereUniqueWithoutBucketInput | ClothingItemUpdateWithWhereUniqueWithoutBucketInput[]
    updateMany?: ClothingItemUpdateManyWithWhereWithoutBucketInput | ClothingItemUpdateManyWithWhereWithoutBucketInput[]
    deleteMany?: ClothingItemScalarWhereInput | ClothingItemScalarWhereInput[]
  }

  export type OutfitUncheckedUpdateManyWithoutBucketNestedInput = {
    create?: XOR<OutfitCreateWithoutBucketInput, OutfitUncheckedCreateWithoutBucketInput> | OutfitCreateWithoutBucketInput[] | OutfitUncheckedCreateWithoutBucketInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutBucketInput | OutfitCreateOrConnectWithoutBucketInput[]
    upsert?: OutfitUpsertWithWhereUniqueWithoutBucketInput | OutfitUpsertWithWhereUniqueWithoutBucketInput[]
    createMany?: OutfitCreateManyBucketInputEnvelope
    set?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    disconnect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    delete?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    update?: OutfitUpdateWithWhereUniqueWithoutBucketInput | OutfitUpdateWithWhereUniqueWithoutBucketInput[]
    updateMany?: OutfitUpdateManyWithWhereWithoutBucketInput | OutfitUpdateManyWithWhereWithoutBucketInput[]
    deleteMany?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
  }

  export type ClosetCreateNestedOneWithoutClothingItemsInput = {
    create?: XOR<ClosetCreateWithoutClothingItemsInput, ClosetUncheckedCreateWithoutClothingItemsInput>
    connectOrCreate?: ClosetCreateOrConnectWithoutClothingItemsInput
    connect?: ClosetWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutClothingItemsInput = {
    create?: XOR<CategoryCreateWithoutClothingItemsInput, CategoryUncheckedCreateWithoutClothingItemsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutClothingItemsInput
    connect?: CategoryWhereUniqueInput
  }

  export type S3BucketCreateNestedOneWithoutClothingItemsInput = {
    create?: XOR<S3BucketCreateWithoutClothingItemsInput, S3BucketUncheckedCreateWithoutClothingItemsInput>
    connectOrCreate?: S3BucketCreateOrConnectWithoutClothingItemsInput
    connect?: S3BucketWhereUniqueInput
  }

  export type OutfitClothingItemCreateNestedManyWithoutClothingItemInput = {
    create?: XOR<OutfitClothingItemCreateWithoutClothingItemInput, OutfitClothingItemUncheckedCreateWithoutClothingItemInput> | OutfitClothingItemCreateWithoutClothingItemInput[] | OutfitClothingItemUncheckedCreateWithoutClothingItemInput[]
    connectOrCreate?: OutfitClothingItemCreateOrConnectWithoutClothingItemInput | OutfitClothingItemCreateOrConnectWithoutClothingItemInput[]
    createMany?: OutfitClothingItemCreateManyClothingItemInputEnvelope
    connect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
  }

  export type OutfitClothingItemUncheckedCreateNestedManyWithoutClothingItemInput = {
    create?: XOR<OutfitClothingItemCreateWithoutClothingItemInput, OutfitClothingItemUncheckedCreateWithoutClothingItemInput> | OutfitClothingItemCreateWithoutClothingItemInput[] | OutfitClothingItemUncheckedCreateWithoutClothingItemInput[]
    connectOrCreate?: OutfitClothingItemCreateOrConnectWithoutClothingItemInput | OutfitClothingItemCreateOrConnectWithoutClothingItemInput[]
    createMany?: OutfitClothingItemCreateManyClothingItemInputEnvelope
    connect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClosetUpdateOneRequiredWithoutClothingItemsNestedInput = {
    create?: XOR<ClosetCreateWithoutClothingItemsInput, ClosetUncheckedCreateWithoutClothingItemsInput>
    connectOrCreate?: ClosetCreateOrConnectWithoutClothingItemsInput
    upsert?: ClosetUpsertWithoutClothingItemsInput
    connect?: ClosetWhereUniqueInput
    update?: XOR<XOR<ClosetUpdateToOneWithWhereWithoutClothingItemsInput, ClosetUpdateWithoutClothingItemsInput>, ClosetUncheckedUpdateWithoutClothingItemsInput>
  }

  export type CategoryUpdateOneRequiredWithoutClothingItemsNestedInput = {
    create?: XOR<CategoryCreateWithoutClothingItemsInput, CategoryUncheckedCreateWithoutClothingItemsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutClothingItemsInput
    upsert?: CategoryUpsertWithoutClothingItemsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutClothingItemsInput, CategoryUpdateWithoutClothingItemsInput>, CategoryUncheckedUpdateWithoutClothingItemsInput>
  }

  export type S3BucketUpdateOneRequiredWithoutClothingItemsNestedInput = {
    create?: XOR<S3BucketCreateWithoutClothingItemsInput, S3BucketUncheckedCreateWithoutClothingItemsInput>
    connectOrCreate?: S3BucketCreateOrConnectWithoutClothingItemsInput
    upsert?: S3BucketUpsertWithoutClothingItemsInput
    connect?: S3BucketWhereUniqueInput
    update?: XOR<XOR<S3BucketUpdateToOneWithWhereWithoutClothingItemsInput, S3BucketUpdateWithoutClothingItemsInput>, S3BucketUncheckedUpdateWithoutClothingItemsInput>
  }

  export type OutfitClothingItemUpdateManyWithoutClothingItemNestedInput = {
    create?: XOR<OutfitClothingItemCreateWithoutClothingItemInput, OutfitClothingItemUncheckedCreateWithoutClothingItemInput> | OutfitClothingItemCreateWithoutClothingItemInput[] | OutfitClothingItemUncheckedCreateWithoutClothingItemInput[]
    connectOrCreate?: OutfitClothingItemCreateOrConnectWithoutClothingItemInput | OutfitClothingItemCreateOrConnectWithoutClothingItemInput[]
    upsert?: OutfitClothingItemUpsertWithWhereUniqueWithoutClothingItemInput | OutfitClothingItemUpsertWithWhereUniqueWithoutClothingItemInput[]
    createMany?: OutfitClothingItemCreateManyClothingItemInputEnvelope
    set?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    disconnect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    delete?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    connect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    update?: OutfitClothingItemUpdateWithWhereUniqueWithoutClothingItemInput | OutfitClothingItemUpdateWithWhereUniqueWithoutClothingItemInput[]
    updateMany?: OutfitClothingItemUpdateManyWithWhereWithoutClothingItemInput | OutfitClothingItemUpdateManyWithWhereWithoutClothingItemInput[]
    deleteMany?: OutfitClothingItemScalarWhereInput | OutfitClothingItemScalarWhereInput[]
  }

  export type OutfitClothingItemUncheckedUpdateManyWithoutClothingItemNestedInput = {
    create?: XOR<OutfitClothingItemCreateWithoutClothingItemInput, OutfitClothingItemUncheckedCreateWithoutClothingItemInput> | OutfitClothingItemCreateWithoutClothingItemInput[] | OutfitClothingItemUncheckedCreateWithoutClothingItemInput[]
    connectOrCreate?: OutfitClothingItemCreateOrConnectWithoutClothingItemInput | OutfitClothingItemCreateOrConnectWithoutClothingItemInput[]
    upsert?: OutfitClothingItemUpsertWithWhereUniqueWithoutClothingItemInput | OutfitClothingItemUpsertWithWhereUniqueWithoutClothingItemInput[]
    createMany?: OutfitClothingItemCreateManyClothingItemInputEnvelope
    set?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    disconnect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    delete?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    connect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    update?: OutfitClothingItemUpdateWithWhereUniqueWithoutClothingItemInput | OutfitClothingItemUpdateWithWhereUniqueWithoutClothingItemInput[]
    updateMany?: OutfitClothingItemUpdateManyWithWhereWithoutClothingItemInput | OutfitClothingItemUpdateManyWithWhereWithoutClothingItemInput[]
    deleteMany?: OutfitClothingItemScalarWhereInput | OutfitClothingItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOutfitsInput = {
    create?: XOR<UserCreateWithoutOutfitsInput, UserUncheckedCreateWithoutOutfitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutfitsInput
    connect?: UserWhereUniqueInput
  }

  export type S3BucketCreateNestedOneWithoutOutfitsInput = {
    create?: XOR<S3BucketCreateWithoutOutfitsInput, S3BucketUncheckedCreateWithoutOutfitsInput>
    connectOrCreate?: S3BucketCreateOrConnectWithoutOutfitsInput
    connect?: S3BucketWhereUniqueInput
  }

  export type MCPSessionCreateNestedOneWithoutOutfitsInput = {
    create?: XOR<MCPSessionCreateWithoutOutfitsInput, MCPSessionUncheckedCreateWithoutOutfitsInput>
    connectOrCreate?: MCPSessionCreateOrConnectWithoutOutfitsInput
    connect?: MCPSessionWhereUniqueInput
  }

  export type OutfitClothingItemCreateNestedManyWithoutOutfitInput = {
    create?: XOR<OutfitClothingItemCreateWithoutOutfitInput, OutfitClothingItemUncheckedCreateWithoutOutfitInput> | OutfitClothingItemCreateWithoutOutfitInput[] | OutfitClothingItemUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: OutfitClothingItemCreateOrConnectWithoutOutfitInput | OutfitClothingItemCreateOrConnectWithoutOutfitInput[]
    createMany?: OutfitClothingItemCreateManyOutfitInputEnvelope
    connect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
  }

  export type MCPSessionOutfitCreateNestedManyWithoutOutfitInput = {
    create?: XOR<MCPSessionOutfitCreateWithoutOutfitInput, MCPSessionOutfitUncheckedCreateWithoutOutfitInput> | MCPSessionOutfitCreateWithoutOutfitInput[] | MCPSessionOutfitUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: MCPSessionOutfitCreateOrConnectWithoutOutfitInput | MCPSessionOutfitCreateOrConnectWithoutOutfitInput[]
    createMany?: MCPSessionOutfitCreateManyOutfitInputEnvelope
    connect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
  }

  export type OutfitClothingItemUncheckedCreateNestedManyWithoutOutfitInput = {
    create?: XOR<OutfitClothingItemCreateWithoutOutfitInput, OutfitClothingItemUncheckedCreateWithoutOutfitInput> | OutfitClothingItemCreateWithoutOutfitInput[] | OutfitClothingItemUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: OutfitClothingItemCreateOrConnectWithoutOutfitInput | OutfitClothingItemCreateOrConnectWithoutOutfitInput[]
    createMany?: OutfitClothingItemCreateManyOutfitInputEnvelope
    connect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
  }

  export type MCPSessionOutfitUncheckedCreateNestedManyWithoutOutfitInput = {
    create?: XOR<MCPSessionOutfitCreateWithoutOutfitInput, MCPSessionOutfitUncheckedCreateWithoutOutfitInput> | MCPSessionOutfitCreateWithoutOutfitInput[] | MCPSessionOutfitUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: MCPSessionOutfitCreateOrConnectWithoutOutfitInput | MCPSessionOutfitCreateOrConnectWithoutOutfitInput[]
    createMany?: MCPSessionOutfitCreateManyOutfitInputEnvelope
    connect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutOutfitsNestedInput = {
    create?: XOR<UserCreateWithoutOutfitsInput, UserUncheckedCreateWithoutOutfitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutfitsInput
    upsert?: UserUpsertWithoutOutfitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOutfitsInput, UserUpdateWithoutOutfitsInput>, UserUncheckedUpdateWithoutOutfitsInput>
  }

  export type S3BucketUpdateOneWithoutOutfitsNestedInput = {
    create?: XOR<S3BucketCreateWithoutOutfitsInput, S3BucketUncheckedCreateWithoutOutfitsInput>
    connectOrCreate?: S3BucketCreateOrConnectWithoutOutfitsInput
    upsert?: S3BucketUpsertWithoutOutfitsInput
    disconnect?: S3BucketWhereInput | boolean
    delete?: S3BucketWhereInput | boolean
    connect?: S3BucketWhereUniqueInput
    update?: XOR<XOR<S3BucketUpdateToOneWithWhereWithoutOutfitsInput, S3BucketUpdateWithoutOutfitsInput>, S3BucketUncheckedUpdateWithoutOutfitsInput>
  }

  export type MCPSessionUpdateOneWithoutOutfitsNestedInput = {
    create?: XOR<MCPSessionCreateWithoutOutfitsInput, MCPSessionUncheckedCreateWithoutOutfitsInput>
    connectOrCreate?: MCPSessionCreateOrConnectWithoutOutfitsInput
    upsert?: MCPSessionUpsertWithoutOutfitsInput
    disconnect?: MCPSessionWhereInput | boolean
    delete?: MCPSessionWhereInput | boolean
    connect?: MCPSessionWhereUniqueInput
    update?: XOR<XOR<MCPSessionUpdateToOneWithWhereWithoutOutfitsInput, MCPSessionUpdateWithoutOutfitsInput>, MCPSessionUncheckedUpdateWithoutOutfitsInput>
  }

  export type OutfitClothingItemUpdateManyWithoutOutfitNestedInput = {
    create?: XOR<OutfitClothingItemCreateWithoutOutfitInput, OutfitClothingItemUncheckedCreateWithoutOutfitInput> | OutfitClothingItemCreateWithoutOutfitInput[] | OutfitClothingItemUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: OutfitClothingItemCreateOrConnectWithoutOutfitInput | OutfitClothingItemCreateOrConnectWithoutOutfitInput[]
    upsert?: OutfitClothingItemUpsertWithWhereUniqueWithoutOutfitInput | OutfitClothingItemUpsertWithWhereUniqueWithoutOutfitInput[]
    createMany?: OutfitClothingItemCreateManyOutfitInputEnvelope
    set?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    disconnect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    delete?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    connect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    update?: OutfitClothingItemUpdateWithWhereUniqueWithoutOutfitInput | OutfitClothingItemUpdateWithWhereUniqueWithoutOutfitInput[]
    updateMany?: OutfitClothingItemUpdateManyWithWhereWithoutOutfitInput | OutfitClothingItemUpdateManyWithWhereWithoutOutfitInput[]
    deleteMany?: OutfitClothingItemScalarWhereInput | OutfitClothingItemScalarWhereInput[]
  }

  export type MCPSessionOutfitUpdateManyWithoutOutfitNestedInput = {
    create?: XOR<MCPSessionOutfitCreateWithoutOutfitInput, MCPSessionOutfitUncheckedCreateWithoutOutfitInput> | MCPSessionOutfitCreateWithoutOutfitInput[] | MCPSessionOutfitUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: MCPSessionOutfitCreateOrConnectWithoutOutfitInput | MCPSessionOutfitCreateOrConnectWithoutOutfitInput[]
    upsert?: MCPSessionOutfitUpsertWithWhereUniqueWithoutOutfitInput | MCPSessionOutfitUpsertWithWhereUniqueWithoutOutfitInput[]
    createMany?: MCPSessionOutfitCreateManyOutfitInputEnvelope
    set?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    disconnect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    delete?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    connect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    update?: MCPSessionOutfitUpdateWithWhereUniqueWithoutOutfitInput | MCPSessionOutfitUpdateWithWhereUniqueWithoutOutfitInput[]
    updateMany?: MCPSessionOutfitUpdateManyWithWhereWithoutOutfitInput | MCPSessionOutfitUpdateManyWithWhereWithoutOutfitInput[]
    deleteMany?: MCPSessionOutfitScalarWhereInput | MCPSessionOutfitScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OutfitClothingItemUncheckedUpdateManyWithoutOutfitNestedInput = {
    create?: XOR<OutfitClothingItemCreateWithoutOutfitInput, OutfitClothingItemUncheckedCreateWithoutOutfitInput> | OutfitClothingItemCreateWithoutOutfitInput[] | OutfitClothingItemUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: OutfitClothingItemCreateOrConnectWithoutOutfitInput | OutfitClothingItemCreateOrConnectWithoutOutfitInput[]
    upsert?: OutfitClothingItemUpsertWithWhereUniqueWithoutOutfitInput | OutfitClothingItemUpsertWithWhereUniqueWithoutOutfitInput[]
    createMany?: OutfitClothingItemCreateManyOutfitInputEnvelope
    set?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    disconnect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    delete?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    connect?: OutfitClothingItemWhereUniqueInput | OutfitClothingItemWhereUniqueInput[]
    update?: OutfitClothingItemUpdateWithWhereUniqueWithoutOutfitInput | OutfitClothingItemUpdateWithWhereUniqueWithoutOutfitInput[]
    updateMany?: OutfitClothingItemUpdateManyWithWhereWithoutOutfitInput | OutfitClothingItemUpdateManyWithWhereWithoutOutfitInput[]
    deleteMany?: OutfitClothingItemScalarWhereInput | OutfitClothingItemScalarWhereInput[]
  }

  export type MCPSessionOutfitUncheckedUpdateManyWithoutOutfitNestedInput = {
    create?: XOR<MCPSessionOutfitCreateWithoutOutfitInput, MCPSessionOutfitUncheckedCreateWithoutOutfitInput> | MCPSessionOutfitCreateWithoutOutfitInput[] | MCPSessionOutfitUncheckedCreateWithoutOutfitInput[]
    connectOrCreate?: MCPSessionOutfitCreateOrConnectWithoutOutfitInput | MCPSessionOutfitCreateOrConnectWithoutOutfitInput[]
    upsert?: MCPSessionOutfitUpsertWithWhereUniqueWithoutOutfitInput | MCPSessionOutfitUpsertWithWhereUniqueWithoutOutfitInput[]
    createMany?: MCPSessionOutfitCreateManyOutfitInputEnvelope
    set?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    disconnect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    delete?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    connect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    update?: MCPSessionOutfitUpdateWithWhereUniqueWithoutOutfitInput | MCPSessionOutfitUpdateWithWhereUniqueWithoutOutfitInput[]
    updateMany?: MCPSessionOutfitUpdateManyWithWhereWithoutOutfitInput | MCPSessionOutfitUpdateManyWithWhereWithoutOutfitInput[]
    deleteMany?: MCPSessionOutfitScalarWhereInput | MCPSessionOutfitScalarWhereInput[]
  }

  export type OutfitCreateNestedOneWithoutOutfitClothingItemsInput = {
    create?: XOR<OutfitCreateWithoutOutfitClothingItemsInput, OutfitUncheckedCreateWithoutOutfitClothingItemsInput>
    connectOrCreate?: OutfitCreateOrConnectWithoutOutfitClothingItemsInput
    connect?: OutfitWhereUniqueInput
  }

  export type ClothingItemCreateNestedOneWithoutOutfitClothingItemsInput = {
    create?: XOR<ClothingItemCreateWithoutOutfitClothingItemsInput, ClothingItemUncheckedCreateWithoutOutfitClothingItemsInput>
    connectOrCreate?: ClothingItemCreateOrConnectWithoutOutfitClothingItemsInput
    connect?: ClothingItemWhereUniqueInput
  }

  export type OutfitUpdateOneRequiredWithoutOutfitClothingItemsNestedInput = {
    create?: XOR<OutfitCreateWithoutOutfitClothingItemsInput, OutfitUncheckedCreateWithoutOutfitClothingItemsInput>
    connectOrCreate?: OutfitCreateOrConnectWithoutOutfitClothingItemsInput
    upsert?: OutfitUpsertWithoutOutfitClothingItemsInput
    connect?: OutfitWhereUniqueInput
    update?: XOR<XOR<OutfitUpdateToOneWithWhereWithoutOutfitClothingItemsInput, OutfitUpdateWithoutOutfitClothingItemsInput>, OutfitUncheckedUpdateWithoutOutfitClothingItemsInput>
  }

  export type ClothingItemUpdateOneRequiredWithoutOutfitClothingItemsNestedInput = {
    create?: XOR<ClothingItemCreateWithoutOutfitClothingItemsInput, ClothingItemUncheckedCreateWithoutOutfitClothingItemsInput>
    connectOrCreate?: ClothingItemCreateOrConnectWithoutOutfitClothingItemsInput
    upsert?: ClothingItemUpsertWithoutOutfitClothingItemsInput
    connect?: ClothingItemWhereUniqueInput
    update?: XOR<XOR<ClothingItemUpdateToOneWithWhereWithoutOutfitClothingItemsInput, ClothingItemUpdateWithoutOutfitClothingItemsInput>, ClothingItemUncheckedUpdateWithoutOutfitClothingItemsInput>
  }

  export type UserCreateNestedOneWithoutChatSessionsInput = {
    create?: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutChatSessionsNestedInput = {
    create?: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatSessionsInput
    upsert?: UserUpsertWithoutChatSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatSessionsInput, UserUpdateWithoutChatSessionsInput>, UserUncheckedUpdateWithoutChatSessionsInput>
  }

  export type ChatMessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSessionInput | ChatMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSessionInput | ChatMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSessionInput | ChatMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSessionInput | ChatMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSessionInput | ChatMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSessionInput | ChatMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatSessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutMessagesInput
    connect?: ChatSessionWhereUniqueInput
  }

  export type ChatSessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutMessagesInput
    upsert?: ChatSessionUpsertWithoutMessagesInput
    connect?: ChatSessionWhereUniqueInput
    update?: XOR<XOR<ChatSessionUpdateToOneWithWhereWithoutMessagesInput, ChatSessionUpdateWithoutMessagesInput>, ChatSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutMcpSessionsInput = {
    create?: XOR<UserCreateWithoutMcpSessionsInput, UserUncheckedCreateWithoutMcpSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMcpSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type OutfitCreateNestedManyWithoutMcpSessionInput = {
    create?: XOR<OutfitCreateWithoutMcpSessionInput, OutfitUncheckedCreateWithoutMcpSessionInput> | OutfitCreateWithoutMcpSessionInput[] | OutfitUncheckedCreateWithoutMcpSessionInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutMcpSessionInput | OutfitCreateOrConnectWithoutMcpSessionInput[]
    createMany?: OutfitCreateManyMcpSessionInputEnvelope
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
  }

  export type MCPSessionOutfitCreateNestedManyWithoutMcpSessionInput = {
    create?: XOR<MCPSessionOutfitCreateWithoutMcpSessionInput, MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput> | MCPSessionOutfitCreateWithoutMcpSessionInput[] | MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput[]
    connectOrCreate?: MCPSessionOutfitCreateOrConnectWithoutMcpSessionInput | MCPSessionOutfitCreateOrConnectWithoutMcpSessionInput[]
    createMany?: MCPSessionOutfitCreateManyMcpSessionInputEnvelope
    connect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
  }

  export type OutfitUncheckedCreateNestedManyWithoutMcpSessionInput = {
    create?: XOR<OutfitCreateWithoutMcpSessionInput, OutfitUncheckedCreateWithoutMcpSessionInput> | OutfitCreateWithoutMcpSessionInput[] | OutfitUncheckedCreateWithoutMcpSessionInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutMcpSessionInput | OutfitCreateOrConnectWithoutMcpSessionInput[]
    createMany?: OutfitCreateManyMcpSessionInputEnvelope
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
  }

  export type MCPSessionOutfitUncheckedCreateNestedManyWithoutMcpSessionInput = {
    create?: XOR<MCPSessionOutfitCreateWithoutMcpSessionInput, MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput> | MCPSessionOutfitCreateWithoutMcpSessionInput[] | MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput[]
    connectOrCreate?: MCPSessionOutfitCreateOrConnectWithoutMcpSessionInput | MCPSessionOutfitCreateOrConnectWithoutMcpSessionInput[]
    createMany?: MCPSessionOutfitCreateManyMcpSessionInputEnvelope
    connect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMcpSessionsNestedInput = {
    create?: XOR<UserCreateWithoutMcpSessionsInput, UserUncheckedCreateWithoutMcpSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMcpSessionsInput
    upsert?: UserUpsertWithoutMcpSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMcpSessionsInput, UserUpdateWithoutMcpSessionsInput>, UserUncheckedUpdateWithoutMcpSessionsInput>
  }

  export type OutfitUpdateManyWithoutMcpSessionNestedInput = {
    create?: XOR<OutfitCreateWithoutMcpSessionInput, OutfitUncheckedCreateWithoutMcpSessionInput> | OutfitCreateWithoutMcpSessionInput[] | OutfitUncheckedCreateWithoutMcpSessionInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutMcpSessionInput | OutfitCreateOrConnectWithoutMcpSessionInput[]
    upsert?: OutfitUpsertWithWhereUniqueWithoutMcpSessionInput | OutfitUpsertWithWhereUniqueWithoutMcpSessionInput[]
    createMany?: OutfitCreateManyMcpSessionInputEnvelope
    set?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    disconnect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    delete?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    update?: OutfitUpdateWithWhereUniqueWithoutMcpSessionInput | OutfitUpdateWithWhereUniqueWithoutMcpSessionInput[]
    updateMany?: OutfitUpdateManyWithWhereWithoutMcpSessionInput | OutfitUpdateManyWithWhereWithoutMcpSessionInput[]
    deleteMany?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
  }

  export type MCPSessionOutfitUpdateManyWithoutMcpSessionNestedInput = {
    create?: XOR<MCPSessionOutfitCreateWithoutMcpSessionInput, MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput> | MCPSessionOutfitCreateWithoutMcpSessionInput[] | MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput[]
    connectOrCreate?: MCPSessionOutfitCreateOrConnectWithoutMcpSessionInput | MCPSessionOutfitCreateOrConnectWithoutMcpSessionInput[]
    upsert?: MCPSessionOutfitUpsertWithWhereUniqueWithoutMcpSessionInput | MCPSessionOutfitUpsertWithWhereUniqueWithoutMcpSessionInput[]
    createMany?: MCPSessionOutfitCreateManyMcpSessionInputEnvelope
    set?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    disconnect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    delete?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    connect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    update?: MCPSessionOutfitUpdateWithWhereUniqueWithoutMcpSessionInput | MCPSessionOutfitUpdateWithWhereUniqueWithoutMcpSessionInput[]
    updateMany?: MCPSessionOutfitUpdateManyWithWhereWithoutMcpSessionInput | MCPSessionOutfitUpdateManyWithWhereWithoutMcpSessionInput[]
    deleteMany?: MCPSessionOutfitScalarWhereInput | MCPSessionOutfitScalarWhereInput[]
  }

  export type OutfitUncheckedUpdateManyWithoutMcpSessionNestedInput = {
    create?: XOR<OutfitCreateWithoutMcpSessionInput, OutfitUncheckedCreateWithoutMcpSessionInput> | OutfitCreateWithoutMcpSessionInput[] | OutfitUncheckedCreateWithoutMcpSessionInput[]
    connectOrCreate?: OutfitCreateOrConnectWithoutMcpSessionInput | OutfitCreateOrConnectWithoutMcpSessionInput[]
    upsert?: OutfitUpsertWithWhereUniqueWithoutMcpSessionInput | OutfitUpsertWithWhereUniqueWithoutMcpSessionInput[]
    createMany?: OutfitCreateManyMcpSessionInputEnvelope
    set?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    disconnect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    delete?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    connect?: OutfitWhereUniqueInput | OutfitWhereUniqueInput[]
    update?: OutfitUpdateWithWhereUniqueWithoutMcpSessionInput | OutfitUpdateWithWhereUniqueWithoutMcpSessionInput[]
    updateMany?: OutfitUpdateManyWithWhereWithoutMcpSessionInput | OutfitUpdateManyWithWhereWithoutMcpSessionInput[]
    deleteMany?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
  }

  export type MCPSessionOutfitUncheckedUpdateManyWithoutMcpSessionNestedInput = {
    create?: XOR<MCPSessionOutfitCreateWithoutMcpSessionInput, MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput> | MCPSessionOutfitCreateWithoutMcpSessionInput[] | MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput[]
    connectOrCreate?: MCPSessionOutfitCreateOrConnectWithoutMcpSessionInput | MCPSessionOutfitCreateOrConnectWithoutMcpSessionInput[]
    upsert?: MCPSessionOutfitUpsertWithWhereUniqueWithoutMcpSessionInput | MCPSessionOutfitUpsertWithWhereUniqueWithoutMcpSessionInput[]
    createMany?: MCPSessionOutfitCreateManyMcpSessionInputEnvelope
    set?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    disconnect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    delete?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    connect?: MCPSessionOutfitWhereUniqueInput | MCPSessionOutfitWhereUniqueInput[]
    update?: MCPSessionOutfitUpdateWithWhereUniqueWithoutMcpSessionInput | MCPSessionOutfitUpdateWithWhereUniqueWithoutMcpSessionInput[]
    updateMany?: MCPSessionOutfitUpdateManyWithWhereWithoutMcpSessionInput | MCPSessionOutfitUpdateManyWithWhereWithoutMcpSessionInput[]
    deleteMany?: MCPSessionOutfitScalarWhereInput | MCPSessionOutfitScalarWhereInput[]
  }

  export type MCPSessionCreateNestedOneWithoutMcpSessionOutfitsInput = {
    create?: XOR<MCPSessionCreateWithoutMcpSessionOutfitsInput, MCPSessionUncheckedCreateWithoutMcpSessionOutfitsInput>
    connectOrCreate?: MCPSessionCreateOrConnectWithoutMcpSessionOutfitsInput
    connect?: MCPSessionWhereUniqueInput
  }

  export type OutfitCreateNestedOneWithoutMcpSessionOutfitsInput = {
    create?: XOR<OutfitCreateWithoutMcpSessionOutfitsInput, OutfitUncheckedCreateWithoutMcpSessionOutfitsInput>
    connectOrCreate?: OutfitCreateOrConnectWithoutMcpSessionOutfitsInput
    connect?: OutfitWhereUniqueInput
  }

  export type MCPSessionUpdateOneRequiredWithoutMcpSessionOutfitsNestedInput = {
    create?: XOR<MCPSessionCreateWithoutMcpSessionOutfitsInput, MCPSessionUncheckedCreateWithoutMcpSessionOutfitsInput>
    connectOrCreate?: MCPSessionCreateOrConnectWithoutMcpSessionOutfitsInput
    upsert?: MCPSessionUpsertWithoutMcpSessionOutfitsInput
    connect?: MCPSessionWhereUniqueInput
    update?: XOR<XOR<MCPSessionUpdateToOneWithWhereWithoutMcpSessionOutfitsInput, MCPSessionUpdateWithoutMcpSessionOutfitsInput>, MCPSessionUncheckedUpdateWithoutMcpSessionOutfitsInput>
  }

  export type OutfitUpdateOneRequiredWithoutMcpSessionOutfitsNestedInput = {
    create?: XOR<OutfitCreateWithoutMcpSessionOutfitsInput, OutfitUncheckedCreateWithoutMcpSessionOutfitsInput>
    connectOrCreate?: OutfitCreateOrConnectWithoutMcpSessionOutfitsInput
    upsert?: OutfitUpsertWithoutMcpSessionOutfitsInput
    connect?: OutfitWhereUniqueInput
    update?: XOR<XOR<OutfitUpdateToOneWithWhereWithoutMcpSessionOutfitsInput, OutfitUpdateWithoutMcpSessionOutfitsInput>, OutfitUncheckedUpdateWithoutMcpSessionOutfitsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ClosetCreateWithoutUserInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    clothingItems?: ClothingItemCreateNestedManyWithoutClosetInput
  }

  export type ClosetUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    clothingItems?: ClothingItemUncheckedCreateNestedManyWithoutClosetInput
  }

  export type ClosetCreateOrConnectWithoutUserInput = {
    where: ClosetWhereUniqueInput
    create: XOR<ClosetCreateWithoutUserInput, ClosetUncheckedCreateWithoutUserInput>
  }

  export type ClosetCreateManyUserInputEnvelope = {
    data: ClosetCreateManyUserInput | ClosetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutUserInput = {
    title: string
    created_at?: Date | string
    clothingItems?: ClothingItemCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    created_at?: Date | string
    clothingItems?: ClothingItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutUserInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput>
  }

  export type CategoryCreateManyUserInputEnvelope = {
    data: CategoryCreateManyUserInput | CategoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OutfitCreateWithoutUserInput = {
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    bucket?: S3BucketCreateNestedOneWithoutOutfitsInput
    mcpSession?: MCPSessionCreateNestedOneWithoutOutfitsInput
    outfitClothingItems?: OutfitClothingItemCreateNestedManyWithoutOutfitInput
    mcpSessionOutfits?: MCPSessionOutfitCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUncheckedCreateWithoutUserInput = {
    id?: number
    bucket_name?: string | null
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    mcp_session_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    outfitClothingItems?: OutfitClothingItemUncheckedCreateNestedManyWithoutOutfitInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedCreateNestedManyWithoutOutfitInput
  }

  export type OutfitCreateOrConnectWithoutUserInput = {
    where: OutfitWhereUniqueInput
    create: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput>
  }

  export type OutfitCreateManyUserInputEnvelope = {
    data: OutfitCreateManyUserInput | OutfitCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatSessionCreateWithoutUserInput = {
    started_at?: Date | string
    messages?: ChatMessageCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUncheckedCreateWithoutUserInput = {
    id?: number
    started_at?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionCreateOrConnectWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionCreateManyUserInputEnvelope = {
    data: ChatSessionCreateManyUserInput | ChatSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MCPSessionCreateWithoutUserInput = {
    prompt_payload: JsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    completed_at?: Date | string | null
    outfits?: OutfitCreateNestedManyWithoutMcpSessionInput
    mcpSessionOutfits?: MCPSessionOutfitCreateNestedManyWithoutMcpSessionInput
  }

  export type MCPSessionUncheckedCreateWithoutUserInput = {
    id?: number
    prompt_payload: JsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    completed_at?: Date | string | null
    outfits?: OutfitUncheckedCreateNestedManyWithoutMcpSessionInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedCreateNestedManyWithoutMcpSessionInput
  }

  export type MCPSessionCreateOrConnectWithoutUserInput = {
    where: MCPSessionWhereUniqueInput
    create: XOR<MCPSessionCreateWithoutUserInput, MCPSessionUncheckedCreateWithoutUserInput>
  }

  export type MCPSessionCreateManyUserInputEnvelope = {
    data: MCPSessionCreateManyUserInput | MCPSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClosetUpsertWithWhereUniqueWithoutUserInput = {
    where: ClosetWhereUniqueInput
    update: XOR<ClosetUpdateWithoutUserInput, ClosetUncheckedUpdateWithoutUserInput>
    create: XOR<ClosetCreateWithoutUserInput, ClosetUncheckedCreateWithoutUserInput>
  }

  export type ClosetUpdateWithWhereUniqueWithoutUserInput = {
    where: ClosetWhereUniqueInput
    data: XOR<ClosetUpdateWithoutUserInput, ClosetUncheckedUpdateWithoutUserInput>
  }

  export type ClosetUpdateManyWithWhereWithoutUserInput = {
    where: ClosetScalarWhereInput
    data: XOR<ClosetUpdateManyMutationInput, ClosetUncheckedUpdateManyWithoutUserInput>
  }

  export type ClosetScalarWhereInput = {
    AND?: ClosetScalarWhereInput | ClosetScalarWhereInput[]
    OR?: ClosetScalarWhereInput[]
    NOT?: ClosetScalarWhereInput | ClosetScalarWhereInput[]
    id?: IntFilter<"Closet"> | number
    user_id?: IntFilter<"Closet"> | number
    name?: StringFilter<"Closet"> | string
    created_at?: DateTimeFilter<"Closet"> | Date | string
    updated_at?: DateTimeFilter<"Closet"> | Date | string
  }

  export type CategoryUpsertWithWhereUniqueWithoutUserInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutUserInput, CategoryUncheckedUpdateWithoutUserInput>
    create: XOR<CategoryCreateWithoutUserInput, CategoryUncheckedCreateWithoutUserInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutUserInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutUserInput, CategoryUncheckedUpdateWithoutUserInput>
  }

  export type CategoryUpdateManyWithWhereWithoutUserInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutUserInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    user_id?: IntFilter<"Category"> | number
    title?: StringFilter<"Category"> | string
    created_at?: DateTimeFilter<"Category"> | Date | string
  }

  export type OutfitUpsertWithWhereUniqueWithoutUserInput = {
    where: OutfitWhereUniqueInput
    update: XOR<OutfitUpdateWithoutUserInput, OutfitUncheckedUpdateWithoutUserInput>
    create: XOR<OutfitCreateWithoutUserInput, OutfitUncheckedCreateWithoutUserInput>
  }

  export type OutfitUpdateWithWhereUniqueWithoutUserInput = {
    where: OutfitWhereUniqueInput
    data: XOR<OutfitUpdateWithoutUserInput, OutfitUncheckedUpdateWithoutUserInput>
  }

  export type OutfitUpdateManyWithWhereWithoutUserInput = {
    where: OutfitScalarWhereInput
    data: XOR<OutfitUpdateManyMutationInput, OutfitUncheckedUpdateManyWithoutUserInput>
  }

  export type OutfitScalarWhereInput = {
    AND?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
    OR?: OutfitScalarWhereInput[]
    NOT?: OutfitScalarWhereInput | OutfitScalarWhereInput[]
    id?: IntFilter<"Outfit"> | number
    user_id?: IntFilter<"Outfit"> | number
    bucket_name?: StringNullableFilter<"Outfit"> | string | null
    image_key?: StringNullableFilter<"Outfit"> | string | null
    title?: StringFilter<"Outfit"> | string
    is_favorite?: BoolFilter<"Outfit"> | boolean
    is_recurring?: BoolFilter<"Outfit"> | boolean
    wear_count?: IntFilter<"Outfit"> | number
    last_worn_at?: DateTimeNullableFilter<"Outfit"> | Date | string | null
    mcp_session_id?: IntNullableFilter<"Outfit"> | number | null
    created_at?: DateTimeFilter<"Outfit"> | Date | string
    updated_at?: DateTimeFilter<"Outfit"> | Date | string
  }

  export type ChatSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    update: XOR<ChatSessionUpdateWithoutUserInput, ChatSessionUncheckedUpdateWithoutUserInput>
    create: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    data: XOR<ChatSessionUpdateWithoutUserInput, ChatSessionUncheckedUpdateWithoutUserInput>
  }

  export type ChatSessionUpdateManyWithWhereWithoutUserInput = {
    where: ChatSessionScalarWhereInput
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatSessionScalarWhereInput = {
    AND?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
    OR?: ChatSessionScalarWhereInput[]
    NOT?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
    id?: IntFilter<"ChatSession"> | number
    user_id?: IntFilter<"ChatSession"> | number
    started_at?: DateTimeFilter<"ChatSession"> | Date | string
  }

  export type MCPSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: MCPSessionWhereUniqueInput
    update: XOR<MCPSessionUpdateWithoutUserInput, MCPSessionUncheckedUpdateWithoutUserInput>
    create: XOR<MCPSessionCreateWithoutUserInput, MCPSessionUncheckedCreateWithoutUserInput>
  }

  export type MCPSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: MCPSessionWhereUniqueInput
    data: XOR<MCPSessionUpdateWithoutUserInput, MCPSessionUncheckedUpdateWithoutUserInput>
  }

  export type MCPSessionUpdateManyWithWhereWithoutUserInput = {
    where: MCPSessionScalarWhereInput
    data: XOR<MCPSessionUpdateManyMutationInput, MCPSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type MCPSessionScalarWhereInput = {
    AND?: MCPSessionScalarWhereInput | MCPSessionScalarWhereInput[]
    OR?: MCPSessionScalarWhereInput[]
    NOT?: MCPSessionScalarWhereInput | MCPSessionScalarWhereInput[]
    id?: IntFilter<"MCPSession"> | number
    user_id?: IntFilter<"MCPSession"> | number
    prompt_payload?: JsonFilter<"MCPSession">
    status?: StringFilter<"MCPSession"> | string
    created_at?: DateTimeFilter<"MCPSession"> | Date | string
    completed_at?: DateTimeNullableFilter<"MCPSession"> | Date | string | null
  }

  export type UserCreateWithoutCategoriesInput = {
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    closets?: ClosetCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    mcpSessions?: MCPSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCategoriesInput = {
    id?: number
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    closets?: ClosetUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    mcpSessions?: MCPSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
  }

  export type ClothingItemCreateWithoutCategoryInput = {
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    closet: ClosetCreateNestedOneWithoutClothingItemsInput
    bucket: S3BucketCreateNestedOneWithoutClothingItemsInput
    outfitClothingItems?: OutfitClothingItemCreateNestedManyWithoutClothingItemInput
  }

  export type ClothingItemUncheckedCreateWithoutCategoryInput = {
    id?: number
    closet_id: number
    bucket_name: string
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    outfitClothingItems?: OutfitClothingItemUncheckedCreateNestedManyWithoutClothingItemInput
  }

  export type ClothingItemCreateOrConnectWithoutCategoryInput = {
    where: ClothingItemWhereUniqueInput
    create: XOR<ClothingItemCreateWithoutCategoryInput, ClothingItemUncheckedCreateWithoutCategoryInput>
  }

  export type ClothingItemCreateManyCategoryInputEnvelope = {
    data: ClothingItemCreateManyCategoryInput | ClothingItemCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCategoriesInput = {
    update: XOR<UserUpdateWithoutCategoriesInput, UserUncheckedUpdateWithoutCategoriesInput>
    create: XOR<UserCreateWithoutCategoriesInput, UserUncheckedCreateWithoutCategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCategoriesInput, UserUncheckedUpdateWithoutCategoriesInput>
  }

  export type UserUpdateWithoutCategoriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    closets?: ClosetUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    mcpSessions?: MCPSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    closets?: ClosetUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    mcpSessions?: MCPSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClothingItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ClothingItemWhereUniqueInput
    update: XOR<ClothingItemUpdateWithoutCategoryInput, ClothingItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<ClothingItemCreateWithoutCategoryInput, ClothingItemUncheckedCreateWithoutCategoryInput>
  }

  export type ClothingItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ClothingItemWhereUniqueInput
    data: XOR<ClothingItemUpdateWithoutCategoryInput, ClothingItemUncheckedUpdateWithoutCategoryInput>
  }

  export type ClothingItemUpdateManyWithWhereWithoutCategoryInput = {
    where: ClothingItemScalarWhereInput
    data: XOR<ClothingItemUpdateManyMutationInput, ClothingItemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ClothingItemScalarWhereInput = {
    AND?: ClothingItemScalarWhereInput | ClothingItemScalarWhereInput[]
    OR?: ClothingItemScalarWhereInput[]
    NOT?: ClothingItemScalarWhereInput | ClothingItemScalarWhereInput[]
    id?: IntFilter<"ClothingItem"> | number
    closet_id?: IntFilter<"ClothingItem"> | number
    category_id?: IntFilter<"ClothingItem"> | number
    bucket_name?: StringFilter<"ClothingItem"> | string
    image_key?: StringFilter<"ClothingItem"> | string
    label?: StringFilter<"ClothingItem"> | string
    description?: StringFilter<"ClothingItem"> | string
    wear_count?: IntFilter<"ClothingItem"> | number
    last_worn_at?: DateTimeNullableFilter<"ClothingItem"> | Date | string | null
    created_at?: DateTimeFilter<"ClothingItem"> | Date | string
    updated_at?: DateTimeFilter<"ClothingItem"> | Date | string
    status?: StringFilter<"ClothingItem"> | string
  }

  export type UserCreateWithoutClosetsInput = {
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    categories?: CategoryCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    mcpSessions?: MCPSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClosetsInput = {
    id?: number
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    mcpSessions?: MCPSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClosetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClosetsInput, UserUncheckedCreateWithoutClosetsInput>
  }

  export type ClothingItemCreateWithoutClosetInput = {
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    category: CategoryCreateNestedOneWithoutClothingItemsInput
    bucket: S3BucketCreateNestedOneWithoutClothingItemsInput
    outfitClothingItems?: OutfitClothingItemCreateNestedManyWithoutClothingItemInput
  }

  export type ClothingItemUncheckedCreateWithoutClosetInput = {
    id?: number
    category_id: number
    bucket_name: string
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    outfitClothingItems?: OutfitClothingItemUncheckedCreateNestedManyWithoutClothingItemInput
  }

  export type ClothingItemCreateOrConnectWithoutClosetInput = {
    where: ClothingItemWhereUniqueInput
    create: XOR<ClothingItemCreateWithoutClosetInput, ClothingItemUncheckedCreateWithoutClosetInput>
  }

  export type ClothingItemCreateManyClosetInputEnvelope = {
    data: ClothingItemCreateManyClosetInput | ClothingItemCreateManyClosetInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClosetsInput = {
    update: XOR<UserUpdateWithoutClosetsInput, UserUncheckedUpdateWithoutClosetsInput>
    create: XOR<UserCreateWithoutClosetsInput, UserUncheckedCreateWithoutClosetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClosetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClosetsInput, UserUncheckedUpdateWithoutClosetsInput>
  }

  export type UserUpdateWithoutClosetsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    mcpSessions?: MCPSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClosetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    mcpSessions?: MCPSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClothingItemUpsertWithWhereUniqueWithoutClosetInput = {
    where: ClothingItemWhereUniqueInput
    update: XOR<ClothingItemUpdateWithoutClosetInput, ClothingItemUncheckedUpdateWithoutClosetInput>
    create: XOR<ClothingItemCreateWithoutClosetInput, ClothingItemUncheckedCreateWithoutClosetInput>
  }

  export type ClothingItemUpdateWithWhereUniqueWithoutClosetInput = {
    where: ClothingItemWhereUniqueInput
    data: XOR<ClothingItemUpdateWithoutClosetInput, ClothingItemUncheckedUpdateWithoutClosetInput>
  }

  export type ClothingItemUpdateManyWithWhereWithoutClosetInput = {
    where: ClothingItemScalarWhereInput
    data: XOR<ClothingItemUpdateManyMutationInput, ClothingItemUncheckedUpdateManyWithoutClosetInput>
  }

  export type ClothingItemCreateWithoutBucketInput = {
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    closet: ClosetCreateNestedOneWithoutClothingItemsInput
    category: CategoryCreateNestedOneWithoutClothingItemsInput
    outfitClothingItems?: OutfitClothingItemCreateNestedManyWithoutClothingItemInput
  }

  export type ClothingItemUncheckedCreateWithoutBucketInput = {
    id?: number
    closet_id: number
    category_id: number
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    outfitClothingItems?: OutfitClothingItemUncheckedCreateNestedManyWithoutClothingItemInput
  }

  export type ClothingItemCreateOrConnectWithoutBucketInput = {
    where: ClothingItemWhereUniqueInput
    create: XOR<ClothingItemCreateWithoutBucketInput, ClothingItemUncheckedCreateWithoutBucketInput>
  }

  export type ClothingItemCreateManyBucketInputEnvelope = {
    data: ClothingItemCreateManyBucketInput | ClothingItemCreateManyBucketInput[]
    skipDuplicates?: boolean
  }

  export type OutfitCreateWithoutBucketInput = {
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutOutfitsInput
    mcpSession?: MCPSessionCreateNestedOneWithoutOutfitsInput
    outfitClothingItems?: OutfitClothingItemCreateNestedManyWithoutOutfitInput
    mcpSessionOutfits?: MCPSessionOutfitCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUncheckedCreateWithoutBucketInput = {
    id?: number
    user_id: number
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    mcp_session_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    outfitClothingItems?: OutfitClothingItemUncheckedCreateNestedManyWithoutOutfitInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedCreateNestedManyWithoutOutfitInput
  }

  export type OutfitCreateOrConnectWithoutBucketInput = {
    where: OutfitWhereUniqueInput
    create: XOR<OutfitCreateWithoutBucketInput, OutfitUncheckedCreateWithoutBucketInput>
  }

  export type OutfitCreateManyBucketInputEnvelope = {
    data: OutfitCreateManyBucketInput | OutfitCreateManyBucketInput[]
    skipDuplicates?: boolean
  }

  export type ClothingItemUpsertWithWhereUniqueWithoutBucketInput = {
    where: ClothingItemWhereUniqueInput
    update: XOR<ClothingItemUpdateWithoutBucketInput, ClothingItemUncheckedUpdateWithoutBucketInput>
    create: XOR<ClothingItemCreateWithoutBucketInput, ClothingItemUncheckedCreateWithoutBucketInput>
  }

  export type ClothingItemUpdateWithWhereUniqueWithoutBucketInput = {
    where: ClothingItemWhereUniqueInput
    data: XOR<ClothingItemUpdateWithoutBucketInput, ClothingItemUncheckedUpdateWithoutBucketInput>
  }

  export type ClothingItemUpdateManyWithWhereWithoutBucketInput = {
    where: ClothingItemScalarWhereInput
    data: XOR<ClothingItemUpdateManyMutationInput, ClothingItemUncheckedUpdateManyWithoutBucketInput>
  }

  export type OutfitUpsertWithWhereUniqueWithoutBucketInput = {
    where: OutfitWhereUniqueInput
    update: XOR<OutfitUpdateWithoutBucketInput, OutfitUncheckedUpdateWithoutBucketInput>
    create: XOR<OutfitCreateWithoutBucketInput, OutfitUncheckedCreateWithoutBucketInput>
  }

  export type OutfitUpdateWithWhereUniqueWithoutBucketInput = {
    where: OutfitWhereUniqueInput
    data: XOR<OutfitUpdateWithoutBucketInput, OutfitUncheckedUpdateWithoutBucketInput>
  }

  export type OutfitUpdateManyWithWhereWithoutBucketInput = {
    where: OutfitScalarWhereInput
    data: XOR<OutfitUpdateManyMutationInput, OutfitUncheckedUpdateManyWithoutBucketInput>
  }

  export type ClosetCreateWithoutClothingItemsInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutClosetsInput
  }

  export type ClosetUncheckedCreateWithoutClothingItemsInput = {
    id?: number
    user_id: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClosetCreateOrConnectWithoutClothingItemsInput = {
    where: ClosetWhereUniqueInput
    create: XOR<ClosetCreateWithoutClothingItemsInput, ClosetUncheckedCreateWithoutClothingItemsInput>
  }

  export type CategoryCreateWithoutClothingItemsInput = {
    title: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutClothingItemsInput = {
    id?: number
    user_id: number
    title: string
    created_at?: Date | string
  }

  export type CategoryCreateOrConnectWithoutClothingItemsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutClothingItemsInput, CategoryUncheckedCreateWithoutClothingItemsInput>
  }

  export type S3BucketCreateWithoutClothingItemsInput = {
    name: string
    region: string
    created_at?: Date | string
    outfits?: OutfitCreateNestedManyWithoutBucketInput
  }

  export type S3BucketUncheckedCreateWithoutClothingItemsInput = {
    name: string
    region: string
    created_at?: Date | string
    outfits?: OutfitUncheckedCreateNestedManyWithoutBucketInput
  }

  export type S3BucketCreateOrConnectWithoutClothingItemsInput = {
    where: S3BucketWhereUniqueInput
    create: XOR<S3BucketCreateWithoutClothingItemsInput, S3BucketUncheckedCreateWithoutClothingItemsInput>
  }

  export type OutfitClothingItemCreateWithoutClothingItemInput = {
    added_at?: Date | string
    outfit: OutfitCreateNestedOneWithoutOutfitClothingItemsInput
  }

  export type OutfitClothingItemUncheckedCreateWithoutClothingItemInput = {
    outfit_id: number
    added_at?: Date | string
  }

  export type OutfitClothingItemCreateOrConnectWithoutClothingItemInput = {
    where: OutfitClothingItemWhereUniqueInput
    create: XOR<OutfitClothingItemCreateWithoutClothingItemInput, OutfitClothingItemUncheckedCreateWithoutClothingItemInput>
  }

  export type OutfitClothingItemCreateManyClothingItemInputEnvelope = {
    data: OutfitClothingItemCreateManyClothingItemInput | OutfitClothingItemCreateManyClothingItemInput[]
    skipDuplicates?: boolean
  }

  export type ClosetUpsertWithoutClothingItemsInput = {
    update: XOR<ClosetUpdateWithoutClothingItemsInput, ClosetUncheckedUpdateWithoutClothingItemsInput>
    create: XOR<ClosetCreateWithoutClothingItemsInput, ClosetUncheckedCreateWithoutClothingItemsInput>
    where?: ClosetWhereInput
  }

  export type ClosetUpdateToOneWithWhereWithoutClothingItemsInput = {
    where?: ClosetWhereInput
    data: XOR<ClosetUpdateWithoutClothingItemsInput, ClosetUncheckedUpdateWithoutClothingItemsInput>
  }

  export type ClosetUpdateWithoutClothingItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClosetsNestedInput
  }

  export type ClosetUncheckedUpdateWithoutClothingItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutClothingItemsInput = {
    update: XOR<CategoryUpdateWithoutClothingItemsInput, CategoryUncheckedUpdateWithoutClothingItemsInput>
    create: XOR<CategoryCreateWithoutClothingItemsInput, CategoryUncheckedCreateWithoutClothingItemsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutClothingItemsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutClothingItemsInput, CategoryUncheckedUpdateWithoutClothingItemsInput>
  }

  export type CategoryUpdateWithoutClothingItemsInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutClothingItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type S3BucketUpsertWithoutClothingItemsInput = {
    update: XOR<S3BucketUpdateWithoutClothingItemsInput, S3BucketUncheckedUpdateWithoutClothingItemsInput>
    create: XOR<S3BucketCreateWithoutClothingItemsInput, S3BucketUncheckedCreateWithoutClothingItemsInput>
    where?: S3BucketWhereInput
  }

  export type S3BucketUpdateToOneWithWhereWithoutClothingItemsInput = {
    where?: S3BucketWhereInput
    data: XOR<S3BucketUpdateWithoutClothingItemsInput, S3BucketUncheckedUpdateWithoutClothingItemsInput>
  }

  export type S3BucketUpdateWithoutClothingItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    outfits?: OutfitUpdateManyWithoutBucketNestedInput
  }

  export type S3BucketUncheckedUpdateWithoutClothingItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    outfits?: OutfitUncheckedUpdateManyWithoutBucketNestedInput
  }

  export type OutfitClothingItemUpsertWithWhereUniqueWithoutClothingItemInput = {
    where: OutfitClothingItemWhereUniqueInput
    update: XOR<OutfitClothingItemUpdateWithoutClothingItemInput, OutfitClothingItemUncheckedUpdateWithoutClothingItemInput>
    create: XOR<OutfitClothingItemCreateWithoutClothingItemInput, OutfitClothingItemUncheckedCreateWithoutClothingItemInput>
  }

  export type OutfitClothingItemUpdateWithWhereUniqueWithoutClothingItemInput = {
    where: OutfitClothingItemWhereUniqueInput
    data: XOR<OutfitClothingItemUpdateWithoutClothingItemInput, OutfitClothingItemUncheckedUpdateWithoutClothingItemInput>
  }

  export type OutfitClothingItemUpdateManyWithWhereWithoutClothingItemInput = {
    where: OutfitClothingItemScalarWhereInput
    data: XOR<OutfitClothingItemUpdateManyMutationInput, OutfitClothingItemUncheckedUpdateManyWithoutClothingItemInput>
  }

  export type OutfitClothingItemScalarWhereInput = {
    AND?: OutfitClothingItemScalarWhereInput | OutfitClothingItemScalarWhereInput[]
    OR?: OutfitClothingItemScalarWhereInput[]
    NOT?: OutfitClothingItemScalarWhereInput | OutfitClothingItemScalarWhereInput[]
    outfit_id?: IntFilter<"OutfitClothingItem"> | number
    clothing_item_id?: IntFilter<"OutfitClothingItem"> | number
    added_at?: DateTimeFilter<"OutfitClothingItem"> | Date | string
  }

  export type UserCreateWithoutOutfitsInput = {
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    closets?: ClosetCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    mcpSessions?: MCPSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOutfitsInput = {
    id?: number
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    closets?: ClosetUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    mcpSessions?: MCPSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOutfitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOutfitsInput, UserUncheckedCreateWithoutOutfitsInput>
  }

  export type S3BucketCreateWithoutOutfitsInput = {
    name: string
    region: string
    created_at?: Date | string
    clothingItems?: ClothingItemCreateNestedManyWithoutBucketInput
  }

  export type S3BucketUncheckedCreateWithoutOutfitsInput = {
    name: string
    region: string
    created_at?: Date | string
    clothingItems?: ClothingItemUncheckedCreateNestedManyWithoutBucketInput
  }

  export type S3BucketCreateOrConnectWithoutOutfitsInput = {
    where: S3BucketWhereUniqueInput
    create: XOR<S3BucketCreateWithoutOutfitsInput, S3BucketUncheckedCreateWithoutOutfitsInput>
  }

  export type MCPSessionCreateWithoutOutfitsInput = {
    prompt_payload: JsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    completed_at?: Date | string | null
    user: UserCreateNestedOneWithoutMcpSessionsInput
    mcpSessionOutfits?: MCPSessionOutfitCreateNestedManyWithoutMcpSessionInput
  }

  export type MCPSessionUncheckedCreateWithoutOutfitsInput = {
    id?: number
    user_id: number
    prompt_payload: JsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    completed_at?: Date | string | null
    mcpSessionOutfits?: MCPSessionOutfitUncheckedCreateNestedManyWithoutMcpSessionInput
  }

  export type MCPSessionCreateOrConnectWithoutOutfitsInput = {
    where: MCPSessionWhereUniqueInput
    create: XOR<MCPSessionCreateWithoutOutfitsInput, MCPSessionUncheckedCreateWithoutOutfitsInput>
  }

  export type OutfitClothingItemCreateWithoutOutfitInput = {
    added_at?: Date | string
    clothingItem: ClothingItemCreateNestedOneWithoutOutfitClothingItemsInput
  }

  export type OutfitClothingItemUncheckedCreateWithoutOutfitInput = {
    clothing_item_id: number
    added_at?: Date | string
  }

  export type OutfitClothingItemCreateOrConnectWithoutOutfitInput = {
    where: OutfitClothingItemWhereUniqueInput
    create: XOR<OutfitClothingItemCreateWithoutOutfitInput, OutfitClothingItemUncheckedCreateWithoutOutfitInput>
  }

  export type OutfitClothingItemCreateManyOutfitInputEnvelope = {
    data: OutfitClothingItemCreateManyOutfitInput | OutfitClothingItemCreateManyOutfitInput[]
    skipDuplicates?: boolean
  }

  export type MCPSessionOutfitCreateWithoutOutfitInput = {
    added_at?: Date | string
    mcpSession: MCPSessionCreateNestedOneWithoutMcpSessionOutfitsInput
  }

  export type MCPSessionOutfitUncheckedCreateWithoutOutfitInput = {
    mcp_session_id: number
    added_at?: Date | string
  }

  export type MCPSessionOutfitCreateOrConnectWithoutOutfitInput = {
    where: MCPSessionOutfitWhereUniqueInput
    create: XOR<MCPSessionOutfitCreateWithoutOutfitInput, MCPSessionOutfitUncheckedCreateWithoutOutfitInput>
  }

  export type MCPSessionOutfitCreateManyOutfitInputEnvelope = {
    data: MCPSessionOutfitCreateManyOutfitInput | MCPSessionOutfitCreateManyOutfitInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOutfitsInput = {
    update: XOR<UserUpdateWithoutOutfitsInput, UserUncheckedUpdateWithoutOutfitsInput>
    create: XOR<UserCreateWithoutOutfitsInput, UserUncheckedCreateWithoutOutfitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOutfitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOutfitsInput, UserUncheckedUpdateWithoutOutfitsInput>
  }

  export type UserUpdateWithoutOutfitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    closets?: ClosetUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    mcpSessions?: MCPSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOutfitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    closets?: ClosetUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    mcpSessions?: MCPSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type S3BucketUpsertWithoutOutfitsInput = {
    update: XOR<S3BucketUpdateWithoutOutfitsInput, S3BucketUncheckedUpdateWithoutOutfitsInput>
    create: XOR<S3BucketCreateWithoutOutfitsInput, S3BucketUncheckedCreateWithoutOutfitsInput>
    where?: S3BucketWhereInput
  }

  export type S3BucketUpdateToOneWithWhereWithoutOutfitsInput = {
    where?: S3BucketWhereInput
    data: XOR<S3BucketUpdateWithoutOutfitsInput, S3BucketUncheckedUpdateWithoutOutfitsInput>
  }

  export type S3BucketUpdateWithoutOutfitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItems?: ClothingItemUpdateManyWithoutBucketNestedInput
  }

  export type S3BucketUncheckedUpdateWithoutOutfitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItems?: ClothingItemUncheckedUpdateManyWithoutBucketNestedInput
  }

  export type MCPSessionUpsertWithoutOutfitsInput = {
    update: XOR<MCPSessionUpdateWithoutOutfitsInput, MCPSessionUncheckedUpdateWithoutOutfitsInput>
    create: XOR<MCPSessionCreateWithoutOutfitsInput, MCPSessionUncheckedCreateWithoutOutfitsInput>
    where?: MCPSessionWhereInput
  }

  export type MCPSessionUpdateToOneWithWhereWithoutOutfitsInput = {
    where?: MCPSessionWhereInput
    data: XOR<MCPSessionUpdateWithoutOutfitsInput, MCPSessionUncheckedUpdateWithoutOutfitsInput>
  }

  export type MCPSessionUpdateWithoutOutfitsInput = {
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMcpSessionsNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUpdateManyWithoutMcpSessionNestedInput
  }

  export type MCPSessionUncheckedUpdateWithoutOutfitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcpSessionOutfits?: MCPSessionOutfitUncheckedUpdateManyWithoutMcpSessionNestedInput
  }

  export type OutfitClothingItemUpsertWithWhereUniqueWithoutOutfitInput = {
    where: OutfitClothingItemWhereUniqueInput
    update: XOR<OutfitClothingItemUpdateWithoutOutfitInput, OutfitClothingItemUncheckedUpdateWithoutOutfitInput>
    create: XOR<OutfitClothingItemCreateWithoutOutfitInput, OutfitClothingItemUncheckedCreateWithoutOutfitInput>
  }

  export type OutfitClothingItemUpdateWithWhereUniqueWithoutOutfitInput = {
    where: OutfitClothingItemWhereUniqueInput
    data: XOR<OutfitClothingItemUpdateWithoutOutfitInput, OutfitClothingItemUncheckedUpdateWithoutOutfitInput>
  }

  export type OutfitClothingItemUpdateManyWithWhereWithoutOutfitInput = {
    where: OutfitClothingItemScalarWhereInput
    data: XOR<OutfitClothingItemUpdateManyMutationInput, OutfitClothingItemUncheckedUpdateManyWithoutOutfitInput>
  }

  export type MCPSessionOutfitUpsertWithWhereUniqueWithoutOutfitInput = {
    where: MCPSessionOutfitWhereUniqueInput
    update: XOR<MCPSessionOutfitUpdateWithoutOutfitInput, MCPSessionOutfitUncheckedUpdateWithoutOutfitInput>
    create: XOR<MCPSessionOutfitCreateWithoutOutfitInput, MCPSessionOutfitUncheckedCreateWithoutOutfitInput>
  }

  export type MCPSessionOutfitUpdateWithWhereUniqueWithoutOutfitInput = {
    where: MCPSessionOutfitWhereUniqueInput
    data: XOR<MCPSessionOutfitUpdateWithoutOutfitInput, MCPSessionOutfitUncheckedUpdateWithoutOutfitInput>
  }

  export type MCPSessionOutfitUpdateManyWithWhereWithoutOutfitInput = {
    where: MCPSessionOutfitScalarWhereInput
    data: XOR<MCPSessionOutfitUpdateManyMutationInput, MCPSessionOutfitUncheckedUpdateManyWithoutOutfitInput>
  }

  export type MCPSessionOutfitScalarWhereInput = {
    AND?: MCPSessionOutfitScalarWhereInput | MCPSessionOutfitScalarWhereInput[]
    OR?: MCPSessionOutfitScalarWhereInput[]
    NOT?: MCPSessionOutfitScalarWhereInput | MCPSessionOutfitScalarWhereInput[]
    mcp_session_id?: IntFilter<"MCPSessionOutfit"> | number
    outfit_id?: IntFilter<"MCPSessionOutfit"> | number
    added_at?: DateTimeFilter<"MCPSessionOutfit"> | Date | string
  }

  export type OutfitCreateWithoutOutfitClothingItemsInput = {
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutOutfitsInput
    bucket?: S3BucketCreateNestedOneWithoutOutfitsInput
    mcpSession?: MCPSessionCreateNestedOneWithoutOutfitsInput
    mcpSessionOutfits?: MCPSessionOutfitCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUncheckedCreateWithoutOutfitClothingItemsInput = {
    id?: number
    user_id: number
    bucket_name?: string | null
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    mcp_session_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    mcpSessionOutfits?: MCPSessionOutfitUncheckedCreateNestedManyWithoutOutfitInput
  }

  export type OutfitCreateOrConnectWithoutOutfitClothingItemsInput = {
    where: OutfitWhereUniqueInput
    create: XOR<OutfitCreateWithoutOutfitClothingItemsInput, OutfitUncheckedCreateWithoutOutfitClothingItemsInput>
  }

  export type ClothingItemCreateWithoutOutfitClothingItemsInput = {
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
    closet: ClosetCreateNestedOneWithoutClothingItemsInput
    category: CategoryCreateNestedOneWithoutClothingItemsInput
    bucket: S3BucketCreateNestedOneWithoutClothingItemsInput
  }

  export type ClothingItemUncheckedCreateWithoutOutfitClothingItemsInput = {
    id?: number
    closet_id: number
    category_id: number
    bucket_name: string
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
  }

  export type ClothingItemCreateOrConnectWithoutOutfitClothingItemsInput = {
    where: ClothingItemWhereUniqueInput
    create: XOR<ClothingItemCreateWithoutOutfitClothingItemsInput, ClothingItemUncheckedCreateWithoutOutfitClothingItemsInput>
  }

  export type OutfitUpsertWithoutOutfitClothingItemsInput = {
    update: XOR<OutfitUpdateWithoutOutfitClothingItemsInput, OutfitUncheckedUpdateWithoutOutfitClothingItemsInput>
    create: XOR<OutfitCreateWithoutOutfitClothingItemsInput, OutfitUncheckedCreateWithoutOutfitClothingItemsInput>
    where?: OutfitWhereInput
  }

  export type OutfitUpdateToOneWithWhereWithoutOutfitClothingItemsInput = {
    where?: OutfitWhereInput
    data: XOR<OutfitUpdateWithoutOutfitClothingItemsInput, OutfitUncheckedUpdateWithoutOutfitClothingItemsInput>
  }

  export type OutfitUpdateWithoutOutfitClothingItemsInput = {
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOutfitsNestedInput
    bucket?: S3BucketUpdateOneWithoutOutfitsNestedInput
    mcpSession?: MCPSessionUpdateOneWithoutOutfitsNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateWithoutOutfitClothingItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcp_session_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mcpSessionOutfits?: MCPSessionOutfitUncheckedUpdateManyWithoutOutfitNestedInput
  }

  export type ClothingItemUpsertWithoutOutfitClothingItemsInput = {
    update: XOR<ClothingItemUpdateWithoutOutfitClothingItemsInput, ClothingItemUncheckedUpdateWithoutOutfitClothingItemsInput>
    create: XOR<ClothingItemCreateWithoutOutfitClothingItemsInput, ClothingItemUncheckedCreateWithoutOutfitClothingItemsInput>
    where?: ClothingItemWhereInput
  }

  export type ClothingItemUpdateToOneWithWhereWithoutOutfitClothingItemsInput = {
    where?: ClothingItemWhereInput
    data: XOR<ClothingItemUpdateWithoutOutfitClothingItemsInput, ClothingItemUncheckedUpdateWithoutOutfitClothingItemsInput>
  }

  export type ClothingItemUpdateWithoutOutfitClothingItemsInput = {
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    closet?: ClosetUpdateOneRequiredWithoutClothingItemsNestedInput
    category?: CategoryUpdateOneRequiredWithoutClothingItemsNestedInput
    bucket?: S3BucketUpdateOneRequiredWithoutClothingItemsNestedInput
  }

  export type ClothingItemUncheckedUpdateWithoutOutfitClothingItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    closet_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: StringFieldUpdateOperationsInput | string
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutChatSessionsInput = {
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    closets?: ClosetCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    mcpSessions?: MCPSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatSessionsInput = {
    id?: number
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    closets?: ClosetUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    mcpSessions?: MCPSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
  }

  export type ChatMessageCreateWithoutSessionInput = {
    role: string
    content: string
    sent_at?: Date | string
  }

  export type ChatMessageUncheckedCreateWithoutSessionInput = {
    id?: number
    role: string
    content: string
    sent_at?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput>
  }

  export type ChatMessageCreateManySessionInputEnvelope = {
    data: ChatMessageCreateManySessionInput | ChatMessageCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChatSessionsInput = {
    update: XOR<UserUpdateWithoutChatSessionsInput, UserUncheckedUpdateWithoutChatSessionsInput>
    create: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatSessionsInput, UserUncheckedUpdateWithoutChatSessionsInput>
  }

  export type UserUpdateWithoutChatSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    closets?: ClosetUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    mcpSessions?: MCPSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    closets?: ClosetUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    mcpSessions?: MCPSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSessionInput, ChatMessageUncheckedUpdateWithoutSessionInput>
    create: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSessionInput, ChatMessageUncheckedUpdateWithoutSessionInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSessionInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    session_id?: IntFilter<"ChatMessage"> | number
    role?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    sent_at?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatSessionCreateWithoutMessagesInput = {
    started_at?: Date | string
    user: UserCreateNestedOneWithoutChatSessionsInput
  }

  export type ChatSessionUncheckedCreateWithoutMessagesInput = {
    id?: number
    user_id: number
    started_at?: Date | string
  }

  export type ChatSessionCreateOrConnectWithoutMessagesInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
  }

  export type ChatSessionUpsertWithoutMessagesInput = {
    update: XOR<ChatSessionUpdateWithoutMessagesInput, ChatSessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    where?: ChatSessionWhereInput
  }

  export type ChatSessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatSessionWhereInput
    data: XOR<ChatSessionUpdateWithoutMessagesInput, ChatSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatSessionUpdateWithoutMessagesInput = {
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatSessionsNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutMcpSessionsInput = {
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    closets?: ClosetCreateNestedManyWithoutUserInput
    categories?: CategoryCreateNestedManyWithoutUserInput
    outfits?: OutfitCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMcpSessionsInput = {
    id?: number
    email: string
    username: string
    password_hash: string
    google_id?: string | null
    coin_balance?: number
    security_question: string
    security_answer_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    role?: string
    avatar_url?: string | null
    avatar_key?: string | null
    closets?: ClosetUncheckedCreateNestedManyWithoutUserInput
    categories?: CategoryUncheckedCreateNestedManyWithoutUserInput
    outfits?: OutfitUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMcpSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMcpSessionsInput, UserUncheckedCreateWithoutMcpSessionsInput>
  }

  export type OutfitCreateWithoutMcpSessionInput = {
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutOutfitsInput
    bucket?: S3BucketCreateNestedOneWithoutOutfitsInput
    outfitClothingItems?: OutfitClothingItemCreateNestedManyWithoutOutfitInput
    mcpSessionOutfits?: MCPSessionOutfitCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUncheckedCreateWithoutMcpSessionInput = {
    id?: number
    user_id: number
    bucket_name?: string | null
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    outfitClothingItems?: OutfitClothingItemUncheckedCreateNestedManyWithoutOutfitInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedCreateNestedManyWithoutOutfitInput
  }

  export type OutfitCreateOrConnectWithoutMcpSessionInput = {
    where: OutfitWhereUniqueInput
    create: XOR<OutfitCreateWithoutMcpSessionInput, OutfitUncheckedCreateWithoutMcpSessionInput>
  }

  export type OutfitCreateManyMcpSessionInputEnvelope = {
    data: OutfitCreateManyMcpSessionInput | OutfitCreateManyMcpSessionInput[]
    skipDuplicates?: boolean
  }

  export type MCPSessionOutfitCreateWithoutMcpSessionInput = {
    added_at?: Date | string
    outfit: OutfitCreateNestedOneWithoutMcpSessionOutfitsInput
  }

  export type MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput = {
    outfit_id: number
    added_at?: Date | string
  }

  export type MCPSessionOutfitCreateOrConnectWithoutMcpSessionInput = {
    where: MCPSessionOutfitWhereUniqueInput
    create: XOR<MCPSessionOutfitCreateWithoutMcpSessionInput, MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput>
  }

  export type MCPSessionOutfitCreateManyMcpSessionInputEnvelope = {
    data: MCPSessionOutfitCreateManyMcpSessionInput | MCPSessionOutfitCreateManyMcpSessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMcpSessionsInput = {
    update: XOR<UserUpdateWithoutMcpSessionsInput, UserUncheckedUpdateWithoutMcpSessionsInput>
    create: XOR<UserCreateWithoutMcpSessionsInput, UserUncheckedCreateWithoutMcpSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMcpSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMcpSessionsInput, UserUncheckedUpdateWithoutMcpSessionsInput>
  }

  export type UserUpdateWithoutMcpSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    closets?: ClosetUpdateManyWithoutUserNestedInput
    categories?: CategoryUpdateManyWithoutUserNestedInput
    outfits?: OutfitUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMcpSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    google_id?: NullableStringFieldUpdateOperationsInput | string | null
    coin_balance?: IntFieldUpdateOperationsInput | number
    security_question?: StringFieldUpdateOperationsInput | string
    security_answer_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    avatar_key?: NullableStringFieldUpdateOperationsInput | string | null
    closets?: ClosetUncheckedUpdateManyWithoutUserNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutUserNestedInput
    outfits?: OutfitUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OutfitUpsertWithWhereUniqueWithoutMcpSessionInput = {
    where: OutfitWhereUniqueInput
    update: XOR<OutfitUpdateWithoutMcpSessionInput, OutfitUncheckedUpdateWithoutMcpSessionInput>
    create: XOR<OutfitCreateWithoutMcpSessionInput, OutfitUncheckedCreateWithoutMcpSessionInput>
  }

  export type OutfitUpdateWithWhereUniqueWithoutMcpSessionInput = {
    where: OutfitWhereUniqueInput
    data: XOR<OutfitUpdateWithoutMcpSessionInput, OutfitUncheckedUpdateWithoutMcpSessionInput>
  }

  export type OutfitUpdateManyWithWhereWithoutMcpSessionInput = {
    where: OutfitScalarWhereInput
    data: XOR<OutfitUpdateManyMutationInput, OutfitUncheckedUpdateManyWithoutMcpSessionInput>
  }

  export type MCPSessionOutfitUpsertWithWhereUniqueWithoutMcpSessionInput = {
    where: MCPSessionOutfitWhereUniqueInput
    update: XOR<MCPSessionOutfitUpdateWithoutMcpSessionInput, MCPSessionOutfitUncheckedUpdateWithoutMcpSessionInput>
    create: XOR<MCPSessionOutfitCreateWithoutMcpSessionInput, MCPSessionOutfitUncheckedCreateWithoutMcpSessionInput>
  }

  export type MCPSessionOutfitUpdateWithWhereUniqueWithoutMcpSessionInput = {
    where: MCPSessionOutfitWhereUniqueInput
    data: XOR<MCPSessionOutfitUpdateWithoutMcpSessionInput, MCPSessionOutfitUncheckedUpdateWithoutMcpSessionInput>
  }

  export type MCPSessionOutfitUpdateManyWithWhereWithoutMcpSessionInput = {
    where: MCPSessionOutfitScalarWhereInput
    data: XOR<MCPSessionOutfitUpdateManyMutationInput, MCPSessionOutfitUncheckedUpdateManyWithoutMcpSessionInput>
  }

  export type MCPSessionCreateWithoutMcpSessionOutfitsInput = {
    prompt_payload: JsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    completed_at?: Date | string | null
    user: UserCreateNestedOneWithoutMcpSessionsInput
    outfits?: OutfitCreateNestedManyWithoutMcpSessionInput
  }

  export type MCPSessionUncheckedCreateWithoutMcpSessionOutfitsInput = {
    id?: number
    user_id: number
    prompt_payload: JsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    completed_at?: Date | string | null
    outfits?: OutfitUncheckedCreateNestedManyWithoutMcpSessionInput
  }

  export type MCPSessionCreateOrConnectWithoutMcpSessionOutfitsInput = {
    where: MCPSessionWhereUniqueInput
    create: XOR<MCPSessionCreateWithoutMcpSessionOutfitsInput, MCPSessionUncheckedCreateWithoutMcpSessionOutfitsInput>
  }

  export type OutfitCreateWithoutMcpSessionOutfitsInput = {
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutOutfitsInput
    bucket?: S3BucketCreateNestedOneWithoutOutfitsInput
    mcpSession?: MCPSessionCreateNestedOneWithoutOutfitsInput
    outfitClothingItems?: OutfitClothingItemCreateNestedManyWithoutOutfitInput
  }

  export type OutfitUncheckedCreateWithoutMcpSessionOutfitsInput = {
    id?: number
    user_id: number
    bucket_name?: string | null
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    mcp_session_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    outfitClothingItems?: OutfitClothingItemUncheckedCreateNestedManyWithoutOutfitInput
  }

  export type OutfitCreateOrConnectWithoutMcpSessionOutfitsInput = {
    where: OutfitWhereUniqueInput
    create: XOR<OutfitCreateWithoutMcpSessionOutfitsInput, OutfitUncheckedCreateWithoutMcpSessionOutfitsInput>
  }

  export type MCPSessionUpsertWithoutMcpSessionOutfitsInput = {
    update: XOR<MCPSessionUpdateWithoutMcpSessionOutfitsInput, MCPSessionUncheckedUpdateWithoutMcpSessionOutfitsInput>
    create: XOR<MCPSessionCreateWithoutMcpSessionOutfitsInput, MCPSessionUncheckedCreateWithoutMcpSessionOutfitsInput>
    where?: MCPSessionWhereInput
  }

  export type MCPSessionUpdateToOneWithWhereWithoutMcpSessionOutfitsInput = {
    where?: MCPSessionWhereInput
    data: XOR<MCPSessionUpdateWithoutMcpSessionOutfitsInput, MCPSessionUncheckedUpdateWithoutMcpSessionOutfitsInput>
  }

  export type MCPSessionUpdateWithoutMcpSessionOutfitsInput = {
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMcpSessionsNestedInput
    outfits?: OutfitUpdateManyWithoutMcpSessionNestedInput
  }

  export type MCPSessionUncheckedUpdateWithoutMcpSessionOutfitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outfits?: OutfitUncheckedUpdateManyWithoutMcpSessionNestedInput
  }

  export type OutfitUpsertWithoutMcpSessionOutfitsInput = {
    update: XOR<OutfitUpdateWithoutMcpSessionOutfitsInput, OutfitUncheckedUpdateWithoutMcpSessionOutfitsInput>
    create: XOR<OutfitCreateWithoutMcpSessionOutfitsInput, OutfitUncheckedCreateWithoutMcpSessionOutfitsInput>
    where?: OutfitWhereInput
  }

  export type OutfitUpdateToOneWithWhereWithoutMcpSessionOutfitsInput = {
    where?: OutfitWhereInput
    data: XOR<OutfitUpdateWithoutMcpSessionOutfitsInput, OutfitUncheckedUpdateWithoutMcpSessionOutfitsInput>
  }

  export type OutfitUpdateWithoutMcpSessionOutfitsInput = {
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOutfitsNestedInput
    bucket?: S3BucketUpdateOneWithoutOutfitsNestedInput
    mcpSession?: MCPSessionUpdateOneWithoutOutfitsNestedInput
    outfitClothingItems?: OutfitClothingItemUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateWithoutMcpSessionOutfitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcp_session_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitClothingItems?: OutfitClothingItemUncheckedUpdateManyWithoutOutfitNestedInput
  }

  export type ClosetCreateManyUserInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CategoryCreateManyUserInput = {
    id?: number
    title: string
    created_at?: Date | string
  }

  export type OutfitCreateManyUserInput = {
    id?: number
    bucket_name?: string | null
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    mcp_session_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatSessionCreateManyUserInput = {
    id?: number
    started_at?: Date | string
  }

  export type MCPSessionCreateManyUserInput = {
    id?: number
    prompt_payload: JsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    completed_at?: Date | string | null
  }

  export type ClosetUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItems?: ClothingItemUpdateManyWithoutClosetNestedInput
  }

  export type ClosetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItems?: ClothingItemUncheckedUpdateManyWithoutClosetNestedInput
  }

  export type ClosetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItems?: ClothingItemUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItems?: ClothingItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitUpdateWithoutUserInput = {
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: S3BucketUpdateOneWithoutOutfitsNestedInput
    mcpSession?: MCPSessionUpdateOneWithoutOutfitsNestedInput
    outfitClothingItems?: OutfitClothingItemUpdateManyWithoutOutfitNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bucket_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcp_session_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitClothingItems?: OutfitClothingItemUncheckedUpdateManyWithoutOutfitNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bucket_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcp_session_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUpdateWithoutUserInput = {
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPSessionUpdateWithoutUserInput = {
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outfits?: OutfitUpdateManyWithoutMcpSessionNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUpdateManyWithoutMcpSessionNestedInput
  }

  export type MCPSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outfits?: OutfitUncheckedUpdateManyWithoutMcpSessionNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedUpdateManyWithoutMcpSessionNestedInput
  }

  export type MCPSessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    prompt_payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClothingItemCreateManyCategoryInput = {
    id?: number
    closet_id: number
    bucket_name: string
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
  }

  export type ClothingItemUpdateWithoutCategoryInput = {
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    closet?: ClosetUpdateOneRequiredWithoutClothingItemsNestedInput
    bucket?: S3BucketUpdateOneRequiredWithoutClothingItemsNestedInput
    outfitClothingItems?: OutfitClothingItemUpdateManyWithoutClothingItemNestedInput
  }

  export type ClothingItemUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    closet_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: StringFieldUpdateOperationsInput | string
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    outfitClothingItems?: OutfitClothingItemUncheckedUpdateManyWithoutClothingItemNestedInput
  }

  export type ClothingItemUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    closet_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: StringFieldUpdateOperationsInput | string
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClothingItemCreateManyClosetInput = {
    id?: number
    category_id: number
    bucket_name: string
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
  }

  export type ClothingItemUpdateWithoutClosetInput = {
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutClothingItemsNestedInput
    bucket?: S3BucketUpdateOneRequiredWithoutClothingItemsNestedInput
    outfitClothingItems?: OutfitClothingItemUpdateManyWithoutClothingItemNestedInput
  }

  export type ClothingItemUncheckedUpdateWithoutClosetInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: StringFieldUpdateOperationsInput | string
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    outfitClothingItems?: OutfitClothingItemUncheckedUpdateManyWithoutClothingItemNestedInput
  }

  export type ClothingItemUncheckedUpdateManyWithoutClosetInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: StringFieldUpdateOperationsInput | string
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ClothingItemCreateManyBucketInput = {
    id?: number
    closet_id: number
    category_id: number
    image_key: string
    label: string
    description: string
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    status?: string
  }

  export type OutfitCreateManyBucketInput = {
    id?: number
    user_id: number
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    mcp_session_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ClothingItemUpdateWithoutBucketInput = {
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    closet?: ClosetUpdateOneRequiredWithoutClothingItemsNestedInput
    category?: CategoryUpdateOneRequiredWithoutClothingItemsNestedInput
    outfitClothingItems?: OutfitClothingItemUpdateManyWithoutClothingItemNestedInput
  }

  export type ClothingItemUncheckedUpdateWithoutBucketInput = {
    id?: IntFieldUpdateOperationsInput | number
    closet_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    outfitClothingItems?: OutfitClothingItemUncheckedUpdateManyWithoutClothingItemNestedInput
  }

  export type ClothingItemUncheckedUpdateManyWithoutBucketInput = {
    id?: IntFieldUpdateOperationsInput | number
    closet_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    image_key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type OutfitUpdateWithoutBucketInput = {
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOutfitsNestedInput
    mcpSession?: MCPSessionUpdateOneWithoutOutfitsNestedInput
    outfitClothingItems?: OutfitClothingItemUpdateManyWithoutOutfitNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateWithoutBucketInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcp_session_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitClothingItems?: OutfitClothingItemUncheckedUpdateManyWithoutOutfitNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateManyWithoutBucketInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mcp_session_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitClothingItemCreateManyClothingItemInput = {
    outfit_id: number
    added_at?: Date | string
  }

  export type OutfitClothingItemUpdateWithoutClothingItemInput = {
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    outfit?: OutfitUpdateOneRequiredWithoutOutfitClothingItemsNestedInput
  }

  export type OutfitClothingItemUncheckedUpdateWithoutClothingItemInput = {
    outfit_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitClothingItemUncheckedUpdateManyWithoutClothingItemInput = {
    outfit_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitClothingItemCreateManyOutfitInput = {
    clothing_item_id: number
    added_at?: Date | string
  }

  export type MCPSessionOutfitCreateManyOutfitInput = {
    mcp_session_id: number
    added_at?: Date | string
  }

  export type OutfitClothingItemUpdateWithoutOutfitInput = {
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    clothingItem?: ClothingItemUpdateOneRequiredWithoutOutfitClothingItemsNestedInput
  }

  export type OutfitClothingItemUncheckedUpdateWithoutOutfitInput = {
    clothing_item_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitClothingItemUncheckedUpdateManyWithoutOutfitInput = {
    clothing_item_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPSessionOutfitUpdateWithoutOutfitInput = {
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mcpSession?: MCPSessionUpdateOneRequiredWithoutMcpSessionOutfitsNestedInput
  }

  export type MCPSessionOutfitUncheckedUpdateWithoutOutfitInput = {
    mcp_session_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPSessionOutfitUncheckedUpdateManyWithoutOutfitInput = {
    mcp_session_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManySessionInput = {
    id?: number
    role: string
    content: string
    sent_at?: Date | string
  }

  export type ChatMessageUpdateWithoutSessionInput = {
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutfitCreateManyMcpSessionInput = {
    id?: number
    user_id: number
    bucket_name?: string | null
    image_key?: string | null
    title: string
    is_favorite?: boolean
    is_recurring?: boolean
    wear_count?: number
    last_worn_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MCPSessionOutfitCreateManyMcpSessionInput = {
    outfit_id: number
    added_at?: Date | string
  }

  export type OutfitUpdateWithoutMcpSessionInput = {
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOutfitsNestedInput
    bucket?: S3BucketUpdateOneWithoutOutfitsNestedInput
    outfitClothingItems?: OutfitClothingItemUpdateManyWithoutOutfitNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateWithoutMcpSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    outfitClothingItems?: OutfitClothingItemUncheckedUpdateManyWithoutOutfitNestedInput
    mcpSessionOutfits?: MCPSessionOutfitUncheckedUpdateManyWithoutOutfitNestedInput
  }

  export type OutfitUncheckedUpdateManyWithoutMcpSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    bucket_name?: NullableStringFieldUpdateOperationsInput | string | null
    image_key?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    is_favorite?: BoolFieldUpdateOperationsInput | boolean
    is_recurring?: BoolFieldUpdateOperationsInput | boolean
    wear_count?: IntFieldUpdateOperationsInput | number
    last_worn_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPSessionOutfitUpdateWithoutMcpSessionInput = {
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
    outfit?: OutfitUpdateOneRequiredWithoutMcpSessionOutfitsNestedInput
  }

  export type MCPSessionOutfitUncheckedUpdateWithoutMcpSessionInput = {
    outfit_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPSessionOutfitUncheckedUpdateManyWithoutMcpSessionInput = {
    outfit_id?: IntFieldUpdateOperationsInput | number
    added_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}